<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LowLevelParticleFilters Documentation</title><meta name="title" content="API · LowLevelParticleFilters Documentation"/><meta property="og:title" content="API · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="API · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../measurement_models/">Multiple measurement models</a></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="../parameter_estimation/">Overview</a></li><li><a class="tocitem" href="../param_est_ml/">Maximum-likelihood and MAP</a></li><li><a class="tocitem" href="../param_est_bayesian/">Bayesian inference</a></li><li><a class="tocitem" href="../param_est_joint/">Joint state and parameter estimation</a></li><li><a class="tocitem" href="../param_est_mukf/">MUKF for parameter estimation</a></li><li><a class="tocitem" href="../param_est_optimizer/">Using an optimizer</a></li><li><a class="tocitem" href="../param_est_identifiability/">Identifiability</a></li></ul></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="../beetle_example_imm/">IMM-filter tutorial</a></li><li><a class="tocitem" href="../rbpf_example/">Rao-Blackwellized filter tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="../adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="../neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="../friction_nn_example/">SciML: Adaptive Universal Differential Equation</a></li><li><a class="tocitem" href="../thermal_nn_example/">SciML: Learning a sunshine disturbance model</a></li><li><a class="tocitem" href="../fault_detection/">Fault detection</a></li><li><a class="tocitem" href="../ut/">Unscented transform</a></li><li><a class="tocitem" href="../disturbance_gallery/">Disturbance gallery</a></li><li><a class="tocitem" href="../sample_rate/">Influence of sample rate on performance</a></li><li><a class="tocitem" href="../cross_covariance/">Cross-covariance between dynamics and measurement</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.AdvancedParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>LowLevelParticleFilters.AuxiliaryParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}"><code>LowLevelParticleFilters.CompositeMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}} where IPM"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.EnsembleKalmanFilter"><code>LowLevelParticleFilters.EnsembleKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>LowLevelParticleFilters.ExtendedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}, NTuple{9, Any}} where IPM"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>LowLevelParticleFilters.IMM</code></a></li><li><a href="#LowLevelParticleFilters.IndexingMatrix"><code>LowLevelParticleFilters.IndexingMatrix</code></a></li><li><a href="#LowLevelParticleFilters.IndexingMatrix-Tuple{AbstractMatrix}"><code>LowLevelParticleFilters.IndexingMatrix</code></a></li><li><a href="#LowLevelParticleFilters.KalmanFilter"><code>LowLevelParticleFilters.KalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>LowLevelParticleFilters.KalmanFilteringSolution</code></a></li><li><a href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>LowLevelParticleFilters.KalmanSmoothingSolution</code></a></li><li><a href="#LowLevelParticleFilters.LinearMeasurementModel"><code>LowLevelParticleFilters.LinearMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.MUKF"><code>LowLevelParticleFilters.MUKF</code></a></li><li><a href="#LowLevelParticleFilters.MerweParams"><code>LowLevelParticleFilters.MerweParams</code></a></li><li><a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>LowLevelParticleFilters.ParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.ParticleFilteringSolution"><code>LowLevelParticleFilters.ParticleFilteringSolution</code></a></li><li><a href="#LowLevelParticleFilters.RBMeasurementModel"><code>LowLevelParticleFilters.RBMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.RBPF-Union{Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Int64, Any, Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD}"><code>LowLevelParticleFilters.RBPF</code></a></li><li><a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.RBParticle</code></a></li><li><a href="#LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}"><code>LowLevelParticleFilters.SignalNames</code></a></li><li><a href="#LowLevelParticleFilters.SignalNames"><code>LowLevelParticleFilters.SignalNames</code></a></li><li><a href="#LowLevelParticleFilters.SqExtendedKalmanFilter"><code>LowLevelParticleFilters.SqExtendedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.SqKalmanFilter"><code>LowLevelParticleFilters.SqKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.TrivialParams"><code>LowLevelParticleFilters.TrivialParams</code></a></li><li><a href="#LowLevelParticleFilters.UIKalmanFilter"><code>LowLevelParticleFilters.UIKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.UKFWeights"><code>LowLevelParticleFilters.UKFWeights</code></a></li><li><a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>LowLevelParticleFilters.UnscentedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.WikiParams"><code>LowLevelParticleFilters.WikiParams</code></a></li><li><a href="#LowLevelParticleFilters.IteratedExtendedKalmanFilter"><code>LowLevelParticleFilters.IteratedExtendedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.autotune_covariances"><code>LowLevelParticleFilters.autotune_covariances</code></a></li><li><a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>LowLevelParticleFilters.combine!</code></a></li><li><a href="#LowLevelParticleFilters.commandplot"><code>LowLevelParticleFilters.commandplot</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{SqExtendedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.covariance-Tuple{EnsembleKalmanFilter}"><code>LowLevelParticleFilters.covariance</code></a></li><li><a href="#LowLevelParticleFilters.covplot"><code>LowLevelParticleFilters.covplot</code></a></li><li><a href="#LowLevelParticleFilters.debugplot"><code>LowLevelParticleFilters.debugplot</code></a></li><li><a href="#LowLevelParticleFilters.densityplot"><code>LowLevelParticleFilters.densityplot</code></a></li><li><a href="#LowLevelParticleFilters.double_integrator_covariance"><code>LowLevelParticleFilters.double_integrator_covariance</code></a></li><li><a href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>LowLevelParticleFilters.double_integrator_covariance_smooth</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>LowLevelParticleFilters.interact!</code></a></li><li><a href="#LowLevelParticleFilters.is_indexing_matrix-Tuple{AbstractMatrix}"><code>LowLevelParticleFilters.is_indexing_matrix</code></a></li><li><a href="#LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Vararg{Any}}"><code>LowLevelParticleFilters.log_likelihood_fun</code></a></li><li><a href="#LowLevelParticleFilters.loglik"><code>LowLevelParticleFilters.loglik</code></a></li><li><a href="#LowLevelParticleFilters.loglik_x"><code>LowLevelParticleFilters.loglik_x</code></a></li><li><a href="#LowLevelParticleFilters.logsumexp!"><code>LowLevelParticleFilters.logsumexp!</code></a></li><li><a href="#LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mean_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.mean_trajectory"><code>LowLevelParticleFilters.mean_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.metropolis"><code>LowLevelParticleFilters.metropolis</code></a></li><li><a href="#LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mode_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.n_integrator_covariance"><code>LowLevelParticleFilters.n_integrator_covariance</code></a></li><li><a href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>LowLevelParticleFilters.n_integrator_covariance_smooth</code></a></li><li><a href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{EnsembleKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.sampleplot"><code>LowLevelParticleFilters.sampleplot</code></a></li><li><a href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_cov</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_mean</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_trajs</code></a></li><li><a href="#LowLevelParticleFilters.state-Tuple{EnsembleKalmanFilter}"><code>LowLevelParticleFilters.state</code></a></li><li><a href="#LowLevelParticleFilters.unscentedplot"><code>LowLevelParticleFilters.unscentedplot</code></a></li><li><a href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a></li><li><a href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a></li><li><a href="#LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.update!</code></a></li><li><a href="#LowLevelParticleFilters.validationplot"><code>LowLevelParticleFilters.validationplot</code></a></li><li><a href="#LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}"><code>LowLevelParticleFilters.weighted_cov</code></a></li><li><a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>LowLevelParticleFilters.weighted_mean</code></a></li><li><a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any}"><code>LowLevelParticleFilters.weighted_mean</code></a></li><li><a href="#LowLevelParticleFilters.weighted_quantile-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.weighted_quantile</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!-Union{Tuple{IPD}, Tuple{SqExtendedKalmanFilter{IPD}, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any, Real}} where IPD"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!-Union{Tuple{CF}, Tuple{MF}, Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM, MF, CF}"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li></ul><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.AdvancedParticleFilter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AdvancedParticleFilter(N::Integer, dynamics::Function, measurement::Function, measurement_likelihood, dynamics_density, initial_density; p = NullParameters(), threads = false, kwargs...)</code></pre><p>This type represents a standard particle filter but affords extra flexibility compared to the <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a> type, e.g., non-additive noise in the dynamics and measurement functions.</p><p>See the docs for more information: https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/#AdvancedParticleFilter-1</p><p><strong>Arguments:</strong></p><ul><li><code>N</code>: Number of particles</li><li><code>dynamics</code>: A discrete-time dynamics function <code>(x, u, p, t, noise=false) -&gt; x⁺</code>. It&#39;s important that the <code>noise</code> argument defaults to <code>false</code>.</li><li><code>measurement</code>: A measurement function <code>(x, u, p, t, noise=false) -&gt; y</code>. It&#39;s important that the <code>noise</code> argument defaults to <code>false</code>.</li><li><code>measurement_likelihood</code>: A function <code>(x, u, y, p, t)-&gt;logl</code> to evaluate the log-likelihood of a measurement.</li><li><code>dynamics_density</code>: This field is not used by the advanced filter and can be set to <code>nothing</code>.</li><li><code>initial_density</code>: The distribution of the initial state.</li><li><code>threads</code>: use threads to propagate particles in parallel. Only activate this if your dynamics is thread-safe. <code>SeeToDee.SimpleColloc</code> is not thread-safe by default due to the use of internal caches, but <code>SeeToDee.Rk4</code> is.</li></ul><p><strong>Extended help</strong></p><p><strong>Multiple measurement models</strong></p><p>The <code>measurement_likelihood</code> function is used to evaluate the likelihood of a measurement. If you have multiple sensors and want to perform individual <code>correct!</code> steps for each, call <code>correct!(..., g = custom_likelihood_function)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/PFtypes.jl#L180-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><a class="docstring-binding" href="#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>LowLevelParticleFilters.AuxiliaryParticleFilter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AuxiliaryParticleFilter(args...; kwargs...)</code></pre><p>Takes exactly the same arguments as <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>, or an instance of <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/PFtypes.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}"><code>LowLevelParticleFilters.CompositeMeasurementModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CompositeMeasurementModel(model1, model2, ...)</code></pre><p>A composite measurement model that combines multiple measurement models. This model acts as all component models concatenated. The tuple returned from <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a> will be</p><ul><li><code>ll</code>: The sum of the log-likelihood of all component models</li><li><code>e</code>: The concatenated innovation vector</li><li><code>S</code>: A vector of the innovation covariance matrices of the component models</li><li><code>Sᵪ</code>: A vector of the Cholesky factorizations of the innovation covariance matrices of the component models</li><li><code>K</code>: A vector of the Kalman gains of the component models</li></ul><p>If all sensors operate on at the same rate, and all measurement models are of the same type, it&#39;s more efficient to use a single measurement model with a vector-valued measurement function.</p><p><strong>Fields:</strong></p><ul><li><code>models</code>: A tuple of measurement models</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L11-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}} where IPM"><a class="docstring-binding" href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}} where IPM"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EKFMeasurementModel{IPM}(measurement, R2, ny, Cjac, R12 = nothing, cache = nothing)</code></pre><p>A measurement model for the Extended Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>IPM</code>: A boolean indicating if the measurement function is inplace</li><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>Cjac</code>: The Jacobian of the measurement function <code>Cjac(x, u, p, t)</code>. If none is provided, ForwardDiff will be used.</li><li><code>R12</code>: Cross-covariance between dynamics noise at step <code>k</code> and measurement noise at step <code>k+1</code>. See Simon, D.: &quot;Optimal state estimation: Kalman, H Infinity, and nonlinear approaches&quot; sec. 7.1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L260-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><a class="docstring-binding" href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EKFMeasurementModel{T,IPM}(measurement::M, R2; nx, ny, Cjac = nothing, R12 = nothing)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li><li><code>R12</code> is the cross-covariance between dynamics noise and measurement noise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L296-L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.EnsembleKalmanFilter"><a class="docstring-binding" href="#LowLevelParticleFilters.EnsembleKalmanFilter"><code>LowLevelParticleFilters.EnsembleKalmanFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EnsembleKalmanFilter(dynamics, measurement, R1, R2, d0, N; kwargs...)</code></pre><p>An Ensemble Kalman Filter (EnKF) that uses an ensemble of states instead of explicitly tracking the covariance matrix. This makes it suitable for high-dimensional systems where covariance matrices become intractable.</p><p>This implementation uses the <strong>Stochastic EnKF</strong> formulation with perturbed observations.</p><p><strong>Arguments</strong></p><ul><li><code>dynamics</code>: Dynamics function <code>f(x, u, p, t) -&gt; x⁺</code></li><li><code>measurement</code>: Measurement function <code>h(x, u, p, t) -&gt; y</code></li><li><code>R1</code>: Process noise covariance matrix</li><li><code>R2</code>: Measurement noise covariance matrix</li><li><code>d0</code>: Initial state distribution (must support <code>rand</code> and have fields <code>μ</code> and <code>Σ</code>)</li><li><code>N::Int</code>: Number of ensemble members</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>nu::Int</code>: Number of inputs (required)</li><li><code>ny::Int = size(R2, 1)</code>: Number of outputs</li><li><code>p = NullParameters()</code>: Parameters passed to dynamics and measurement functions</li><li><code>Ts = 1.0</code>: Sample time</li><li><code>inflation = 1.0</code>: Covariance inflation factor (≥1.0). Values &gt; 1.0 inflate the ensemble spread after each prediction step to prevent filter divergence.</li><li><code>rng = Random.Xoshiro()</code>: Random number generator</li><li><code>names = default_names(...)</code>: Signal names for plotting</li></ul><p><strong>Algorithm</strong></p><p><strong>Predict Step</strong></p><p>For each ensemble member <code>i = 1:N</code>:</p><p class="math-container">\[x_i^- = f(x_i, u, p, t) + w_i \quad \text{where } w_i \sim \mathcal{N}(0, R_1)\]</p><p><strong>Correct Step (Stochastic EnKF)</strong></p><ol><li>Ensemble mean: <span>$\bar{x} = \frac{1}{N} \sum_i x_i$</span></li><li>Anomaly matrix: <span>$X&#39; = [x_1 - \bar{x}, \ldots, x_N - \bar{x}]$</span></li><li>Predicted measurements: <span>$y_i = h(x_i, u, p, t)$</span>, <span>$\bar{y} = \frac{1}{N} \sum_i y_i$</span></li><li>Measurement anomalies: <span>$Y&#39; = [y_1 - \bar{y}, \ldots, y_N - \bar{y}]$</span></li><li>Kalman gain: <span>$K = X&#39;(Y&#39;)^T (Y&#39;(Y&#39;)^T / (N-1) + R_2)^{-1}$</span></li><li>Perturbed observations: <span>$y_i^{pert} = y + \varepsilon_i$</span> where <span>$\varepsilon_i \sim \mathcal{N}(0, R_2)$</span></li><li>Update: <span>$x_i^+ = x_i^- + K(y_i^{pert} - y_i)$</span></li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LowLevelParticleFilters, LinearAlgebra, Distributions

nx, nu, ny = 2, 1, 1
N = 100  # Number of ensemble members

# Linear system
A = [0.9 0.1; 0.0 0.95]
B = [0.0; 1.0;;]
C = [1.0 0.0]

dynamics(x, u, p, t) = A*x + B*u
measurement(x, u, p, t) = C*x

R1 = 0.01*I(nx)
R2 = 0.1*I(ny)
d0 = MvNormal(zeros(nx), I(nx))

enkf = EnsembleKalmanFilter(dynamics, measurement, R1, R2, d0, N; nu, ny)

# Use like other filters
u, y = [randn(nu)], [randn(ny)]
enkf(u[1], y[1])  # One filtering step
x̂ = state(enkf)  # Ensemble mean
P = covariance(enkf)  # Sample covariance</code></pre><p>See also <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>, <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/enkf.jl#L1-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.ExtendedKalmanFilter"><a class="docstring-binding" href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>LowLevelParticleFilters.ExtendedKalmanFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExtendedKalmanFilter(kf, dynamics, measurement; Ajac, Cjac)
ExtendedKalmanFilter(dynamics, measurement, R1,R2,d0=MvNormal(Matrix(R1)); nu::Int, p = NullParameters(), α = 1.0, check = true)</code></pre><p>A nonlinear state estimator propagating uncertainty using linearization.</p><p>The constructor to the extended Kalman filter takes dynamics and measurement functions, and either covariance matrices, or a <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. If the former constructor is used, the number of inputs to the system dynamics, <code>nu</code>, must be explicitly provided with a keyword argument.</p><p>By default, the filter will internally linearize the dynamics using ForwardDiff. User provided Jacobian functions can be provided as keyword arguments <code>Ajac</code> and <code>Cjac</code>. These functions should have the signature <code>(x,u,p,t)::AbstractMatrix</code> where <code>x</code> is the state, <code>u</code> is the input, <code>p</code> is the parameters, and <code>t</code> is the time.</p><p>The dynamics and measurement function are on the following form</p><pre><code class="nohighlight hljs">x(t+1) = dynamics(x, u, p, t) + w
y      = measurement(x, u, p, t) + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices <code>R1, R2</code> can be time varying such that, e.g., <code>R1[:, :, t]</code> contains the <span>$R_1$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Rfun(x, u, p, t) -&gt; R</code></pre><p>This allows for, e.g., handling functions where the dynamics disturbance <span>$w$</span> is an input argument to the function, by linearizing the dynamics w.r.t. the disturbance input in a function for <span>$R_1$</span>, like this (assuming the dynamics have the function signalture <code>f(x, u, p, t, w)</code>):</p><pre><code class="nohighlight hljs">function R1fun(x,u,p,t)
    Bw = ForwardDiff.jacobian(w-&gt;f(x, u, p, t, w), zeros(length(w)))
    Bw * R1 * Bw&#39;
end</code></pre><p>When providing functions, the dimensions of the state, input and output, <code>nx, nu, ny</code> must be provided as keyword arguments to the <code>ExtendedKalmanFilter</code> constructor since these cannot be inferred from the function signature. For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p>See also <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> which is typically more accurate than <code>ExtendedKalmanFilter</code>. See <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> for detailed instructions on how to set up a Kalman filter <code>kf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ekf.jl#L10-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}, NTuple{9, Any}} where IPM"><a class="docstring-binding" href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}, NTuple{9, Any}} where IPM"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IEKFMeasurementModel{IPM}(measurement, R2, ny, Cjac, R12 = nothing, step = 1.0, maxiters = 10, epsilon = 1e-8, cache = nothing)</code></pre><p>A measurement model for the Iterated Extended Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>IPM</code>: A boolean indicating if the measurement function is inplace</li><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>Cjac</code>: The Jacobian of the measurement function <code>Cjac(x, u, p, t)</code>. If none is provided, ForwardDiff will be used.</li><li><code>R12</code>: Cross-covariance between dynamics noise at step <code>k</code> and measurement noise at step <code>k+1</code>. See Simon, D.: &quot;Optimal state estimation: Kalman, H Infinity, and nonlinear approaches&quot; sec. 7.1</li><li><code>step</code>: The step size in the Gauss-Newton method. Should be Float64 between 0 and 1.</li><li><code>maxiters</code>: The maximum number of iterations of the Gauss-Newton method inside the IEKF</li><li><code>epsilon</code>: The convergence criterion for the Gauss-Newton method inside the IEKF</li><li><code>cache</code>: A cache for the Jacobian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L411-L427">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><a class="docstring-binding" href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IEKFMeasurementModel{T,IPM}(measurement::M, R2; nx, ny, Cjac = nothing, R12 = nothing, step = 1.0, maxiters = 10, epsilon = 1e-8)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li><li><code>R12</code> is the cross-covariance between dynamics noise and measurement noise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L457-L463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>LowLevelParticleFilters.IMM</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IMM(models, P, μ; check = true, p = NullParameters(), interact = true)</code></pre><p>Interacting Multiple Model (IMM) filter. This filter is a combination of multiple Kalman-type filters, each with its own state and covariance. The IMM filter is a probabilistically weighted average of the states and covariances of the individual filters. The weights are determined by the probability matrix <code>P</code> and the mixing probabilities <code>μ</code>.</p><p>This implmentation allows for any combination of Kalman-type estimators to be used in the internal ensemble of models, and is not limited to linear estimators. This class of models encompasses others, such as </p><ul><li>Jump Markov Linear Systems (JMLS)</li><li>Multiple-model filters (interactivity can be turned off by setting <code>interact=false</code>)</li><li>Multiple Hypothesis Tracking (MHT)</li></ul><div class="admonition is-warning" id="Experimental-44bb1c34e6f15648"><header class="admonition-header">Experimental<a class="admonition-anchor" href="#Experimental-44bb1c34e6f15648" title="Permalink"></a></header><div class="admonition-body"><p>This filter is currently considered experimental and the user interface may change in the future without respecting semantic versioning.</p></div></div><p>In addition to the <a href="#StatsAPI.predict!"><code>predict!</code></a> and <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a> steps, the IMM filter has an <a href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>interact!</code></a> method that updates the states and covariances of the individual filters based on the mixing probabilities. The <a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>combine!</code></a> method combines the states and covariances of the individual filters into a single state and covariance. These four functions are typically called in either of the orders</p><ul><li><code>correct!, combine!, interact!, predict!</code> (as is done in <a href="#LowLevelParticleFilters.update!"><code>update!</code></a>)</li><li><code>interact!, predict!, correct!, combine!</code> (as is done in the reference cited below)</li></ul><p>These two orders are cyclic permutations of each other, and the order used in <a href="#LowLevelParticleFilters.update!"><code>update!</code></a> is chosen to align with the order used in the other filters, where the initial condition is corrected using the first measurement, i.e., we assume the first measurement updates <span>$x(0|-1)$</span> to <span>$x(0|0)$</span>.</p><p>The initial (combined) state and covariance of the IMM filter is made up of the weighted average of the states and covariances of the individual filters. The weights are the initial mixing probabilities <code>μ</code>.</p><p>Ref: &quot;Interacting multiple model methods in target tracking: a survey&quot;, E. Mazor; A. Averbuch; Y. Bar-Shalom; J. Dayan</p><p><strong>Arguments:</strong></p><ul><li><code>models</code>: An array of Kalman-type filters, such as <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>, <a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a>, <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>, etc. The state of each model must have the same meaning, such that forming a weighted average makes sense.</li><li><code>P</code>: The mode-transition probability matrix. <code>P[i,j]</code> is the probability of transitioning from mode <code>i</code> to mode <code>j</code> (each row must sum to one).</li><li><code>μ</code>: The initial mixing probabilities. <code>μ[i]</code> is the probability of being in mode <code>i</code> at the initial contidion (must sum to one).</li><li><code>check</code>: If <code>true</code>, check that the inputs are valid. If <code>false</code>, skip the checks.</li><li><code>p</code>: Parameters for the filter. NOTE: this <code>p</code> is shared among all internal filters. The internal <code>p</code> of each filter will be overridden by this one.</li><li><code>interact</code>: If <code>true</code>, the filter will run the interaction as part of <a href="#LowLevelParticleFilters.update!"><code>update!</code></a> and <a href="#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>. If <code>false</code>, the filter will not run the interaction step. This choice can be overridden by passing the keyword argument <code>interact</code> to the respective functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/imm.jl#L18-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.IndexingMatrix"><a class="docstring-binding" href="#LowLevelParticleFilters.IndexingMatrix"><code>LowLevelParticleFilters.IndexingMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IndexingMatrix{N, VT} &lt;: AbstractMatrix{Bool}</code></pre><p>A sparse representation of a matrix containing only 0s and 1s, where each row contains exactly one 1. This is stored efficiently as a vector of column indices.</p><p><strong>Type Parameters</strong></p><ul><li><code>N::Int</code>: Number of columns in the matrix</li><li><code>VT</code>: Type of the indices vector</li></ul><p><strong>Fields</strong></p><ul><li><code>indices::VT</code>: Column indices where the 1s appear for each row</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Represents the matrix:
# [0 1 0
#  0 0 1
#  1 0 0]
I = IndexingMatrix([2, 3, 1], 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/indexing_matrix.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.IndexingMatrix-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#LowLevelParticleFilters.IndexingMatrix-Tuple{AbstractMatrix}"><code>LowLevelParticleFilters.IndexingMatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IndexingMatrix(M::AbstractMatrix)</code></pre><p>Convert a valid indexing matrix to an IndexingMatrix type. Throws an error if M is not a valid indexing matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/indexing_matrix.jl#L140-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.KalmanFilter"><a class="docstring-binding" href="#LowLevelParticleFilters.KalmanFilter"><code>LowLevelParticleFilters.KalmanFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KalmanFilter(A,B,C,D,R1,R2,d0=MvNormal(R1); p = NullParameters(), α=1, check=true)</code></pre><p>The matrices <code>A,B,C,D</code> define the dynamics</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w
y  = Cx + Du + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices can be time varying such that, e.g., <code>A[:, :, t]</code> contains the <span>$A$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Afun(x, u, p, t) -&gt; A</code></pre><p>When providing functions, the dimensions of the state, input and output, <code>nx, nu, ny</code> must be provided as keyword arguments to the <code>KalmanFilter</code> constructor since these cannot be inferred from the function signature. For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p>α is an optional &quot;forgetting factor&quot;, if this is set to a value &gt; 1, such as 1.01-1.2, the filter will, in addition to the covariance inflation due to <span>$R_1$</span>, exhibit &quot;exponential forgetting&quot; similar to a <a href="https://en.wikipedia.org/wiki/Recursive_least_squares_filter">Recursive Least-Squares (RLS) estimator</a>. It is thus possible to get a RLS-like algorithm by setting <span>$R_1=0, R_2 = 1/α$</span> and <span>$α &gt; 1$</span> (<span>$α$</span> is the inverse of the traditional RLS parameter <span>$α = 1/λ$</span>). The exact form of the covariance update is</p><p class="math-container">\[R(t+1|t) = α AR(t)A^T + R_1\]</p><p>If <code>check = true (default)</code> the function will check that the eigenvalues of <code>A</code> are less than 2 in absolute value. Large eigenvalues may be an indication that the system matrices are representing a continuous-time system and the user has forgotten to discretize it. Turn off this check by setting <code>check = false</code>.</p><p><strong>Tutorials on Kalman filtering</strong></p><p>The tutorial <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">&quot;How to tune a Kalman filter&quot;</a> details how to figure out appropriate covariance matrices for the Kalman filter, as well as how to add disturbance models to the system model. See also the <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/adaptive_kalmanfilter/">tutorial in the documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/kalman.jl#L47-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.KalmanFilteringSolution"><a class="docstring-binding" href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>LowLevelParticleFilters.KalmanFilteringSolution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KalmanFilteringSolution &lt;: AbstractKalmanFilteringSolution</code></pre><p><strong>Fields</strong></p><ul><li><code>x</code>: predictions <span>$x(t+1|t)$</span> (plotted if <code>plotx=true</code>)</li><li><code>xt</code>: filtered estimates <span>$x(t|t)$</span> (plotted if <code>plotxt=true</code>)</li><li><code>R</code>: predicted covariance matrices <span>$R(t+1|t)$</span> (plotted if <code>plotR=true</code>)</li><li><code>Rt</code>: filter covariances <span>$R(t|t)$</span> (plotted if <code>plotRt=true</code>)</li><li><code>ll</code>: loglikelihood</li><li><code>e</code>: prediction errors <span>$e(t|t-1) = y - ŷ(t|t-1)$</span> (plotted if <code>plote=true</code>)</li><li><code>K</code>: Kalman gain</li><li><code>S</code>: Cholesky factorization of innovation covariance</li></ul><p><strong>Plot</strong></p><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol, plotx=true, plotxt=true, plotR=true, plotRt=true, plote=true, plotu=true, ploty=true, plotyh=true, plotyht=true, plotSt=false, name=&quot;&quot;)</code></pre><p>where</p><ul><li><code>plotx</code>: Plot the predictions <code>x(t|t-1)</code></li><li><code>plotxt</code>: Plot the filtered estimates <code>x(t|t)</code></li><li><code>plotR</code>: Plot the predicted covariances <code>R(t|t-1)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li><code>plotRt</code>: Plot the filter covariances <code>R(t|t)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li><code>plote</code>: Plot the prediction errors <code>e(t|t-1) = y - ŷ(t|t-1)</code></li><li><code>plotu</code>: Plot the input</li><li><code>ploty</code>: Plot the measurements</li><li><code>plotyh</code>: Plot the predicted measurements <code>ŷ(t|t-1)</code></li><li><code>plotyht</code>: Plot the filtered measurements <code>ŷ(t|t)</code></li><li><code>plotS</code>: Plot the innovation covariances <code>S(t|t-1)</code> as ribbons at ±2σ on predicted measurements <code>ŷ(t|t-1)</code> (requires <code>plotyh=true</code>)</li><li><code>plotSt</code>: Plot the filtered output covariances <code>St = C*Rt*C&#39;</code> as ribbons at ±2σ on filtered measurements <code>ŷ(t|t)</code> (requires <code>plotyht=true</code>, not supported for UnscentedKalmanFilter)</li><li><code>name</code>: a string that is prepended to the labels of the plots, which is useful when plotting multiple solutions in the same plot.</li><li><code>σ = 1.96</code> The number of standard deviations covered by covariance ribbons</li></ul><p>To modify the signal names used in legend entries, construct an instance of <a href="#LowLevelParticleFilters.SignalNames"><code>SignalNames</code></a> and pass this to the filter (or directly to the plot command) using the <code>names</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/solutions.jl#L14-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.KalmanSmoothingSolution"><a class="docstring-binding" href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>LowLevelParticleFilters.KalmanSmoothingSolution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct KalmanSmoothingSolution</code></pre><p>A structure representing the solution to a Kalman smoothing problem.</p><p><strong>Fields</strong></p><ul><li><code>sol</code>: A solution object containing the results of the <em>filtering</em> process.</li><li><code>xT</code>: The smoothed state estimate.</li><li><code>RT</code>: The smoothed state covariance.</li></ul><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol; plotxT=true, plotRT=true, plotyhT=false, plotST=false, kwargs...)</code></pre><p>where</p><ul><li><code>plotxT</code>: Plot the smoothed estimates <code>x(t|T)</code></li><li><code>plotRT</code>: Plot the smoothed covariances <code>R(t|T)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li><code>plotyhT</code>: Plot the smoothed output estimates <code>ŷ(t|T) = C*x(t|T)</code></li><li><code>plotST</code>: Plot the smoothed output covariances <code>ST = C*RT*C&#39;</code> as ribbons at ±2σ on smoothed measurements <code>ŷ(t|T)</code> (requires <code>plotyhT=true</code>, not supported for UnscentedKalmanFilter)</li><li>The rest of the keyword arguments are the same as for <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a></li></ul><p>When plotting a smoothing solution, the filtering solution is also plotted. The same keyword arguments as for <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> may be used to control which signals are plotted</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/solutions.jl#L202-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.LinearMeasurementModel"><a class="docstring-binding" href="#LowLevelParticleFilters.LinearMeasurementModel"><code>LowLevelParticleFilters.LinearMeasurementModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearMeasurementModel(C, D, R2; R12 = nothing)</code></pre><p>A linear measurement model <span>$y = C*x + D*u + e$</span>.</p><p><strong>Fields:</strong></p><ul><li><code>C</code></li><li><code>D</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>R12</code>: Cross-covariance between dynamics noise at step <code>k</code> and measurement noise at step <code>k+1</code>. See Simon, D.: &quot;Optimal state estimation: Kalman, H Infinity, and nonlinear approaches&quot; sec. 7.1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L344-L355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.MUKF"><a class="docstring-binding" href="#LowLevelParticleFilters.MUKF"><code>LowLevelParticleFilters.MUKF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MUKF(; dynamics, nl_measurement_model::RBMeasurementModel, A, Cl, R1, d0, nxn, nu, ny, Ts=1.0, p=NullParameters(), weight_params=MerweParams(), names=default_names(length(d0.μ), nu, ny, &quot;MUKF&quot;))</code></pre><p>Marginalized Unscented Kalman Filter for mixed linear/nonlinear state-space models.</p><div class="admonition is-warning" id="Experimental-44bb1c34e6f15648"><header class="admonition-header">Experimental<a class="admonition-anchor" href="#Experimental-44bb1c34e6f15648" title="Permalink"></a></header><div class="admonition-body"><p>This filter is currently considered experimental and the user interface may change in the future without respecting semantic versioning.</p></div></div><p>This filter combines the Unscented Kalman Filter (UKF) for the nonlinear substate with a standard Kalman filters for the linear substate. This approach provides improved accuracy compared to linearization-based methods while remaining more efficient than standard UKF. This filter is sometimes referred to as a Rao-Blackwellized Unscented Kalman Filter, similar to the <a href="../rbpf_example/#RBPF"><code>RBPF</code></a>.</p><p>Ref: Morelande, M.R. &amp; Moran, Bill. (2007). An Unscented Transformation for Conditionally Linear Models</p><p><strong>Model structure</strong></p><p>The filter assumes dynamics on the form:</p><p class="math-container">\[\begin{aligned}
x_{t+1}^n &amp;= d_n(x_t^n, u, p, t) + A_n(x_t^n, u, p, t)\, x_t^l + w_t^n \\
x_{t+1}^l &amp;= d_l(x_t^n, u, p, t) + A_l(x_t^n, u, p, t)\, x_t^l + w_t^l \\
w_t &amp;= \begin{bmatrix} w_t^n \\ w_t^l \end{bmatrix} &amp;\sim \mathcal{N}(0, R_1) \\
y_t &amp;= g(x_t^n, u, p, t) + C_l(x_t^n, u, p, t)\, x_t^l + e_t, \quad &amp;e_t \sim \mathcal{N}(0, R_2)
\end{aligned}\]</p><p>where <span>$x^n$</span> is the nonlinear substate and <span>$x^l$</span> is the linear substate. This is the <strong>conditionally linear</strong> form from Morelande &amp; Moran (2007), that is, given <span>$x^n$</span>, the dynamics and measurement models are linear in <span>$x^l$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>dynamics</code>: Function returning nonlinear contribution to the dynamics <code>[dn(xn, u, p, t); dl(xn, u, p, t)]</code>. Control input dependence can be encoded directly in both <code>dn</code> and <code>dl</code>.</li><li><code>nl_measurement_model</code>: An instance of <a href="#LowLevelParticleFilters.RBMeasurementModel"><code>RBMeasurementModel</code></a> containing <code>g</code> and <code>R_2</code></li><li><code>A</code>: Combined coupling and dynamics matrix/function <code>[An(xn); Al(xn)]</code> (nx × nxl). The first nxn rows (An) couple the linear state to the nonlinear state dynamics, and the last nxl rows (Al) define the linear state dynamics matrix.</li><li><code>Cl</code>: Measurement matrix/function <code>Cl(xn, u, p, t)</code> for the linear substate</li><li><code>R1</code>: Full process noise covariance matrix (nx × nx) for the combined state <a href="matrix or function">xn; xl</a></li><li><code>d0</code>: Initial normal distribution for the full state <a href="`LowLevelParticleFilters.SimpleMvNormal`">xn; xl</a></li><li><code>nxn</code>: Dimension of the nonlinear substate</li><li><code>nu</code>: Number of inputs</li><li><code>ny</code>: Number of measurements</li><li><code>Ts</code>: Sampling time (default: 1.0)</li><li><code>p</code>: Parameters (default: NullParameters())</li><li><code>weight_params</code>: Unscented transform parameters (default: MerweParams())</li><li><code>names</code>: Signal names for plotting</li><li><code>n_inds</code>: Optional index vector for nonlinear state elements in full state vector (default: <code>1:nxn</code>). Allows arbitrary state ordering.</li><li><code>l_inds</code>: Optional index vector for linear state elements in full state vector (default: <code>nxn+1:nx</code>). Must be provided together with <code>n_inds</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/mukf.jl#L88-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.MerweParams"><a class="docstring-binding" href="#LowLevelParticleFilters.MerweParams"><code>LowLevelParticleFilters.MerweParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MerweParams(; α = 1.0, β = 2.0, κ = 0.0)
MerweParams(; ακ = 1.0, β = 2.0) # Simplified interface with only one parameter for ακ</code></pre><p>Unscented transform parameters suggested by van der Merwe et al.</p><ul><li><code>α</code>: Scaling parameter (0,1] for the spread of the sigma points. Reduce <code>α</code> to reduce the spread.</li><li><code>β</code>: Incorporates prior knowledge of the distribution of the state.</li><li><code>κ</code>: Secondary scaling parameter that is usually set to 0. Increase <code>κ</code> to increase the spread of the sigma points.</li></ul><p>If <span>$α^2 (L + κ) &lt; L$</span> where <span>$L$</span> is the dimension of the sigma points, the center mean weight is negative. This is allowed, but may in some cases lead to an indefinite covariance matrix.</p><p>The spread of the points are <span>$α^2 (L + κ)$</span> where <span>$L$</span> is the dimension of each point. Visualize the spread by</p><pre><code class="language-julia hljs">using Plots
μ = [0.0, 0.0]
Σ = [1.0 0.0; 0.0 1.0]
pars = LowLevelParticleFilters.MerweParams(α = 1e-3, β = 2.0, κ = 0.0)
xs = LowLevelParticleFilters.sigmapoints(μ, Σ, pars)
unscentedplot(xs, pars)</code></pre><p>A simplified tuning rule </p><ul><li>If a decrease in the spread of the sigma points is desired, use <span>$κ = 0$</span> and <span>$α &lt; 1$</span>.</li><li>If an increase in the spread of the sigma points is desired, use <span>$κ &gt; 0$</span> and <span>$α = 1$</span>.</li></ul><p>This rule may be used when using the interface with only a single function argument <span>$ακ$</span>. See Nielsen, K. et al., 2021, &quot;UKF Parameter Tuning for Local Variation Smoothing&quot; for more details.</p><p>See also <a href="#LowLevelParticleFilters.WikiParams"><code>WikiParams</code></a> and <a href="#LowLevelParticleFilters.TrivialParams"><code>TrivialParams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ukf.jl#L56-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>LowLevelParticleFilters.ParticleFilter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ParticleFilter(N::Integer, dynamics, measurement, dynamics_density, measurement_density, initial_density; threads = false, p = NullParameters(), kwargs...)</code></pre><p>See the docs for more information: https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/#Particle-filter-1</p><p><strong>Arguments:</strong></p><ul><li><code>N</code>: Number of particles</li><li><code>dynamics</code>: A discrete-time dynamics function <code>(x, u, p, t) -&gt; x⁺</code></li><li><code>measurement</code>: A measurement function <code>(x, u, p, t) -&gt; y</code></li><li><code>dynamics_density</code>: A probability-density function for additive noise in the dynamics. Use <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> for non-additive noise.</li><li><code>measurement_density</code>: A probability-density function for additive measurement noise. Use <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> for non-additive noise.</li><li><code>initial_density</code>: Distribution of the initial state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/PFtypes.jl#L51-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.ParticleFilteringSolution"><a class="docstring-binding" href="#LowLevelParticleFilters.ParticleFilteringSolution"><code>LowLevelParticleFilters.ParticleFilteringSolution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParticleFilteringSolution{F, Tu, Ty, Tx, Tw, Twe, Tll} &lt;: AbstractFilteringSolution</code></pre><p><strong>Fields:</strong></p><ul><li><code>f</code>: The filter used to produce the solution.</li><li><code>u</code>: Input</li><li><code>y</code>: Output / measurements</li><li><code>x</code>: Particles, the size of this array is <code>(N,T)</code>, where <code>N</code> is the number of particles and <code>T</code> is the number of time steps. Each element represents a weighted state hypothesis with weight given by <code>we</code>.</li><li><code>w</code>: Weights (log space). These are used for internal computations.</li><li><code>we</code>: Weights (exponentiated / original space). These are the ones to use to compute weighted means etc., they sum to one for each time step.</li><li><code>ll</code>: Log likelihood</li></ul><p><strong>Plot</strong></p><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol; nbinsy=30, xreal=nothing, dim=nothing, ploty=true, q=nothing)</code></pre><p>By default, a weighted 2D histogram is plotted, one for each state variable. If a vector of quantiles are provided in <code>q</code>, the quantiles are plotted instead of the histogram. If <code>xreal</code> is provided, the true state is plotted as a scatter plot on top of the histogram. If <code>dim</code> is provided, only the specified dimension is plotted. If <code>ploty</code> is true, the measurements are plotted as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/solutions.jl#L314-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.RBMeasurementModel"><a class="docstring-binding" href="#LowLevelParticleFilters.RBMeasurementModel"><code>LowLevelParticleFilters.RBMeasurementModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RBMeasurementModel{IPM}(measurement, R2, ny)</code></pre><p>A measurement model for the Rao-Blackwellized particle filter.</p><p><strong>Fields:</strong></p><ul><li><code>measurement</code>: The contribution from the nonlinar state to the output, <span>$g$</span> in <span>$y = g(x^n, u, p, t) + C x^l + e$</span></li><li><code>R2</code>: The probability distribution of the measurement noise. If <code>C == 0</code>, this may be any distribution, otherwise it must be an instance of <code>MvNormal</code> or <code>SimpleMvNormal</code>.</li><li><code>ny</code>: The number of outputs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/rbpf.jl#L36-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.RBPF-Union{Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Int64, Any, Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD}"><a class="docstring-binding" href="#LowLevelParticleFilters.RBPF-Union{Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Int64, Any, Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD}"><code>LowLevelParticleFilters.RBPF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RBPF{IPD,IPM,AUGD}(N::Int, kf, dynamics, nl_measurement_model::AbstractMeasurementModel, R1n, d0n; An, nu::Int, Ts=1.0, p=NullParameters(), names, rng = Xoshiro(), resample_threshold=0.1)</code></pre><p>Rao-Blackwellized particle filter, also called &quot;Marginalized particle filter&quot;. The filter is effectively a particle filter where each particle is a Kalman filter that is responsible for the estimation of a linear sub structure.</p><div class="admonition is-warning" id="Experimental-44bb1c34e6f15648"><header class="admonition-header">Experimental<a class="admonition-anchor" href="#Experimental-44bb1c34e6f15648" title="Permalink"></a></header><div class="admonition-body"><p>This filter is currently considered experimental and the user interface may change in the future without respecting semantic versioning.</p></div></div><p>The filter assumes that the dynamics follow &quot;model 2&quot; in the reference below, i.e., the dynamics is described by</p><p class="math-container">\[ \begin{align}
     x_{t+1}^n &amp;= f_n(x_t^n, u, p, t) + A_n(x_t^n, u, p, t) x_t^l + w_t^n, \quad &amp;w_t^n \sim \mathcal{N}(0, R_1^n) \\
     x_{t+1}^l &amp;= A(...) x_t^l + Bu + w_t^l, \quad &amp;w_t^l \sim \mathcal{N}(0, R_1^l) \\
     y_t &amp;= g(x_t^n, u, p, t) + C(...) x_t^l + e_t, \quad &amp;e_t \sim \mathcal{N}(0, R_2)
 \end{align}\]</p><p>where <span>$x^n$</span> is a subset of the state that has nonlinear dynamics, and <span>$x^l$</span> is the linear part of the state. The entire state vector is represented by a special type <a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>RBParticle</code></a> that behaves like the vector <code>[xn; xl]</code>, but stores <code>xn, xl</code> and the covariance <code>R</code> or <code>xl</code> separately.</p><ul><li><code>N</code>: Number of particles</li><li><code>kf</code>: The internal Kalman filter that will be used for the linear part. This encodes the dynamics of the linear subspace. The matrices <span>$A, B, C, D, R_1^l$</span> of the Kalman filter may be functions of <code>x, u, p, t</code> that return a matrix. The state <code>x</code> received by such functions is of type <a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>RBParticle</code></a> with the fields <code>xn</code> and <code>xl</code>.</li><li><code>dynamics</code>: The nonlinear part <span>$f_n$</span> of the dynamics of the nonlinear substate <code>f(xn, u, p, t)</code></li><li><code>nl_measurement_model</code>: An instance of <a href="#LowLevelParticleFilters.RBMeasurementModel"><code>RBMeasurementModel</code></a> that stores <span>$g$</span> and the measurement noise distribution <span>$R_2$</span>.</li><li><code>R1n</code>: The noise distribution of the nonlinear state dynamics, this may be a covariance matrix or a distribution. If <code>An = nothing</code>, this may be any distribution, otherwise it must be an instance of <code>MvNormal</code> or <code>SimpleMvNormal</code>.</li><li><code>d0n</code>: The initial distribution of the nonlinear state <span>$x_0^n$</span>.</li><li><code>An</code>: The matrix that describes the linear effect on the nonlinear state, i.e., <span>$A_n x^l$</span>. This may be a matrix or a function of <span>$x, u, p, t$</span> that returns a matrix. Pass <code>An = nothing</code> if there is no linear effect on the nonlinear state. The <code>x</code> received by such a function is of type <a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>RBParticle</code></a> with the fields <code>xn</code> and <code>xl</code>.</li><li><code>nu</code>: The number of control inputs</li><li><code>Ts</code>: The sampling time</li><li><code>p</code>: Parameters</li><li><code>names</code>: Signal names, an instance of <a href="#LowLevelParticleFilters.SignalNames"><code>SignalNames</code></a></li><li><code>rng</code>: Random number generator</li><li><code>resample_threshold</code>: The threshold for resampling</li></ul><p>Based on the article <a href="https://people.isy.liu.se/rt/schon/Publications/SchonGN2004.pdf">&quot;Marginalized Particle Filters for Mixed Linear/Nonlinear State-space Models&quot; by Thomas Schön, Fredrik Gustafsson, and Per-Johan Nordlund</a></p><p><strong>Extended help</strong></p><p>The paper contains an even more general model, where the linear part is linearly affected by the nonlinear state. It further details a number of special cases in which possible simplifications arise. </p><ul><li>If <code>C == 0</code> and <code>D == 0</code>, the measurement is not used by the Kalman filter and we may thus have an arbitrary probability distribution for the measurement noise.</li><li>If <code>An == 0</code>, the nonlinear state is not affected by the linear state and we may have an arbitrary probability distribution for the nonlinear state noise <code>R1n</code>. Otherwise <code>R1n</code> must be Gaussian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/rbpf.jl#L81-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.RBParticle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RBParticle(xn, xl, R) &lt;: AbstractVector</code></pre><p>A struct that represents the state of a Rao-Blackwellized particle filter. The struct is an abstract vector, and when indexed like a vector it behaves as <code>[xn; xl]</code>. To access nonlinear or linear substate individually, access the fields <code>xn</code> and <code>xl</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>xn</code>: The nonlinear state vector</li><li><code>xl</code>: The linear state vector</li><li><code>R</code>: The covariance matrix for the linear state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/rbpf.jl#L7-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.SignalNames"><a class="docstring-binding" href="#LowLevelParticleFilters.SignalNames"><code>LowLevelParticleFilters.SignalNames</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SignalNames(; x, u, y, name)</code></pre><p>A structure representing the names of the signals in a system.</p><ul><li><code>x::Vector{String}</code>: Names of the state variables</li><li><code>u::Vector{String}</code>: Names of the input variables</li><li><code>y::Vector{String}</code>: Names of the output variables</li><li><code>name::String</code>: Name of the system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/signalnames.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}"><code>LowLevelParticleFilters.SignalNames</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SignalNames(sn::SignalNames, name)</code></pre><p>Copy the <code>SignalNames</code> structure and change the name of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/signalnames.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.SqExtendedKalmanFilter"><a class="docstring-binding" href="#LowLevelParticleFilters.SqExtendedKalmanFilter"><code>LowLevelParticleFilters.SqExtendedKalmanFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SqExtendedKalmanFilter(kf, dynamics, measurement; Ajac, Cjac)
SqExtendedKalmanFilter(dynamics, measurement, R1,R2,d0=MvNormal(Matrix(R1)); nu::Int, p = NullParameters(), α = 1.0, check = true)</code></pre><p>A nonlinear state estimator propagating uncertainty using linearization with square-root covariance representation.</p><p>This filter combines the Extended Kalman Filter&#39;s ability to handle nonlinear dynamics with the Square-root Kalman Filter&#39;s numerical stability. It maintains the covariance in Cholesky factorized form, ensuring positive definiteness and improved numerical conditioning.</p><p>The constructor takes dynamics and measurement functions, and either covariance matrices or a <a href="#LowLevelParticleFilters.SqKalmanFilter"><code>SqKalmanFilter</code></a>. If the former constructor is used, the number of inputs to the system dynamics, <code>nu</code>, must be explicitly provided.</p><p>By default, the filter will internally linearize the dynamics using ForwardDiff. User provided Jacobian functions can be provided as keyword arguments <code>Ajac</code> and <code>Cjac</code>. These functions should have the signature <code>(x,u,p,t)::AbstractMatrix</code> where <code>x</code> is the state, <code>u</code> is the input, <code>p</code> is the parameters, and <code>t</code> is the time.</p><p>The dynamics and measurement function are on the following form:</p><pre><code class="nohighlight hljs">x(t+1) = dynamics(x, u, p, t) + w
y      = measurement(x, u, p, t) + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>For the square-root formulation, <code>R1</code> and <code>R2</code> can be provided as:</p><ul><li>Regular covariance matrices (will be converted to Cholesky factors internally)</li><li><code>UpperTriangular</code> matrices representing the Cholesky factors</li></ul><p>See also <a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a> for the standard formulation and <a href="#LowLevelParticleFilters.SqKalmanFilter"><code>SqKalmanFilter</code></a> for the linear square-root filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_ekf.jl#L15-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.SqKalmanFilter"><a class="docstring-binding" href="#LowLevelParticleFilters.SqKalmanFilter"><code>LowLevelParticleFilters.SqKalmanFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SqKalmanFilter(A,B,C,D,R1,R2,d0=MvNormal(R1); p = NullParameters(), α=1)</code></pre><p>A standard Kalman filter on square-root form. This filter may have better numerical performance when the covariance matrices are ill-conditioned.</p><p>The matrices <code>A,B,C,D</code> define the dynamics</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w
y  = Cx + Du + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices can be time varying such that, e.g., <code>A[:, :, t]</code> contains the <span>$A$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Afun(x, u, p, t) -&gt; A</code></pre><p>The covariance matrices <code>R1</code> and <code>R2</code> are the covariance matrices of the process noise and measurement noise, respectively. They can be provided as a matrix, as an <code>UpperTriangular</code> matrix representing the Cholesky factor. If <code>R1</code> or <code>R2</code> is a function, it must return the upper triangular Cholesky factor of the covariance matrix at the given time index.</p><p>The internal fields storing covariance matrices are for this filter storing the upper-triangular Cholesky factor.</p><p>α is an optional &quot;forgetting factor&quot;, if this is set to a value &gt; 1, such as 1.01-1.2, the filter will, in addition to the covariance inflation due to <span>$R_1$</span>, exhibit &quot;exponential forgetting&quot; similar to a <a href="https://en.wikipedia.org/wiki/Recursive_least_squares_filter">Recursive Least-Squares (RLS) estimator</a>. It is thus possible to get a RLS-like algorithm by setting <span>$R_1=0, R_2 = 1/α$</span> and <span>$α &gt; 1$</span> (<span>$α$</span> is the inverse of the traditional RLS parameter <span>$α = 1/λ$</span>). The form of the covariance update is</p><p class="math-container">\[R(t+1|t) = α AR(t)A^T + R_1\]</p><p>Ref: &quot;A Square-Root Kalman Filter Using Only QR Decompositions&quot;, Kevin Tracy https://arxiv.org/abs/2208.06452</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_kalman.jl#L19-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.TrivialParams"><a class="docstring-binding" href="#LowLevelParticleFilters.TrivialParams"><code>LowLevelParticleFilters.TrivialParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TrivialParams()</code></pre><p>Unscented transform parameters representing a trivial choice of weights, where all weights are equal.</p><p>See also <a href="#LowLevelParticleFilters.WikiParams"><code>WikiParams</code></a> and <a href="#LowLevelParticleFilters.MerweParams"><code>MerweParams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ukf.jl#L110-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.UIKalmanFilter"><a class="docstring-binding" href="#LowLevelParticleFilters.UIKalmanFilter"><code>LowLevelParticleFilters.UIKalmanFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UIKalmanFilter(kf::KalmanFilter, G)
UIKalmanFilter(A, B, C, D, G, R1, R2, d0; kwargs...)</code></pre><p>An Unknown Input Kalman Filter for estimating both state and unknown inputs in linear systems.</p><div class="admonition is-warning" id="Experimental-44bb1c34e6f15648"><header class="admonition-header">Experimental<a class="admonition-anchor" href="#Experimental-44bb1c34e6f15648" title="Permalink"></a></header><div class="admonition-body"><p>This filter is currently considered experimental and the user interface may change in the future without respecting semantic versioning.</p></div></div><p>This filter implements the algorithm from Gillijns &amp; De Moor (2007), &quot;Unbiased minimum-variance input and state estimation for linear discrete-time systems&quot;, which provides optimal minimum-variance unbiased estimates of both the state <code>x</code> and unknown input <code>d</code>, without augmenting the state vector.</p><p>The system is assumed to be on the form:</p><pre><code class="nohighlight hljs">x(k+1) = A*x(k) + B*u(k) + G*d(k) + w(k)
y(k)   = C*x(k) + D*u(k) + e(k)</code></pre><p>where <code>d(k)</code> is an unknown input vector, <code>w ~ N(0, R1)</code>, and <code>e ~ N(0, R2)</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>kf::KalmanFilter</code>: An existing Kalman filter containing A, B, C, D, R1, R2, and initial state</li><li><code>G</code>: Unknown input matrix (nx × nd) or function <code>G(x,u,p,t)</code> returning such a matrix</li><li><code>A, B, C, D, R1, R2, d0</code>: Standard Kalman filter parameters (see <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>)</li></ul><p><strong>Requirements:</strong></p><p>The filter requires that <code>rank(C*G) = size(G,2)</code> (full column rank). This ensures that the unknown input can be uniquely estimated from the measurements. If this does not hold, consider an augmented state Kalman filter instead, for which a looser observability condition holds.</p><p><strong>Returns from correct!:</strong></p><p>In addition to the standard Kalman filter outputs <code>(ll, e, S, Sᵪ, K)</code>, the <code>correct!</code> function also returns:</p><ul><li><code>d</code>: The estimate of the unknown input d(k-1)</li><li><code>M</code>: The matrix M used for unknown input estimation (weighted least squares matrix)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">sol = forward_trajectory(uikf, u, y)
sol.extra.d # Estimated unknown inputs over time</code></pre><p><strong>Reference:</strong></p><p>Gillijns, S., &amp; De Moor, B. (2007). Unbiased minimum-variance input and state estimation for linear discrete-time systems. Automatica, 43(1), 111-116.</p><p>See also <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>, <a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/uikf.jl#L1-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><a class="docstring-binding" href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UKFMeasurementModel{inplace_measurement,augmented_measurement}(measurement, R2, ny, ne, innovation, mean, cov, cross_cov, weight_params, cache = nothing)</code></pre><p>A measurement model for the Unscented Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>ne</code>: If <code>augmented_measurement</code> is <code>true</code>, the number of measurement noise variables</li><li><code>innovation(y::AbstractVector, yh::AbstractVector)</code> where the arguments represent (measured output, predicted output)</li><li><code>mean(ys::AbstractVector{&lt;:AbstractVector})</code>: computes the mean of the vector of vectors of output sigma points.</li><li><code>cov(ys::AbstractVector{&lt;:AbstractVector}, y::AbstractVector)</code>: computes the covariance matrix of the output sigma points.</li><li><code>cross_cov(xs::AbstractVector{&lt;:AbstractVector}, x::AbstractVector, ys::AbstractVector{&lt;:AbstractVector}, y::AbstractVector, W::UKFWeights)</code> where the arguments represents (state sigma points, mean state, output sigma points, mean output, weights). The function should return the weighted <strong>cross-covariance</strong> matrix between the state and output sigma points.</li><li><code>weight_params</code>: A type that holds the parameters for the unscented-transform weights. See <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> and <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/dev/ut/">Docs: Unscented transform</a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L93-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}"><a class="docstring-binding" href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UKFMeasurementModel{T,IPM,AUGM}(measurement, R2; nx, ny, ne = nothing, innovation = -, mean = weighted_mean, cov = weighted_cov, cross_cov = cross_cov, static = nothing)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li><li><code>AUGM</code> is a boolean indicating if the measurement model is augmented</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/measurement_model.jl#L144-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.UKFWeights"><a class="docstring-binding" href="#LowLevelParticleFilters.UKFWeights"><code>LowLevelParticleFilters.UKFWeights</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UKFWeights</code></pre><p>Weights for the Unscented Transform.</p><p>Sigmapoints are by convention ordered such that the center (mean) point is first.</p><p><strong>Fields</strong></p><ul><li><code>wm</code>: center weight when computing mean</li><li><code>wc</code>: center weight when computing covariance</li><li><code>wmi</code>: off-center weight when computing mean</li><li><code>wci</code>: off-center weight when computing covariance</li><li><code>W</code>: Cholesky weight</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ukf.jl#L120-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><a class="docstring-binding" href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>LowLevelParticleFilters.UnscentedKalmanFilter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UnscentedKalmanFilter(dynamics, measurement, R1, R2, d0=MvNormal(Matrix(R1)); p = NullParameters(), ny, nu, weight_params)
UnscentedKalmanFilter{IPD,IPM,AUGD,AUGM}(dynamics, measurement_model::AbstractMeasurementModel, R1, d0=SimpleMvNormal(R1); p=NullParameters(), nu, weight_params)</code></pre><p>A nonlinear state estimator propagating uncertainty using the unscented transform.</p><p>The dynamics and measurement function are on <em>either</em> of the following forms</p><pre><code class="nohighlight hljs">x&#39; = dynamics(x, u, p, t) + w
y  = measurement(x, u, p, t) + e</code></pre><pre><code class="nohighlight hljs">x&#39; = dynamics(x, u, p, t, w)
y  = measurement(x, u, p, t, e)</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code>. The former (default) assums that the noise is additive and added <em>after</em> the dynamics and measurement updates, while the latter assumes that the dynamics functions take an additional argument corresponding to the noise term. The latter form (sometimes refered to as the &quot;augmented&quot; form) is useful when the noise is multiplicative or when the noise is added <em>before</em> the dynamics and measurement updates. See &quot;Augmented UKF&quot; below for more details on how to use this form. In both cases should the noise be modeled as discrete-time white noise, see Discretization: <a href="../discretization/#Covariance-matrices">Covariance matrices</a>.</p><p>The matrices <code>R1, R2</code> can be time varying such that, e.g., <code>R1[:, :, t]</code> contains the <span>$R_1$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Rfun(x, u, p, t) -&gt; R</code></pre><p>For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p><code>ny, nu</code> indicate the number of outputs and inputs.</p><p><strong>Custom type of <code>u</code></strong></p><p>The input <code>u</code> may be of any type, e.g., a named tuple or a custom struct. The <code>u</code> provided in the input data is passed directly to the dynamics and measurement functions, so as long as the type is compatible with the dynamics it will work out. The one exception where this will not work is when calling <code>simulate</code>, which assumes that <code>u</code> is an array.</p><p><strong>Augmented UKF</strong></p><p>If the noise is not additive, one may use the augmented form of the UKF. In this form, the dynamics functions take additional input arguments that correspond to the noise terms. To enable this form, the typed constructor</p><pre><code class="nohighlight hljs">UnscentedKalmanFilter{inplace_dynamics,inplace_measurement,augmented_dynamics,augmented_measurement}(...)</code></pre><p>is used, where the Boolean type parameters have the following meaning</p><ul><li><code>inplace_dynamics</code>: If <code>true</code>, the dynamics function operates in-place, i.e., it modifies the first argument in <code>dynamics(dx, x, u, p, t)</code>. Default is <code>false</code>.</li><li><code>inplace_measurement</code>: If <code>true</code>, the measurement function operates in-place, i.e., it modifies the first argument in <code>measurement(y, x, u, p, t)</code>. Default is <code>false</code>.</li><li><code>augmented_dynamics</code>: If <code>true</code> the dynamics function is augmented with an additional noise input <code>w</code>, i.e., <code>dynamics(x, u, p, t, w)</code>. Default is <code>false</code>.</li><li><code>augmented_measurement</code>: If <code>true</code> the measurement function is agumented with an additional noise input <code>e</code>, i.e., <code>measurement(x, u, p, t, e)</code>. Default is <code>false</code>. (If the measurement noise has fewer degrees of freedom than the number of measurements, you may failure in Cholesky factorizations, see &quot;Custom Cholesky factorization&quot; below).</li></ul><p>Use of augmented dynamics incurs extra computational cost. The number of sigma points used is <code>2L+1</code> where <code>L</code> is the length of the augmented state vector. Without augmentation, <code>L = nx</code>, with augmentation <code>L = nx + nw</code> and <code>L = nx + ne</code> for dynamics and measurement, respectively.</p><p><strong>Weight tuning</strong></p><p>The spread of the sigma points is controlled by <code>weight_params::UTParams</code>. See <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/dev/ut/">Docs: Unscented transform</a> for a tutorial. The default is <a href="#LowLevelParticleFilters.TrivialParams"><code>TrivialParams</code></a> for unweighted sigma points, other options are <a href="#LowLevelParticleFilters.WikiParams"><code>WikiParams</code></a> and <a href="#LowLevelParticleFilters.MerweParams"><code>MerweParams</code></a>.</p><p><strong>Sigma-point rejection</strong></p><p>For problems with challenging dynamics, a mechanism for rejection of sigma points after the dynamics update is provided. A function <code>reject(x) -&gt; Bool</code> can be provided through the keyword argument <code>reject</code> that returns <code>true</code> if a sigma point for <span>$x(t+1)$</span> should be rejected, e.g., if an instability or non-finite number is detected. A rejected point is replaced by the propagated mean point (the mean point cannot be rejected). This function may be provided either to the constructor of the UKF or passed to the <a href="#StatsAPI.predict!"><code>predict!</code></a> function.</p><p><strong>Enforcing contraints using sigma-point projection</strong></p><p>Constraints on the state (or output) may be enforced by projecting the sigma points onto the constraint set during the dynamics (or measurement) update. In general, two projections per update are required, one after the generation of the sigma points but before the dynamics is applied, and one after the dynamics update. No functionality for this is provided in this package, but the projection may be readibly implemented manually in the dynamics function, e.g.,</p><pre><code class="language-julia hljs">function dynamics(x, u, p, t)
    x  = project(x)  # Sigma points may have been generated outside the constraint set
    xp = f(x, u, p, t)
    xp = project(xp) # The dynamics may have moved the points outside the constraint set
    return xp
end</code></pre><p>Equality constraints can alternatively be handled by making use of a pseudo-measurement <span>$0 = C_{con}x$</span> with close to zero covariance.</p><p><strong>Custom measurement models</strong></p><p>By default, standard arithmetic mean and <code>e(y, yh) = y - yh</code> are used as mean and innovation functions.</p><p>By passing and explicitly created <a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a>, one may provide custom functions that compute the mean, the covariance and the innovation. This is useful in situations where the state or a measurement lives on a manifold. One may further override the mean and covariance functions for the state sigma points by passing the keyword arguments <code>state_mean</code> and <code>state_cov</code> to the constructor.</p><ul><li><code>state_mean(xs::AbstractVector{&lt;:AbstractVector}, w::UKFWeights)</code> computes the weighted mean of the vector of vectors of state sigma points.</li><li><code>state_cov(xs::AbstractVector{&lt;:AbstractVector}, m, w::UKFWeights)</code> where the first argument represent state sigma points and the second argument, represents the weighted mean of those points. The function should return the covariance matrix of the state sigma points weighted by <code>w</code>.</li></ul><p>See <a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a> for more details on how to set up a custom measurement model. Pass the custom measurement model as the second argument to the UKF constructor.</p><p><strong>Custom Cholesky factorization</strong></p><p>The UnscentedKalmanFilter supports providing a custom function to compute the Cholesky factorization of the covariance matrices for use in sigma-point generation.</p><p>If either of the following conditions are met, you may experience failure in internal Cholesky factorizations:</p><ul><li>The dynamics noise or measurement noise covariance matrices (<span>$R_1, R_2$</span>) are singular</li><li>The measurement is augmented and the measurement noise has fewer degrees of freedom than the number of measurements</li><li>(Under specific technical conditions) The dynamics is augmented and the dynamics noise has fewer degrees of freedom than the number of state variables. The technical conditions are easiest to understand in the linear-systems case, where it corresponds to the Riccati equation associated with the Kalman gain not having a solution. This may happen when the pair <span>$(A, R1)$</span> has uncontrollable modes on the unit circle, for example, when there are integrating modes that are not affected through the noise.</li></ul><p>The error message may look like</p><pre><code class="nohighlight hljs">ERROR: PosDefException: matrix is not positive definite; Factorization failed.</code></pre><p>In such situations, it is advicable to reconsider the noise model and covariance matrices, alternatively, you may provide a custom Cholesky factorization function to the UKF constructor through the keyword argument <code>cholesky!</code>. The function should have the signature <code>cholesky!(A::AbstractMatrix)::Cholesky</code>. A useful alternative factorizaiton when covariance matrices are expected to be singular is <code>cholesky! = R-&gt;cholesky!(Positive, Matrix(R))</code> where the &quot;positive&quot; Cholesky factorization is provided by the package PositiveFactorizations.jl, which must be manually installed and loaded by the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ukf.jl#L293-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.WikiParams"><a class="docstring-binding" href="#LowLevelParticleFilters.WikiParams"><code>LowLevelParticleFilters.WikiParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WikiParams(; α = 1.0, β = 0.0, κ = 1.0)
WikiParams(; ακ = 1.0, β = 0.0) # Simplified interface with only one parameter for ακ</code></pre><p>Unscented transform parameters suggested at <a href="https://en.wikipedia.org/wiki/Kalman_filter#Sigma_points">Wiki: Kalman<em>filter#Sigma</em>points</a>.</p><ul><li><code>α</code>: Scaling parameter (0,1] for the spread of the sigma points. Reduce <code>α</code> to reduce the spread.</li><li><code>β</code>: Incorporates prior knowledge of the distribution of the state.</li><li><code>κ</code>: Secondary scaling parameter that is usually set to 3nx/2 or 1. Increase <code>κ</code> to increase the spread of the sigma points.</li></ul><p>If <span>$α^2 κ &lt; L$</span> where <span>$L$</span> is the dimension ofthe sigma points, the center mean weight is negative. This is allowed, but may in some cases lead to an indefinite covariance matrix.</p><p>The spread of the points are <span>$α^2 κ$</span>, that is, independent on the point dimension. Visualize the spread by</p><pre><code class="language-julia hljs">using Plots
μ = [0.0, 0.0]
Σ = [1.0 0.0; 0.0 1.0]
pars = LowLevelParticleFilters.WikiParams(α = 1.0, β = 0.0, κ = 1.0)
xs = LowLevelParticleFilters.sigmapoints(μ, Σ, pars)
unscentedplot(xs, pars)</code></pre><p>A simplified tuning rule </p><ul><li>If a decrease in the spread of the sigma points is desired, use <span>$κ = 1$</span> and <span>$α &lt; 1$</span>.</li><li>If an increase in the spread of the sigma points is desired, use <span>$κ &gt; 1$</span> and <span>$α = 1$</span>.</li></ul><p>This rule may be used when using the interface with only a single function argument <span>$ακ$</span>. See Nielsen, K. et al., 2021, &quot;UKF Parameter Tuning for Local Variation Smoothing&quot; for more details.</p><p>See also <a href="#LowLevelParticleFilters.MerweParams"><code>MerweParams</code></a> and <a href="#LowLevelParticleFilters.TrivialParams"><code>TrivialParams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ukf.jl#L2-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.IteratedExtendedKalmanFilter"><a class="docstring-binding" href="#LowLevelParticleFilters.IteratedExtendedKalmanFilter"><code>LowLevelParticleFilters.IteratedExtendedKalmanFilter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">IteratedExtendedKalmanFilter(kf, dynamics, measurement; Ajac, Cjac, step, maxiters, epsilon)
IteratedExtendedKalmanFilter(dynamics, measurement, R1,R2,d0=SimpleMvNormal(Matrix(R1)); nu::Int, ny=size(R2,1), Cjac = nothing, step = 1.0, maxiters=10, epsilon=1e-8)</code></pre><p>A nonlinear state estimator propagating uncertainty using linearization. Returns an <code>ExtendedKalmanFilter</code> object but with Gauss-Newton based iterating measurement correction step.</p><p>The constructor to the iterated version of extended Kalman filter takes dynamics and measurement functions, and either covariance matrices, or a <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. If the former constructor is used, the number of inputs to the system dynamics, <code>nu</code>, must be explicitly provided with a keyword argument.</p><p>By default, the filter will internally linearize the dynamics using ForwardDiff. User provided Jacobian functions can be provided as keyword arguments <code>Ajac</code> and <code>Cjac</code>. These functions should have the signature <code>(x,u,p,t)::AbstractMatrix</code> where <code>x</code> is the state, <code>u</code> is the input, <code>p</code> is the parameters, and <code>t</code> is the time.</p><p>The dynamics and measurement function are of the following form</p><pre><code class="nohighlight hljs">x(t+1) = dynamics(x, u, p, t) + w
y      = measurement(x, u, p, t) + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><ul><li><code>step</code> is the step size for the Gauss-Newton iterations. Float between 0 and 1. Default is 1.0 which should be good enough for most applications. For more challenging applications, a smaller step size might be necessary.</li><li><code>maxiters</code> is the maximum number of iterations. Default is 10. Usually a small number of iterations is needed. If higher number is needed, consider using UKF.</li><li><code>epsilon</code> is the convergence criterion. Default is 1e-8</li></ul><p>See also <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> which is more robust than <code>IteratedExtendedKalmanFilter</code>. See <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> for detailed instructions on how to set up a Kalman filter <code>kf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/iekf.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.autotune_covariances"><a class="docstring-binding" href="#LowLevelParticleFilters.autotune_covariances"><code>LowLevelParticleFilters.autotune_covariances</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">autotune_covariances(
    sol::KalmanFilteringSolution;
    diagonal = true,
    optimize_x0 = false,
    offset = 0.0,
    optimizer = LevenbergMarquardt(),
    show_trace = true,
    show_every = 1,
    autodiff = :forward,
    v_R1 = nothing,
    v_R2 = nothing,
    kwargs...
)</code></pre><p>Automatically tune the covariance matrices R1 and R2 (and optionally x0) of a Kalman-style filter by maximizing the log-likelihood (MLE) or log-posterior (MAP) using Gauss-Newton optimization.</p><div class="admonition is-info" id="Requires-LeastSquaresOptim.jl-3b662c4fd609ac13"><header class="admonition-header">Requires LeastSquaresOptim.jl<a class="admonition-anchor" href="#Requires-LeastSquaresOptim.jl-3b662c4fd609ac13" title="Permalink"></a></header><div class="admonition-body"><p>This function is available only if LeastSquaresOptim.jl is manually installed and loaded by the user. Install with: <code>using Pkg; Pkg.add(&quot;LeastSquaresOptim&quot;)</code></p></div></div><p><strong>Arguments</strong></p><ul><li><code>sol::KalmanFilteringSolution</code>: Solution object from <code>forward_trajectory</code></li><li><code>diagonal::Bool</code>: If true (default), only optimize diagonal elements. If false, optimize full covariance matrices.</li><li><code>optimize_x0::Bool</code>: If true, also optimize the initial state estimate (default: false)</li><li><code>offset::Real</code>: Offset added to the log-likelihood residuals to ensure positive squared residuals (default: 0.0). If you encounter an error about negative squared residuals during optimization, try increasing this value by an amount slightly larger than what is indicated in the error message.</li><li><code>optimizer</code>: Optimization algorithm from LeastSquaresOptim (default: LevenbergMarquardt())</li><li><code>show_trace::Bool</code>: Show optimization progress (default: true)</li><li><code>show_every::Int</code>: Show progress every N iterations (default: 1)</li><li><code>autodiff</code>: Automatic differentiation method (default: :forward)</li><li><code>v_R1::Union{Nothing,Real}</code>: Degrees of freedom for Inverse-Wishart prior on R1 (default: nothing, no prior). Must be &gt; nw-1 for proper prior, where nw = size(R1,1). The prior mean is automatically set to the initial R1 from the filter.</li><li><code>v_R2::Union{Nothing,Real}</code>: Degrees of freedom for Inverse-Wishart prior on R2 (default: nothing, no prior). Must be &gt; ny-1 for proper prior. The prior mean is automatically set to the initial R2 from the filter.</li><li><code>kwargs...</code>: Additional keyword arguments passed to LeastSquaresOptim.optimize!</li></ul><p><strong>Returns</strong></p><p>A named tuple containing:</p><ul><li><code>filter</code>: The filter with optimized covariance matrices (and x0 if applicable)</li><li><code>result</code>: The optimization result from LeastSquaresOptim</li><li><code>R1</code>: The optimized process noise covariance</li><li><code>R2</code>: The optimized measurement noise covariance</li><li><code>x0</code>: The optimized initial state (if <code>optimize_x0=true</code>)</li><li><code>sol_opt</code>: The solution from running <code>forward_trajectory</code> with the optimized filter</li></ul><p><strong>Maximum Likelihood Estimation (MLE)</strong></p><p>By default (when <code>v_R1</code> and <code>v_R2</code> are <code>nothing</code>), performs maximum likelihood estimation:</p><pre><code class="language-julia hljs">using LeastSquaresOptim

sol = forward_trajectory(kf, u, y)
result = autotune_covariances(sol)  # Pure MLE</code></pre><p><strong>Maximum A Posteriori (MAP) Estimation</strong></p><p>Use Inverse-Wishart priors for Bayesian regularization. The Inverse-Wishart distribution is the conjugate prior for covariance matrices. For a covariance matrix Σ with dimension n:</p><p><code>p(Σ) = InverseWishart(v, Ψ)</code></p><p>where:</p><ul><li><code>v</code> (degrees of freedom): Controls prior strength. Larger v = stronger prior. Must be &gt; n-1.</li><li>Prior mean is automatically set to the initial covariance matrices (R1<em>orig and R2</em>orig) from the filter.</li><li>Internally, the scale matrix is computed as: Ψ = (v - n - 1) * R_orig</li></ul><p>The mean of the Inverse-Wishart prior is E[Σ] = Ψ/(v - n - 1) = R_orig.</p><p>Typical choices for v:</p><ul><li>Weak prior: <code>v = n + 2</code> (prior has low confidence, stays close to MLE)</li><li>Moderate prior: <code>v = n + 5</code> to <code>n + 10</code></li><li>Strong prior: <code>v = n + 20</code> or higher (high confidence, stays close to initial guess)</li></ul><pre><code class="language-julia hljs"># MAP with weak Inverse-Wishart prior on both R1 and R2
nx, ny = 2, 2
v1 = nx + 2  # Weak prior
v2 = ny + 2

result = autotune_covariances(sol; v_R1=v1, v_R2=v2)

# MAP with prior only on R1 (useful when measurement noise is well-known)
result = autotune_covariances(sol; v_R1=nx+5)

# Strong prior to prevent overfitting with limited data
v1_strong = nx + 20
result = autotune_covariances(sol; v_R1=v1_strong)</code></pre><p><strong>Notes</strong></p><ul><li>The function uses log-likelihood optimization via <code>prediction_errors!</code> with <code>loglik=true</code></li><li>For diagonal parametrization, log-diagonal elements are optimized to ensure positivity</li><li>For full parametrization, a triangular (Cholesky-like) parametrization is used</li><li>MAP estimation adds Inverse-Wishart prior terms to the objective function</li><li>The prior mean is the initial covariance matrix from the filter, regularizing toward the initial guess</li><li>The <code>offset</code> parameter is passed to <code>prediction_errors!</code> and shifts the log-likelihood residuals</li><li>When using MAP, the optimized covariances balance fit to data (likelihood) and prior belief (prior)</li><li>x0 optimization uses MLE only (no prior on initial state)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/paramest.jl#L102-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.combine!-Tuple{IMM}"><a class="docstring-binding" href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>LowLevelParticleFilters.combine!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">combine!(imm::IMM)</code></pre><p>Combine the models of the IMM filter into a single state <code>imm.x</code> and covariance <code>imm.R</code>. This is done by taking a weighted average of the states and covariances of the individual models, where the weights are the mixing probabilities <code>μ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/imm.jl#L165-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.commandplot"><a class="docstring-binding" href="#LowLevelParticleFilters.commandplot"><code>LowLevelParticleFilters.commandplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">commandplot(pf, u, y, p=parameters(pf); kwargs...)</code></pre><p>Produce a helpful plot. For customization options (<code>kwargs...</code>), see <code>?pplot</code>. After each time step, a command from the user is requested.</p><ul><li>q: quit</li><li>s n: step <code>n</code> steps</li></ul><div class="admonition is-info" id="Note-b633e3e95be079c3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b633e3e95be079c3" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/LowLevelParticleFilters.jl#L137-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.correct!"><a class="docstring-binding" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ll, e = correct!(pf, u, y, p = parameters(f), t = index(f))</code></pre><p>Update state/weights based on measurement <code>y</code>,  returns log-likelihood and prediction error (the error is always 0 for particle filters).</p><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a>. For <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a>, this can be realized by passing a custom <code>measurement_likelihood</code> function as the keyword argument <code>g</code> to <code>correct!</code>, or by calling the lower-level function <code>measurement_equation!</code> with a custom <code>measurement_likelihood</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L149-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.correct!"><a class="docstring-binding" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">(; ll, e, S, Sᵪ, K) = correct!(enkf::EnsembleKalmanFilter, u, y, p = parameters(enkf), t = index(enkf) * enkf.Ts; R2 = enkf.R2)</code></pre><p>Perform the Stochastic EnKF measurement update with perturbed observations.</p><p>Returns log-likelihood <code>ll</code>, innovation <code>e</code>, innovation covariance <code>S</code>, its Cholesky factor <code>Sᵪ</code>, and Kalman gain <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/enkf.jl#L257-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.correct!"><a class="docstring-binding" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">(; ll, e, S, Sᵪ, K) = correct!(kf::AbstractKalmanFilter, u, y, p = parameters(kf), t::Integer = index(kf), R2)</code></pre><p>The correct step for a Kalman filter returns not only the log likelihood <code>ll</code> and the prediction error <code>e</code>, but also the covariance of the output <code>S</code>, its Cholesky factor <code>Sᵪ</code> and the Kalman gain <code>K</code>.</p><p>If <code>R2</code> stored in <code>kf</code> is a function <code>R2(x, u, p, t)</code>, this function is evaluated at the state <em>before</em> the correction is performed. The measurement noise covariance matrix <code>R2</code> stored in the filter object can optionally be overridden by passing the argument <code>R2</code>, in this case <code>R2</code> must be a matrix.</p><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L82-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.correct!"><a class="docstring-binding" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">correct!(kf::SqKalmanFilter, u, y, p = parameters(kf), t::Real = index(kf); R2 = get_mat(kf.R2, kf.x, u, p, t))</code></pre><p>For the square-root Kalman filter, a custom provided <code>R2</code> must be the upper triangular Cholesky factor of the covariance matrix of the measurement noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_kalman.jl#L131-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ll, lls, rest = correct!(imm::IMM, u, y, args; kwargs)</code></pre><p>The correct step of the IMM filter corrects each model with the measurements <code>y</code> and control input <code>u</code>. The mixing probabilities <code>imm.μ</code> are updated based on the likelihood of each model given the measurements and the transition probability matrix <code>P</code>.</p><p>The returned tuple consists of the sum of the log-likelihood of all models, the vector of individual log-likelihoods and an array of the rest of the return values from the correct step of each model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/imm.jl#L132-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.correct!-Tuple{SqExtendedKalmanFilter, Any, Any, Any, Real}"><a class="docstring-binding" href="#LowLevelParticleFilters.correct!-Tuple{SqExtendedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">correct!(kf::SqExtendedKalmanFilter, u, y, p, t; R2)</code></pre><p>Correction step for the Square-root Extended Kalman Filter. Linearizes the measurement and updates the state and Cholesky factor of covariance using QR decomposition.</p><p>If a custom <code>R2</code> is provided, it must be the upper triangular Cholesky factor (of type <code>UpperTriangular</code>) of the covariance matrix of the measurement noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_ekf.jl#L187-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}"><a class="docstring-binding" href="#LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">correct!(ukf::UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, u, y, p = parameters(ukf), t::Real = index(ukf) * ukf.Ts; R2 = get_mat(ukf.R2, ukf.x, u, p, t), mean, cross_cov, innovation)</code></pre><p>The correction step for an <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> allows the user to override, <code>R2</code>, <code>mean</code>, <code>cross_cov</code>, <code>innovation</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>u</code>: The input</li><li><code>y</code>: The measurement</li><li><code>p</code>: The parameters</li><li><code>t</code>: The current time</li><li><code>R2</code>: The measurement noise covariance matrix, or a function that returns the covariance matrix <code>(x,u,p,t)-&gt;R2</code>.</li><li><code>mean</code>: The function that computes the weighted mean of the output sigma points.</li><li><code>cross_cov</code>: The function that computes the weighted cross-covariance of the state and output sigma points.</li><li><code>innovation</code>: The function that computes the innovation between the measured output and the predicted output.</li></ul><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ukf.jl#L615-L632">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.covariance-Tuple{EnsembleKalmanFilter}"><a class="docstring-binding" href="#LowLevelParticleFilters.covariance-Tuple{EnsembleKalmanFilter}"><code>LowLevelParticleFilters.covariance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">covariance(enkf::EnsembleKalmanFilter)</code></pre><p>Return the cached sample covariance computed from the ensemble.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/enkf.jl#L186-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.covplot"><a class="docstring-binding" href="#LowLevelParticleFilters.covplot"><code>LowLevelParticleFilters.covplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">covplot(μ, Σ; n_std = 2, dims=1:2)
covplot(kf; n_std = 2, dims=1:2)</code></pre><p>Plot the covariance ellipse of the state <code>μ</code> and covariance <code>Σ</code>. <code>dims</code> indicate the two dimensions to plot, and defaults to the first two dimensions.</p><p>If a Kalman-type filter is passed, the state and covariance are extracted from the filter.</p><p>See also <code>unscentedplot</code>.</p><div class="admonition is-info" id="Note-b633e3e95be079c3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b633e3e95be079c3" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/LowLevelParticleFilters.jl#L181-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.debugplot"><a class="docstring-binding" href="#LowLevelParticleFilters.debugplot"><code>LowLevelParticleFilters.debugplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">debugplot(pf, u, y, p=parameters(pf); runall=false, kwargs...)</code></pre><p>Produce a helpful plot. For customization options (<code>kwargs...</code>), see <code>?pplot</code>.</p><ul><li><code>runall=false:</code> if true, runs all time steps befor displaying (faster), if false, displays the plot after each time step.</li></ul><p>The generated plot becomes quite heavy. Initially, try limiting your input to 100 time steps to verify that it doesn&#39;t crash.</p><div class="admonition is-info" id="Note-b633e3e95be079c3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b633e3e95be079c3" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/LowLevelParticleFilters.jl#L150-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.densityplot"><a class="docstring-binding" href="#LowLevelParticleFilters.densityplot"><code>LowLevelParticleFilters.densityplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">densityplot(x,[w])</code></pre><p>Plot (weighted) particles densities</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/plotting.jl#L72-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.double_integrator_covariance"><a class="docstring-binding" href="#LowLevelParticleFilters.double_integrator_covariance"><code>LowLevelParticleFilters.double_integrator_covariance</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">R = double_integrator_covariance(Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time integrator with piecewise constant stochastic force as input. <code>Ts</code> is the sample time. <code>σ2</code> scales the covariance matrix with the variance of the noise.</p><p>The state is assumed to be [x; ẋ] and the dynamics</p><p class="math-container">\[x^+ = Ax + Bu + w\]</p><p>where the noise input <code>w</code> has not been included in the discretization process.</p><p>This matrix is rank deficient and some applications might require a small increase in the diagonal to make it positive definite (or use <a href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>double_integrator_covariance_smooth</code></a>).</p><p>See also <a href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>double_integrator_covariance_smooth</code></a> for the version that does not assume piecewise constant noise, leading to a full-rank covariance matrix that results in sample-time invariant covariance dynamics (often favorable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/utils.jl#L117-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.double_integrator_covariance_smooth"><a class="docstring-binding" href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>LowLevelParticleFilters.double_integrator_covariance_smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">R = double_integrator_covariance_smooth(Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time integrator with continuous noise as input. Assumes the state [x; ẋ]. <code>Ts</code> is the sample time. <code>σ2</code> scales the covariance matrix with the variance of the noise.</p><p>This matrix is full rank, but can be well approximated by a rank-1 matrix as <code>double_integrator_covariance(Ts, σ2) ./ Ts</code>.</p><p>To make use of a single random number per step for augmented UKFs, but be have a resulting covariance dynamics that is approximately invariant to the sample interval, you can use the scalar noise <code>σ2 / Ts</code> instead of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/utils.jl#L171-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.forward_trajectory"><a class="docstring-binding" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sol = forward_trajectory(kf::AbstractKalmanFilter, u::Vector, y::Vector, p=parameters(kf); debug=false)</code></pre><p>Run a Kalman filter forward to perform (offline / batch) filtering along an entire trajectory <code>u, y</code>.</p><p>Returns a KalmanFilteringSolution: with the following</p><ul><li><code>x</code>: predictions <span>$x(t|t-1)$</span></li><li><code>xt</code>: filtered estimates <span>$x(t|t)$</span></li><li><code>R</code>: predicted covariance matrices <span>$R(t|t-1)$</span></li><li><code>Rt</code>: filter covariances <span>$R(t|t)$</span></li><li><code>ll</code>: loglik</li></ul><p><code>sol</code> can be plotted</p><pre><code class="nohighlight hljs">plot(sol::KalmanFilteringSolution; plotx = true, plotxt=true, plotu=true, ploty=true)</code></pre><p>See <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> for more details.</p><p><strong>Extended help</strong></p><p><strong>Very large systems</strong></p><p>If your system is very large, i.e., the dimension of the state is very large, and the arrays <code>u,y</code> are long, this function may use a lot of memory to store all covariance matrices <code>R, Rt</code>. If you do not need all the information retained by this function, you may opt to call one of the functions</p><ul><li><a href="#LowLevelParticleFilters.loglik"><code>loglik</code></a></li><li><a href="@ref"><code>LowLevelParticleFilters.sse</code></a></li><li><a href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a></li></ul><p>That store significantly less information. The amount of computation performed by all of these functions is identical, the only difference lies in what is stored and returned.</p><p><strong>Callbacks</strong></p><p>For advanced usage, such as implementing conditional resetting and adaptive covariance, one may make use of the callback functions</p><ul><li><code>pre_correct_cb(kf, u, y, p, t)</code>: called before the correction step, returns either <code>nothing</code> or a covariance matrix <code>R2</code> to use in the correction step.</li><li><code>pre_predict_cb(kf, u, y, p, t, ll, e, S, Sᵪ)</code>: called before the prediction step, returns either <code>nothing</code> or a covariance matrix <code>R1</code> to use in the prediction step. The arguments to this callback are <code>filter, input, measurement, parameters, time, loglikelihood, prediction error, innovation covariance and Cholesky factor of the innovation covariance</code>, essentially all the information available after the correct step.</li></ul><p>The filter loop consists of the following steps, in this order:</p><ol><li><code>pre_correct_cb</code></li><li><code>correct!</code></li><li><code>post_correct_cb</code> # This callback is considered internal, the signature is subject to change. This happens after correction, but before state and covariance is saved</li><li><code>pre_predict_cb</code></li><li><code>predict!</code></li><li><code>post_predict_cb</code> # This happens after prediction, but before next iteration when the state and covariance is saved</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L236-L274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.forward_trajectory"><a class="docstring-binding" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sol = forward_trajectory(pf, u::AbstractVector, y::AbstractVector, p=parameters(pf))</code></pre><p>Run the particle filter for a sequence of inputs and measurements (offline / batch filtering). Return a solution with <code>x,w,we,ll = particles, weights, expweights and loglikelihood</code></p><p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, you may transform the output particles to <code>Matrix{MonteCarloMeasurements.Particles}</code> using <code>Particles(x,we)</code>. Internally, the particles are then resampled such that they all have unit weight. This is conventient for making use of the <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/#Plotting-1">plotting facilities of MonteCarloMeasurements.jl</a>.</p><p><code>sol</code> can be plotted</p><pre><code class="nohighlight hljs">plot(sol::ParticleFilteringSolution; nbinsy=30, xreal=nothing, dim=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L323-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.forward_trajectory"><a class="docstring-binding" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">forward_trajectory(imm::IMM, u, y, p = parameters(imm); interact = true)</code></pre><p>When performing batch filtering using an <a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter, one may</p><ul><li>Override the <code>interact</code> parameter of the filter</li><li>Access the mode probabilities along the trajectory as the <code>sol.extra</code> field. This is a matrix of size <code>(n_modes, T)</code> where <code>T</code> is the length of the trajectory (length of <code>u</code> and <code>y</code>).</li></ul><p>The returned solution object is of type <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> and has the following fields:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/imm.jl#L257-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.interact!-Tuple{IMM}"><a class="docstring-binding" href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>LowLevelParticleFilters.interact!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interact!(imm::IMM)</code></pre><p>The interaction step of the IMM filter updates the state and covariance of each internal model based on the mixing probabilities <code>imm.μ</code> and the transition probability matrix <code>imm.P</code>.</p><p>Models with small mixing probabilities will have their states and covariances updated more towards the states and covariances of models with higher mixing probabilities, and vice versa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/imm.jl#L79-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.is_indexing_matrix-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#LowLevelParticleFilters.is_indexing_matrix-Tuple{AbstractMatrix}"><code>LowLevelParticleFilters.is_indexing_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_indexing_matrix(M::AbstractMatrix)</code></pre><p>Check if a matrix is a valid indexing matrix (contains only 0s and 1s with exactly one 1 per row).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/indexing_matrix.jl#L118-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Vararg{Any}}"><a class="docstring-binding" href="#LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Vararg{Any}}"><code>LowLevelParticleFilters.log_likelihood_fun</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ll(θ) = log_likelihood_fun(filter_from_parameters(θ::Vector)::Function, priors::Vector{Distribution}, u, y, p)
ll(θ) = log_likelihood_fun(filter_from_parameters(θ::Vector)::Function, priors::Vector{Distribution}, u, y, x, p)</code></pre><p>returns function θ -&gt; p(y|θ)p(θ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L258-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.loglik"><a class="docstring-binding" href="#LowLevelParticleFilters.loglik"><code>LowLevelParticleFilters.loglik</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ll = loglik(filter, u, y, p=parameters(filter))</code></pre><p>Calculate log-likelihood for entire sequences <code>u,y</code>.</p><p>See also <a href="#LowLevelParticleFilters.loglik_x"><code>loglik_x</code></a> for Kalman-type filters when an accurate state sequence <code>x</code> is available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L217-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.loglik_x"><a class="docstring-binding" href="#LowLevelParticleFilters.loglik_x"><code>LowLevelParticleFilters.loglik_x</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ll = loglik_x(kf, u, y, x, p=parameters(kf))</code></pre><p>For Kalman-type filters when an accurate state sequence <code>x</code> is available, such as when data is obtained from a simulation or in a lab setting, the log-likelihood can be calculated using the state prediction errors rather than the output prediction errors. In this case, <code>logpdf(f.R, x-x̂)</code> is used rather than <code>logpdf(S, y-ŷ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L236-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.logsumexp!"><a class="docstring-binding" href="#LowLevelParticleFilters.logsumexp!"><code>LowLevelParticleFilters.logsumexp!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ll = logsumexp!(w, we [, maxw])</code></pre><p>Normalizes the weight vector <code>w</code> and returns the weighted log-likelihood</p><p>https://arxiv.org/pdf/1412.8695.pdf eq 3.8 for p(y) https://discourse.julialang.org/t/fast-logsumexp/22827/7?u=baggepinnen for stable logsumexp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/utils.jl#L11-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.mean_trajectory"><a class="docstring-binding" href="#LowLevelParticleFilters.mean_trajectory"><code>LowLevelParticleFilters.mean_trajectory</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">x,ll = mean_trajectory(pf, u::Vector{Vector}, y::Vector{Vector}, p=parameters(pf))</code></pre><p>This method resets the particle filter to the initial state distribution upon start</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L381-L385">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}"><a class="docstring-binding" href="#LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mean_trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mean_trajectory(sol::ParticleFilteringSolution)
mean_trajectory(x::AbstractMatrix, we::AbstractMatrix)</code></pre><p>Compute the weighted mean along the trajectory of a particle-filter solution. Returns a matrix of size <code>T × nx</code>. If <code>x</code> and <code>we</code> are supplied, the weights are expected to be in the original space (not log space).</p><p>See also <a href="#LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}"><code>mode_trajectory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L390-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.metropolis"><a class="docstring-binding" href="#LowLevelParticleFilters.metropolis"><code>LowLevelParticleFilters.metropolis</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">metropolis(ll::Function(θ), R::Int, θ₀::Vector, draw::Function(θ) = naive_sampler(θ₀))</code></pre><p>Performs MCMC sampling using the marginal Metropolis (-Hastings) algorithm <code>draw = θ -&gt; θ&#39;</code> samples a new parameter vector given an old parameter vector. The distribution must be symmetric, e.g., a Gaussian. <code>R</code> is the number of iterations. See <code>log_likelihood_fun</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">filter_from_parameters(θ) = ParticleFilter(N, dynamics, measurement, MvNormal(n,exp(θ[1])), MvNormal(p,exp(θ[2])), d0)
priors = [Normal(0,0.1),Normal(0,0.1)]
ll     = log_likelihood_fun(filter_from_parameters,priors,u,y,1)
θ₀ = log.([1.,1.]) # Initial point
draw = θ -&gt; θ .+ rand(MvNormal(0.1ones(2))) # Function that proposes new parameters (has to be symmetric)
burnin = 200 # If using threaded call, provide number of burnin iterations
# @time theta, lls = metropolis(ll, 2000, θ₀, draw) # Run single threaded
# thetam = reduce(hcat, theta)&#39;
@time thetalls = LowLevelParticleFilters.metropolis_threaded(burnin, ll, 5000, θ₀, draw) # run on all threads, will provide (2000-burnin)*nthreads() samples
histogram(exp.(thetalls[:,1:2]), layout=3)
plot!(thetalls[:,3], subplot=3) # if threaded call, log likelihoods are in the last column</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L287-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}"><a class="docstring-binding" href="#LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mode_trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mode_trajectory(sol::ParticleFilteringSolution)
mode_trajectory(x::AbstractMatrix, we::AbstractMatrix)</code></pre><p>Compute the mode (particle with largest weight) along the trajectory of a particle-filter solution. Returns a matrix of size <code>T × nx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L402-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.n_integrator_covariance"><a class="docstring-binding" href="#LowLevelParticleFilters.n_integrator_covariance"><code>LowLevelParticleFilters.n_integrator_covariance</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">R = n_integrator_covariance(n, Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time n-integrator with piecewise constant stochastic (generalized) force as input.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Order of the integrator (state dimension)</li><li><code>Ts</code>: Sample time</li><li><code>σ2</code>: Variance of driving noise</li></ul><p>The state is assumed to be <a href="n dimensional">x; ẋ; ẍ; ...</a> and the dynamics follow</p><p class="math-container">\[x^+ = Ax + Bu + w\]</p><p>where the noise input <code>w</code> has not been included in the discretization process.</p><p>This matrix is rank deficient and some applications might require a small increase in the diagonal to make it positive definite (or use <a href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>n_integrator_covariance_smooth</code></a>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">R = n_integrator_covariance(3, 0.1)  # 3rd order integrator with Ts=0.1</code></pre><p>See also <a href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>n_integrator_covariance_smooth</code></a> for the version that does not assume piecewise constant noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/utils.jl#L138-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><a class="docstring-binding" href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>LowLevelParticleFilters.n_integrator_covariance_smooth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">R = n_integrator_covariance_smooth(n, Ts, σ2=1)
R = n_integrator_covariance_smooth(Val(n), Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time n-integrator with continuous noise as input.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Order of the integrator (state dimension), can be provided as <code>Int</code> or <code>Val{n}</code></li><li><code>Ts</code>: Sample time  </li><li><code>σ2</code>: Variance of driving noise (default: 1)</li></ul><p>The state is assumed to be <a href="n dimensional">x; ẋ; ẍ; ...</a>. This assumes continuous white noise  driving the highest derivative, integrated over the sample interval.</p><p>This matrix is full rank, which is often favorable for numerical stability. The resulting  covariance dynamics are approximately invariant to the sample interval.</p><p>Formally, <span>$R$</span> is the solution to the fixed-horizon Lyapunov equation with the dynamics given by an n-th order integrator.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">R = n_integrator_covariance_smooth(3, 0.1)  # 3rd order integrator with Ts=0.1
R = n_integrator_covariance_smooth(Val(3), 0.1)  # Compile-time known dimension</code></pre><p>See also <a href="#LowLevelParticleFilters.n_integrator_covariance"><code>n_integrator_covariance</code></a> for the version that assumes piecewise constant noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/utils.jl#L186-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.reset!-Tuple{EnsembleKalmanFilter}"><a class="docstring-binding" href="#LowLevelParticleFilters.reset!-Tuple{EnsembleKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(enkf::EnsembleKalmanFilter; x0 = nothing)</code></pre><p>Reset the ensemble to the initial distribution. If <code>x0</code> is provided, the ensemble is resampled around that mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/enkf.jl#L193-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}"><a class="docstring-binding" href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(kf::AbstractKalmanFilter; x0)</code></pre><p>Reset the initial distribution of the state. Optionally, a new mean vector <code>x0</code> can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/kalman.jl#L154-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}"><a class="docstring-binding" href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Reset the filter to initial state and covariance/distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}"><a class="docstring-binding" href="#LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset!(kf::SqKalmanFilter; x0)</code></pre><p>Reset the initial distribution of the state. Optionally, a new mean vector <code>x0</code> can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_kalman.jl#L88-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.sampleplot"><a class="docstring-binding" href="#LowLevelParticleFilters.sampleplot"><code>LowLevelParticleFilters.sampleplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sampleplot(f, u, N; plotx=true, ploty=true, alpha=0.5, dynamics_noise=true, measurement_noise=true, sample_initial=true)</code></pre><p>Plot <span>$N$</span> draws from the prior distribution encoded by filter <code>f</code> using input trajectory <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L513-L517">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.simulate"><a class="docstring-binding" href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">x,u,y = simulate(f::AbstractFilter, T::Int, du::Distribution, p=parameters(f), [N]; dynamics_noise=true, measurement_noise=true)
x,u,y = simulate(f::AbstractFilter, u, p=parameters(f); dynamics_noise=true, measurement_noise=true)</code></pre><p>Simulate dynamical system forward in time <code>T</code> steps, or for the duration of <code>u</code>. Returns state sequence, inputs and measurements.</p><ul><li><code>u</code> is an input-signal trajectory, alternatively, <code>du</code> is a distribution of random inputs.</li></ul><p>A simulation can be considered a draw from the prior distribution over the evolution of the system implied by the selected noise models. Such a simulation is useful in order to evaluate whether or not the noise models are reasonable.</p><p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, the argument <code>N::Int</code> can be supplied, in which case <code>N</code> simulations are done and the result is returned in the form of <code>Vector{MonteCarloMeasurements.Particles}</code>.</p><p>See also <a href="#LowLevelParticleFilters.sampleplot"><code>sampleplot</code></a> for a plot recipe that automatically performs many simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L436-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.smooth"><a class="docstring-binding" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">xb,ll = smooth(pf, M, u, y, p=parameters(pf))
xb,ll = smooth(pf, xf, wf, wef, ll, M, u, y, p=parameters(pf))</code></pre><p>Perform particle smoothing using forward-filtering, backward simulation. Return smoothed particles and loglikelihood. See also <a href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>smoothed_trajs</code></a>, <a href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>smoothed_mean</code></a>, <a href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>smoothed_cov</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L107-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.smooth"><a class="docstring-binding" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">smooth(sol, kf::SqExtendedKalmanFilter, u, y, p)</code></pre><p>Performs Rauch-Tung-Striebel smoothing for the Square-root Extended Kalman Filter. Returns smoothed states and covariance matrices (converted from Cholesky factors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_ekf.jl#L248-L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.smooth"><a class="docstring-binding" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sol = smooth(filtersol)
sol = smooth(kf::AbstractKalmanFilter, u::Vector, y::Vector, p=parameters(kf))</code></pre><p>Returns a <a href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>KalmanSmoothingSolution</code></a> with smoothed estimates of state <code>xT</code> and covariance <code>RT</code> given all input output data <code>u,y</code> or an existing filtering solution <code>filtersol</code> obtained from <a href="#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>.</p><p>The return smoothing can be plotted using <code>plot(sol)</code>, see <a href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>KalmanSmoothingSolution</code></a> and <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L2-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_cov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smoothed_cov(xb)</code></pre><p>Helper function to calculate the covariance of smoothed particle trajectories</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L361-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smoothed_mean(xb)</code></pre><p>Helper function to calculate the mean of smoothed particle trajectories</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L349-L353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_trajs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smoothed_trajs(xb)</code></pre><p>Helper function to get particle trajectories as a 3-dimensions array (N,M,T) instead of matrix of vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L372-L376">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.state-Tuple{EnsembleKalmanFilter}"><a class="docstring-binding" href="#LowLevelParticleFilters.state-Tuple{EnsembleKalmanFilter}"><code>LowLevelParticleFilters.state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state(enkf::EnsembleKalmanFilter)</code></pre><p>Return the cached ensemble mean (state estimate).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/enkf.jl#L179-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.unscentedplot"><a class="docstring-binding" href="#LowLevelParticleFilters.unscentedplot"><code>LowLevelParticleFilters.unscentedplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unscentedplot(ukf;          n_std = 2, N = 100, dims=1:2)
unscentedplot(sigmapoints;  n_std = 2, N = 100, dims=1:2)</code></pre><p>Plot the sigma points and their corresponding covariance ellipse. <code>dims</code> indicate the two dimensions to plot, and defaults to the first two dimensions.</p><p>If an UKF is passed, the sigma points after the last dynamics update are extracted from the filter. To plot the sigma points of the output, pass those in manually, they are available as <code>ukf.measurement_model.cache.x0</code> and <code>ukf.measurement_model.cache.x1</code>, denoting the input and output points of the measurement model.</p><p>Note: The covariance of the sigma points does not in general equal the predicted covariance of the state, since the state covariance is updated as <code>cov(sigmapoints) + R1</code>. Only when <code>AUGD = true</code> (augmented dynamics), the covariance of the state is given by the first <code>nx</code> sigmapoints.</p><p>See also <code>covplot</code>.</p><div class="admonition is-info" id="Note-b633e3e95be079c3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b633e3e95be079c3" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/LowLevelParticleFilters.jl#L163-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.update!"><a class="docstring-binding" href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update!(enkf::EnsembleKalmanFilter, u, y, p = parameters(enkf), t = index(enkf) * enkf.Ts)</code></pre><p>Perform one filtering step: correct followed by predict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/enkf.jl#L338-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.update!"><a class="docstring-binding" href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ll, e = update!(f::AbstractFilter, u, y, p = parameters(f), t = index(f))</code></pre><p>Perform one step of <code>predict!</code> and <code>correct!</code>, returns log-likelihood and prediction error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L169-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(imm::IMM, u, y, p, t; correct_kwargs = (;), predict_kwargs = (;), interact = true)</code></pre><p>The combined udpate for an <a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter performs the following steps:</p><ol><li>Correct each model with the measurements <code>y</code> and control input <code>u</code>.</li><li>Combine the models into a single state and covariance.</li><li>Interact the models to update their respective state and covariance.</li><li>Predict each model to the next time step.</li></ol><p>This differs slightly from the udpate step of other filters, where at the end of an update the state of the filter is the one-step ahead <em>predicted</em> value, whereas here each individual filter has a predicted state, but the <a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>combine!</code></a> step of the IMM filter hasn&#39;t been performed on the predictions yet. The state of the IMM filter is thus <span>$x(t|t)$</span> and not <span>$x(t+1|t)$</span> like it is for other filters, and each filter internal to the IMM.</p><p><strong>Arguments:</strong></p><ul><li><code>correct_kwargs</code>: An optional named tuple of keyword arguments that are sent to <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a>.</li><li><code>predict_kwargs</code>: An optional named tuple of keyword arguments that are sent to <a href="#StatsAPI.predict!"><code>predict!</code></a>.</li><li><code>interact</code>: Whether or not to run the interaction step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/imm.jl#L193-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.validationplot"><a class="docstring-binding" href="#LowLevelParticleFilters.validationplot"><code>LowLevelParticleFilters.validationplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">validationplot(sol::KalmanFilteringSolution)</code></pre><p>Perform statistical validation of Kalman filter performance by analyzing the innovation sequence.</p><p>Creates a 4-subplot figure with the following diagnostics:</p><ol><li><p><strong>Root Mean Square (RMS) of Innovation</strong>: Shows the RMS value for each output dimension.</p><ul><li>Lower values indicate better filter performance</li></ul></li><li><p><strong>Normalized Innovation Squared (NIS)</strong>: Plots NIS over time with 95% confidence bounds</p><ul><li>NIS = <span>$e(t)&#39; * S(t)⁻¹ * e(t)$</span> where <span>$e$</span> is innovation and <span>$S$</span> is innovation covariance</li><li>Should follow a chi-squared distribution with <span>$n_y$</span> degrees of freedom</li><li>Points consistently outside bounds indicate filter mistuning (wrong R1 or R2)</li></ul></li><li><p><strong>Autocorrelation of Innovation</strong>: Shows autocorrelation vs lag with white noise bounds</p><ul><li>Innovations should be white (uncorrelated over time)</li><li>Autocorrelation outside ±1.96/√T bounds indicates filter issues</li><li>High autocorrelation suggests model mismatch or underestimated noise</li></ul></li><li><p><strong>Cross-correlation between Innovation and Past Inputs</strong>: Shows correlation vs lag</p><ul><li>Should be near zero at all lags (innovations independent of past inputs)</li><li>Correlation outside ±1.96/√T bounds indicates model errors</li><li>Non-zero cross-correlation suggests incorrect system model</li></ul></li></ol><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using Plots, Distributions
sol = forward_trajectory(kf, u, y)
validationplot(sol)</code></pre><div class="admonition is-info" id="Requires-Distributions.jl-bcce82126ce45bb5"><header class="admonition-header">Requires Distributions.jl<a class="admonition-anchor" href="#Requires-Distributions.jl-bcce82126ce45bb5" title="Permalink"></a></header><div class="admonition-body"><p>This function requires Distributions.jl to be manually installed and loaded.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/LowLevelParticleFilters.jl#L197-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}"><code>LowLevelParticleFilters.weighted_cov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weighted_cov(x,we)</code></pre><p>Similar to <a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>weighted_mean</code></a>, but returns covariances</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L563-L567">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><a class="docstring-binding" href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>LowLevelParticleFilters.weighted_mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">x̂ = weighted_mean(x,we)</code></pre><p>Calculated weighted mean of particle trajectories. <code>we</code> are expweights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L529-L533">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.weighted_mean-Tuple{Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.weighted_mean-Tuple{Any}"><code>LowLevelParticleFilters.weighted_mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">x̂ = weighted_mean(pf)
x̂ = weighted_mean(s::PFstate)</code></pre><p>See also <a href="#LowLevelParticleFilters.mean_trajectory"><code>mean_trajectory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L554-L559">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.weighted_quantile-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#LowLevelParticleFilters.weighted_quantile-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.weighted_quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weighted_quantile(x,we,q)
weighted_quantile(sol,q)</code></pre><p>Calculated weighted quantile <code>q</code> of particle trajectories. <code>we</code> are expweights. Returns a vector of length <code>size(x, 2)</code> where each entry has length <code>nx</code>. For a particle-filtering solution, this means the vector will be as long as the number of time steps in the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L579-L584">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict!"><a class="docstring-binding" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predict!(kf::AbstractKalmanFilter, u, p = parameters(kf), t::Integer = index(kf); R1, α = kf.α)</code></pre><p>Perform the prediction step (updating the state estimate to <span>$x(t+1|t)$</span>). If <code>R1</code> stored in <code>kf</code> is a function <code>R1(x, u, p, t)</code>, this function is evaluated at the state <em>before</em> the prediction is performed. The dynamics noise covariance matrix <code>R1</code> stored in <code>kf</code> can optionally be overridden by passing the argument <code>R1</code>, in this case <code>R1</code> must be a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L38-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict!"><a class="docstring-binding" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predict!(kf::SqKalmanFilter, u, p = parameters(kf), t::Real = index(kf); R1 = get_mat(kf.R1, kf.x, u, p, t), α = kf.α)</code></pre><p>For the square-root Kalman filter, a custom provided <code>R1</code> must be the upper triangular Cholesky factor of the covariance matrix of the process noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_kalman.jl#L99-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict!"><a class="docstring-binding" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predict!(f, u, p = parameters(f), t = index(f))</code></pre><p>Move filter state forward in time using dynamics equation and input vector <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/filtering.jl#L128-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict!"><a class="docstring-binding" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predict!(enkf::EnsembleKalmanFilter, u, p = parameters(enkf), t = index(enkf) * enkf.Ts; R1 = enkf.R1, inflation = enkf.inflation)</code></pre><p>Propagate each ensemble member through the dynamics with process noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/enkf.jl#L218-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict!-Union{Tuple{CF}, Tuple{MF}, Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM, MF, CF}"><a class="docstring-binding" href="#StatsAPI.predict!-Union{Tuple{CF}, Tuple{MF}, Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM, MF, CF}"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">predict!(ukf::UnscentedKalmanFilter, u, p = parameters(ukf), t::Real = index(ukf) * ukf.Ts; R1 = get_mat(ukf.R1, ukf.x, u, p, t), reject, mean, cov, dynamics)</code></pre><p>The prediction step for an <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> allows the user to override, <code>R1</code> and any of the functions, reject, mean, cov, dynamics`.</p><p><strong>Arguments:</strong></p><ul><li><code>u</code>: The input</li><li><code>p</code>: The parameters</li><li><code>t</code>: The current time</li><li><code>R1</code>: The dynamics noise covariance matrix, or a function that returns the covariance matrix.</li><li><code>reject</code>: A function that takes a sigma point and returns <code>true</code> if it should be rejected.</li><li><code>mean</code>: The function that computes the mean of the state sigma points.</li><li><code>cov</code>: The function that computes the covariance of the state sigma points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/ukf.jl#L454-L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict!-Union{Tuple{IPD}, Tuple{SqExtendedKalmanFilter{IPD}, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any, Real}} where IPD"><a class="docstring-binding" href="#StatsAPI.predict!-Union{Tuple{IPD}, Tuple{SqExtendedKalmanFilter{IPD}, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any, Real}} where IPD"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">predict!(kf::SqExtendedKalmanFilter, u, p, t; R1, α)</code></pre><p>Prediction step for the Square-root Extended Kalman Filter. Linearizes the dynamics and updates the state and Cholesky factor of covariance using QR decomposition.</p><p>If a custom <code>R1</code> is provided, it must be the upper triangular Cholesky factor (of type <code>UpperTriangular</code>) of the covariance matrix of the process noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/sq_ekf.jl#L144-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LowLevelParticleFilters.prediction_errors!"><a class="docstring-binding" href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prediction_errors!(res, f::AbstractFilter, u, y, p = parameters(f), λ = 1; loglik = false)</code></pre><p>Calculate the prediction errors and store the result in <code>res</code>. Similar to <a href="@ref"><code>sse</code></a>, this function is useful for sum-of-squares optimization. In contrast to <code>sse</code>, this function returns the residuals themselves rather than their sum of squares. This is useful for Gauss-Newton style optimizers, such as <a href="https://github.com/matthieugomez/LeastSquaresOptim.jl">LeastSquaresOptim.LevenbergMarquardt</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>res</code>: A vector of length <code>ny*length(y)</code>. Note, for each datapoint in <code>u</code> and <code>u</code>, there are <code>ny</code> outputs, and thus <code>ny</code> residuals. If <code>loglik = true</code>, the length of <code>res</code> must be <code>length(y)*(ny+1)</code>, since an extra residual is added for the log-determinant term.</li><li><code>f</code>: Any Kalman type filter</li><li><code>λ</code>: A weighting factor to minimize <code>dot(e, λ, e)</code>. A commonly used metric is <code>λ = Diagonal(1 ./ (mag.^2))</code>, where <code>mag</code> is a vector of the &quot;typical magnitude&quot; of each output. Internally, the square root of <code>W = sqrt(λ)</code> is calculated so that the residuals stored in <code>res</code> are <code>W*e</code>.</li><li><code>loglik</code>: If <code>true</code>, the residuals are calculated as <code>Sᵪ</code>, where <code>Sᵪ</code> is the Cholesky factor of the innovation covariance. This turns least-squares optimization into maximum likelihood estimation. When this is true, the <code>λ</code> argument is ignored and the length of <code>res</code> must be <code>length(y)*(ny+1)</code>, where an extra residual per time step is added for the log-determinant term.</li><li><code>offset</code>: When using <code>loglik = true</code>, an offset may be added to the log-determinant term to avoid negative values inside the square root. The result of adding this offset is that the log-liklihood is shifted by a constant value, which does not affect optimization.</li></ul><p>See example in <a href="../param_est_optimizer/#Solving-using-Gauss-Newton-optimization">Solving using Gauss-Newton optimization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/b360c98875721118154e4250bea64253e030669c/src/smoothing.jl#L160-L173">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cross_covariance/">« Cross-covariance between dynamics and measurement</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 29 January 2026 04:48">Thursday 29 January 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
