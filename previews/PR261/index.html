<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LowLevelParticleFilters Documentation</title><meta name="title" content="Home · LowLevelParticleFilters Documentation"/><meta property="og:title" content="Home · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="Home · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Estimator-types"><span>Estimator types</span></a></li><li><a class="tocitem" href="#Functionality"><span>Functionality</span></a></li><li class="toplevel"><a class="tocitem" href="#Particle-filter"><span>Particle filter</span></a></li><li class="toplevel"><a class="tocitem" href="#Particle-Smoothing"><span>Particle Smoothing</span></a></li><li class="toplevel"><a class="tocitem" href="#Kalman-filter"><span>Kalman filter</span></a></li><li><a class="tocitem" href="#Smoothing-using-KF"><span>Smoothing using KF</span></a></li><li><a class="tocitem" href="#Kalman-filter-tuning-tutorial"><span>Kalman filter tuning tutorial</span></a></li><li class="toplevel"><a class="tocitem" href="#Unscented-Kalman-Filter"><span>Unscented Kalman Filter</span></a></li><li class="toplevel"><a class="tocitem" href="#Extended-Kalman-Filter"><span>Extended Kalman Filter</span></a></li><li class="toplevel"><a class="tocitem" href="#AdvancedParticleFilter"><span>AdvancedParticleFilter</span></a></li><li class="toplevel"><a class="tocitem" href="#Troubleshooting-and-tuning"><span>Troubleshooting and tuning</span></a></li><li><a class="tocitem" href="#Particle-filters"><span>Particle filters</span></a></li><li><a class="tocitem" href="#Troubleshooting-Kalman-filters"><span>Troubleshooting Kalman filters</span></a></li><li><a class="tocitem" href="#Tuning-noise-parameters-through-optimization"><span>Tuning noise parameters through optimization</span></a></li><li><a class="tocitem" href="#Tuning-through-simulation"><span>Tuning through simulation</span></a></li><li class="toplevel"><a class="tocitem" href="#Videos"><span>Videos</span></a></li></ul></li><li><a class="tocitem" href="discretization/">Discretization</a></li><li><a class="tocitem" href="measurement_models/">Multiple measurement models</a></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="parameter_estimation/">Overview</a></li><li><a class="tocitem" href="param_est_ml/">Maximum-likelihood and MAP</a></li><li><a class="tocitem" href="param_est_bayesian/">Bayesian inference</a></li><li><a class="tocitem" href="param_est_joint/">Joint state and parameter estimation</a></li><li><a class="tocitem" href="param_est_mukf/">MUKF for parameter estimation</a></li><li><a class="tocitem" href="param_est_optimizer/">Using an optimizer</a></li><li><a class="tocitem" href="param_est_identifiability/">Identifiability</a></li></ul></li><li><a class="tocitem" href="benchmark/">Benchmark</a></li><li><a class="tocitem" href="distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="beetle_example_imm/">IMM-filter tutorial</a></li><li><a class="tocitem" href="rbpf_example/">Rao-Blackwellized filter tutorial</a></li><li><a class="tocitem" href="dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="friction_nn_example/">SciML: Adaptive Universal Differential Equation</a></li><li><a class="tocitem" href="thermal_nn_example/">SciML: Learning a sunshine disturbance model</a></li><li><a class="tocitem" href="fault_detection/">Fault detection</a></li><li><a class="tocitem" href="ut/">Unscented transform</a></li><li><a class="tocitem" href="disturbance_gallery/">Disturbance gallery</a></li><li><a class="tocitem" href="sample_rate/">Influence of sample rate on performance</a></li><li><a class="tocitem" href="cross_covariance/">Cross-covariance between dynamics and measurement</a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LowLevelParticleFilters"><a class="docs-heading-anchor" href="#LowLevelParticleFilters">LowLevelParticleFilters</a><a id="LowLevelParticleFilters-1"></a><a class="docs-heading-anchor-permalink" href="#LowLevelParticleFilters" title="Permalink"></a></h1><p><a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/actions"><img src="https://github.com/baggepinnen/LowLevelParticleFilters.jl/workflows/CI/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/baggepinnen/LowLevelParticleFilters.jl"><img src="https://codecov.io/gh/baggepinnen/LowLevelParticleFilters.jl/branch/master/graph/badge.svg" alt="codecov"/></a></p><p>This is a library for <em>state estimation</em>, that is, given measurements <span>$y(t)$</span> from a dynamical system, estimate the state vector <span>$x(t)$</span>. Throughout, we assume dynamics on the form</p><p class="math-container">\[\begin{aligned}
x(t+1) &amp;= f(x(t), u(t), p, t, w(t))\\
y(t) &amp;= g(x(t), u(t), p, t, e(t))
\end{aligned}\]</p><p>or the linear version</p><p class="math-container">\[\begin{aligned}
x(t+1) &amp;= Ax(t) + Bu(t) + w(t)\\
y(t) &amp;= Cx(t) + Du(t) + e(t)
\end{aligned}\]</p><p>where <span>$x$</span> is the state vector, <span>$u$</span> an input, <span>$p$</span> some form of parameters, <span>$t$</span> is the time and <span>$w,e$</span> are disturbances (noise). Throughout the documentation, we often call the function <span>$f$</span> <code>dynamics</code> and the function <span>$g$</span> <code>measurement</code>.</p><p>The dynamics above describe a <em>discrete-time</em> system, i.e., the function <span>$f$</span> takes the current state and produces the <em>next state</em>. This is in contrast to a <em>continuous-time</em> system, where <span>$f$</span> takes the current state but produces the <em>time derivative</em> of the state. A continuous-time system can be <em>discretized</em>, described in detail in <a href="discretization/#Discretization">Discretization</a>.</p><p>The parameters <span>$p$</span> can be anything, or left out. You may write the dynamics functions such that they depend on <span>$p$</span> and include parameters when you create a filter object. You may also override the parameters stored in the filter object when you call any function on the filter object. This behavior is modeled after the SciML ecosystem.</p><p>Depending on the nature of <span>$f$</span> and <span>$g$</span>, the best method of estimating the state may vary. If <span>$f,g$</span> are linear and the disturbances are additive and Gaussian, the <a href="api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> is an optimal state estimator. If any of the above assumptions fail to hold, we may need to resort to more advanced estimators. This package provides several filter types, outlined below.</p><h2 id="Estimator-types"><a class="docs-heading-anchor" href="#Estimator-types">Estimator types</a><a id="Estimator-types-1"></a><a class="docs-heading-anchor-permalink" href="#Estimator-types" title="Permalink"></a></h2><p>We provide a number of filter types</p><ul><li><a href="api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. A standard Kalman filter. Is restricted to linear dynamics (possibly time varying) and Gaussian noise.</li><li><a href="api/#LowLevelParticleFilters.SqKalmanFilter"><code>SqKalmanFilter</code></a>. A standard Kalman filter on square-root form (slightly slower but more numerically stable with ill-conditioned covariance).</li><li><a href="api/#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a>: For nonlinear systems, the EKF runs a regular Kalman filter on linearized dynamics. Uses ForwardDiff.jl for linearization (or user provided). The noise model must still be Gaussian and additive.</li><li><a href="api/#LowLevelParticleFilters.SqExtendedKalmanFilter"><code>SqExtendedKalmanFilter</code></a>: A square-root version of the EKF.</li><li><a href="api/#LowLevelParticleFilters.IteratedExtendedKalmanFilter"><code>IteratedExtendedKalmanFilter</code></a> same as EKF, but performs iteration in the measurement update for increased accuracy in the covariance update.</li><li><a href="api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>: The Unscented Kalman filter often performs slightly better than the Extended Kalman filter but may be slightly more computationally expensive. The UKF handles nonlinear dynamics and measurement models, but still requires a Gaussian noise model (may be non additive) and still assumes that all posterior distributions are Gaussian, i.e., can not handle multi-modal posteriors.</li><li><a href="api/#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>: The particle filter is a nonlinear estimator. This version of the particle filter is simple to use and assumes that both dynamics noise and measurement noise are additive. Particle filters handle multi-modal posteriors.</li><li><a href="#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a>: This filter gives you more flexibility, at the expense of having to define a few more functions. This filter does not require the noise to be additive and is thus the most flexible filter type.</li><li><a href="api/#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>AuxiliaryParticleFilter</code></a>: This filter is identical to <a href="api/#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>, but uses a slightly different proposal mechanism for new particles.</li></ul><h3 id="Experimental-estimator-types"><a class="docs-heading-anchor" href="#Experimental-estimator-types">Experimental estimator types</a><a id="Experimental-estimator-types-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-estimator-types" title="Permalink"></a></h3><p>Additionally, these filter types are currently considered experimental and may change in future releases without respecting semantic versioning.</p><ul><li><a href="api/#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a>: The <em>Interacting Multiple Models</em> filter switches between multiple internal filters based on a hidden Markov model. This filter is useful when the system dynamics change over time and the change can be modeled as a discrete Markov chain, i.e., the system may switch between a small number of discrete &quot;modes&quot;.</li><li><a href="rbpf_example/#RBPF"><code>RBPF</code></a>: A Rao-Blackwellized (marginalized) particle filter that uses a Kalman filter for the linear part of the state and a particle filter for the nonlinear part.</li><li><a href="api/#LowLevelParticleFilters.MUKF"><code>MUKF</code></a>: A Rao-Blackwellized (marginalized) Unscented Kalman Filter that combines an Unscented Kalman Filter for the nonlinear substate with a bank of Kalman filters (one per sigma point) for the linear substate. Similar to RBPF but uses deterministic sigma points instead of random particles.</li><li><a href="api/#LowLevelParticleFilters.UIKalmanFilter"><code>UIKalmanFilter</code></a>: An Unknown Input Kalman Filter that estimates both the state and unknown inputs to a linear system without augmenting the state vector. See Gillijns &amp; De Moor (2007), &quot;Unbiased minimum-variance input and state estimation for linear discrete-time systems&quot;.</li></ul><h2 id="Functionality"><a class="docs-heading-anchor" href="#Functionality">Functionality</a><a id="Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Functionality" title="Permalink"></a></h2><p>This package provides </p><ul><li>Filtering, estimating <span>$x(t)$</span> given measurements up to and including time <span>$t$</span>. We call the filtered estimate <span>$x(t|t)$</span> (read as <span>$x$</span> at <span>$t$</span> given <span>$t$</span>).</li><li>Smoothing, estimating <span>$x(t)$</span> given data up to <span>$T &gt; t$</span>, i.e., <span>$x(t|T)$</span>.</li><li>Parameter estimation.</li></ul><p>All filters work in two distinct steps.</p><ol><li>The <em>prediction</em> step (<a href="api/#StatsAPI.predict!"><code>predict!</code></a>). During prediction, we use the dynamics model to form <span>$x(t|t-1) = f(x(t-1), ...)$</span></li><li>The <em>correction</em> step (<a href="api/#LowLevelParticleFilters.correct!"><code>correct!</code></a>). In this step, we adjust the predicted state <span>$x(t|t-1)$</span> using the measurement <span>$y(t)$</span> to form <span>$x(t|t)$</span>.</li></ol><p>The following two exceptions to the above exist</p><ul><li>The <a href="api/#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter has two additional steps, <a href="api/#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>combine!</code></a> and <a href="api/#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>interact!</code></a></li><li>The <a href="api/#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>AuxiliaryParticleFilter</code></a> makes use of the next measurement in the dynamics update, and thus only has an <a href="api/#LowLevelParticleFilters.update!"><code>update!</code></a> method.</li></ul><p>In general, all filters represent not only a point estimate of <span>$x(t)$</span>, but a representation of the complete posterior probability distribution over <span>$x$</span> given all the data available up to time <span>$t$</span>. One major difference between different filter types is how they represent these probability distributions.</p><h1 id="Particle-filter"><a class="docs-heading-anchor" href="#Particle-filter">Particle filter</a><a id="Particle-filter-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-filter" title="Permalink"></a></h1><p>A particle filter represents the probability distribution over the state as a collection of samples, each sample is propagated through the dynamics function <span>$f$</span> individually. When a measurement becomes available, the samples, called <em>particles</em>, are given a weight based on how likely the particle is given the measurement. Each particle can thus be seen as representing a hypothesis about the current state of the system. After a few time steps, most weights are inevitably going to be extremely small, a manifestation of the curse of dimensionality, and a resampling step is incorporated to refresh the particle distribution and focus the particles on areas of the state space with high posterior probability.</p><p>Defining a particle filter (<a href="api/#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>) is straightforward, one must define the distribution of the noise <code>df</code> in the dynamics function, <code>dynamics(x,u,p,t)</code> and the noise distribution <code>dg</code> in the measurement function <code>measurement(x,u,p,t)</code>. Both of these noise sources are assumed to be additive, but can have any distribution (see <a href="#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> for non-additive noise). The distribution of the initial state estimate <code>d0</code> must also be provided. In the example below, we use linear Gaussian dynamics so that we can easily compare both particle and Kalman filters. (If we have something close to linear Gaussian dynamics in practice, we should of course use a Kalman filter and not a particle filter.)</p><pre><code class="language-julia hljs">using LowLevelParticleFilters, LinearAlgebra, StaticArrays, Distributions, Plots</code></pre><p>Define problem</p><pre><code class="language-julia hljs">nx = 2   # Dimension of state
nu = 1   # Dimension of input
ny = 1   # Dimension of measurements
N = 500  # Number of particles

const dg = MvNormal(ny,0.2)          # Measurement noise Distribution
const df = MvNormal(nx,0.1)          # Dynamics noise Distribution
const d0 = MvNormal(randn(nx),2.0)   # Initial state Distribution</code></pre><p>Define linear state-space system (using StaticArrays for maximum performance)</p><pre><code class="language-julia hljs">const A = SA[0.97043   -0.097368
             0.09736    0.970437]
const B = SA[0.1; 0;;]
const C = SA[0 1.0]</code></pre><p>Next, we define the dynamics and measurement equations, they both take the signature <code>(x,u,p,t) = (state, input, parameters, time)</code> </p><pre><code class="language-julia hljs">dynamics(x,u,p,t) = A*x .+ B*u
measurement(x,u,p,t) = C*x
vecvec_to_mat(x) = copy(reduce(hcat, x)&#39;) # Helper function</code></pre><p>the parameter <code>p</code> can be <em>anything</em>, and is often optional. If <code>p</code> is not provided when performing operations on filters, any <code>p</code> stored in the filter objects (if supported) is used. The default if none is provided and none is stored in the filter is <code>p = LowLevelParticleFilters.NullParameters()</code>.</p><p>We are now ready to define and use a filter</p><pre><code class="language-julia hljs">pf = ParticleFilter(N, dynamics, measurement, df, dg, d0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParticleFilter{PFstate{StaticArraysCore.SVector{2, Float64}, Float64}, typeof(Main.dynamics), typeof(Main.measurement), Distributions.ZeroMeanIsoNormal{Tuple{Base.OneTo{Int64}}}, Distributions.ZeroMeanIsoNormal{Tuple{Base.OneTo{Int64}}}, Distributions.IsoNormal, DataType, Random.Xoshiro, LowLevelParticleFilters.NullParameters}(PFstate{StaticArraysCore.SVector{2, Float64}, Float64}(StaticArraysCore.SVector{2, Float64}[[1.5941371388912606, -3.7639209056301706], [-3.859702179393392, -4.714397072108522], [-3.3496643414007847, 1.7078921198648702], [0.832508184256056, 0.33736468959902377], [0.5322638249622654, -0.27294790784742096], [3.2497176349172623, -2.7330376858082723], [0.9048346667967094, -1.6389448824549335], [1.645490874187696, 5.016764763817803], [0.5296735579308378, 2.0285299871182816], [1.822833498642755, -1.2437295103125479]  …  [0.22489102113326087, -3.494239151349024], [0.5775011079561228, -2.449720638328411], [0.9548071930291995, 0.06532855223323486], [0.3731276088661512, -2.3031048167484505], [-0.1078213726381401, -1.506778658267606], [-1.9847827754888796, -2.2747104325625793], [-4.047937487577327, -1.9750664546333336], [-0.051685317311632284, -4.961370077479652], [-0.5054655884304825, -3.690484470354749], [-2.470700972037451, -0.10654232936170571]], StaticArraysCore.SVector{2, Float64}[[1.5941371388912606, -3.7639209056301706], [-3.859702179393392, -4.714397072108522], [-3.3496643414007847, 1.7078921198648702], [0.832508184256056, 0.33736468959902377], [0.5322638249622654, -0.27294790784742096], [3.2497176349172623, -2.7330376858082723], [0.9048346667967094, -1.6389448824549335], [1.645490874187696, 5.016764763817803], [0.5296735579308378, 2.0285299871182816], [1.822833498642755, -1.2437295103125479]  …  [0.22489102113326087, -3.494239151349024], [0.5775011079561228, -2.449720638328411], [0.9548071930291995, 0.06532855223323486], [0.3731276088661512, -2.3031048167484505], [-0.1078213726381401, -1.506778658267606], [-1.9847827754888796, -2.2747104325625793], [-4.047937487577327, -1.9750664546333336], [-0.051685317311632284, -4.961370077479652], [-0.5054655884304825, -3.690484470354749], [-2.470700972037451, -0.10654232936170571]], [-6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191  …  -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191, -6.214608098422191], [0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002  …  0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002], Base.RefValue{Float64}(0.0), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  491, 492, 493, 494, 495, 496, 497, 498, 499, 500], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], Base.RefValue{Int64}(0)), Main.dynamics, Main.measurement, ZeroMeanIsoNormal(
dim: 2
μ: Zeros(2)
Σ: [0.010000000000000002 0.0; 0.0 0.010000000000000002]
)
, ZeroMeanIsoNormal(
dim: 1
μ: Zeros(1)
Σ: [0.04000000000000001;;]
)
, IsoNormal(
dim: 2
μ: [0.1899285619974648, -0.8048164305714557]
Σ: [4.0 0.0; 0.0 4.0]
)
, 0.1, LowLevelParticleFilters.ResampleSystematic, Random.Xoshiro(0x9beb9fba6008a32b, 0x6c17acbe8fcb07f9, 0x047b1cd3d531350f, 0x36488e357892cc4c, 0x7296198f85635a75), LowLevelParticleFilters.NullParameters(), false, 1.0, -1, 1)</code></pre><p>With the filter in hand, we can simulate from its dynamics and query some properties</p><pre><code class="language-julia hljs">du = MvNormal(nu,1.0)         # Random input distribution for simulation
xs,u,y = simulate(pf,200,du) # We can simulate the model that the pf represents
pf(u[1], y[1])               # Perform one filtering step using input u and measurement y
particles(pf)                # Query the filter for particles, try weights(pf) or expweights(pf) as well
x̂ = weighted_mean(pf)        # using the current state</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 -0.015347156769541521
 -0.7897094140730562</code></pre><p>If you want to perform batch filtering using an existing trajectory consisting of vectors of inputs and measurements, try any of the functions <a href="api/#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>, <a href="api/#LowLevelParticleFilters.mean_trajectory"><code>mean_trajectory</code></a>:</p><pre><code class="language-julia hljs">sol = forward_trajectory(pf, u, y) # Filter whole trajectories at once
x̂,ll = mean_trajectory(pf, u, y)
plot(sol, xreal=xs, markersize=2)</code></pre><img src="index-70bd69dc.png" alt="Example block output"/><p><code>u</code> ad <code>y</code> are then assumed to be <em>vectors of vectors</em>. StaticArrays is recommended for maximum performance.</p><p>We can also plot weighted quantiles instead of 2D histograms by providing a vector of desired quantiles through the <code>q</code> keyword argument</p><pre><code class="language-julia hljs">plot(sol, xreal=xs, markersize=2, q=[0.1, 0.5, 0.9], ploty=false, legend=true)</code></pre><img src="index-ec26d05a.png" alt="Example block output"/><p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, you may transform the output particles to <code>Matrix{MonteCarloMeasurements.Particles}</code> with the layout <code>T × n_state</code> using <code>Particles(x,we)</code>. Internally, the particles are then resampled such that they all have unit weight. This is conventient for making use of the <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/#Plotting-1">plotting facilities of MonteCarloMeasurements.jl</a>.</p><p>For a full usage example, see the benchmark section below or <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/src/example_lineargaussian.jl">example_lineargaussian.jl</a></p><h3 id="Resampling"><a class="docs-heading-anchor" href="#Resampling">Resampling</a><a id="Resampling-1"></a><a class="docs-heading-anchor-permalink" href="#Resampling" title="Permalink"></a></h3><p>The particle filter will perform a resampling step whenever the distribution of the weights has become degenerate. The resampling is triggered when the <em>effective number of samples</em> is smaller than <code>pf.resample_threshold</code> <span>$\in [0, 1]$</span>, this value can be set when constructing the filter. How the resampling is done is governed by <code>pf.resampling_strategy</code>, we currently provide <code>ResampleSystematic &lt;: ResamplingStrategy</code> as the only implemented strategy. See https://en.wikipedia.org/wiki/Particle_filter for more info.</p><h1 id="Particle-Smoothing"><a class="docs-heading-anchor" href="#Particle-Smoothing">Particle Smoothing</a><a id="Particle-Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-Smoothing" title="Permalink"></a></h1><p>Smoothing is the process of finding the best state estimate given both past and future data. Smoothing is thus only possible in an offline setting. This package provides a particle smoother, based on forward filtering, backward simulation (FFBS), example usage follows:</p><pre><code class="language-julia hljs">N     = 2000 # Number of particles
T     = 80   # Number of time steps
M     = 100  # Number of smoothed backwards trajectories
pf    = ParticleFilter(N, dynamics, measurement, df, dg, d0)
du    = MvNormal(nu,1)     # Control input distribution
x,u,y = simulate(pf,T,du) # Simulate trajectory using the model in the filter
tosvec(y) = reinterpret(SVector{length(y[1]),Float64}, reduce(hcat,y))[:] |&gt; copy
x,u,y = tosvec.((x,u,y)) # It&#39;s good for performance to use StaticArrays to the extent possible

xb,ll = smooth(pf, M, u, y) # Sample smoothing particles
xbm   = smoothed_mean(xb)   # Calculate the mean of smoothing trajectories
xbc   = smoothed_cov(xb)    # And covariance
xbt   = smoothed_trajs(xb)  # Get smoothing trajectories
xbs   = [diag(xbc) for xbc in xbc] |&gt; vecvec_to_mat .|&gt; sqrt
plot(xbm&#39;, ribbon=2xbs, lab=&quot;PF smooth&quot;)
plot!(vecvec_to_mat(x), l=:dash, lab=&quot;True&quot;)</code></pre><img src="index-0dadf6ee.svg" alt="Example block output"/><p>We can plot the particles themselves as well</p><pre><code class="language-julia hljs">downsample = 5
plot(vecvec_to_mat(x), l=(4,), layout=(2,1), show=false)
scatter!(xbt[1, 1:downsample:end, :]&#39;, subplot=1, show=false, m=(1,:black, 0.5), lab=&quot;&quot;)
scatter!(xbt[2, 1:downsample:end, :]&#39;, subplot=2, m=(1,:black, 0.5), lab=&quot;&quot;)</code></pre><img src="index-90d5eb11.png" alt="Example block output"/><h1 id="Kalman-filter"><a class="docs-heading-anchor" href="#Kalman-filter">Kalman filter</a><a id="Kalman-filter-1"></a><a class="docs-heading-anchor-permalink" href="#Kalman-filter" title="Permalink"></a></h1><p>The <a href="api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> (<a href="https://en.wikipedia.org/wiki/Kalman_filter">wiki</a>) assumes that <span>$f$</span> and <span>$g$</span> are linear functions, i.e., that they can be written on the form</p><p class="math-container">\[\begin{aligned}
x(t+1) &amp;= Ax(t) + Bu(t) + w(t)\\
y(t) &amp;= Cx(t) + Du(t) + e(t)
\end{aligned}\]</p><p>for some matrices <span>$A,B,C,D$</span> where <span>$w \sim N(0, R_1)$</span> and <span>$e \sim N(0, R_2)$</span> are zero mean and Gaussian. The Kalman filter represents the posterior distributions over <span>$x$</span> by the mean and a covariance matrix. The magic behind the Kalman filter is that linear transformations of Gaussian distributions remain Gaussian, and we thus have a very efficient way of representing them.</p><p>A Kalman filter is easily created using the constructor <a href="api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. Many of the functions defined for particle filters, are defined also for Kalman filters, e.g.:</p><pre><code class="language-julia hljs">R1 = cov(df)
R2 = cov(dg)
kf = KalmanFilter(A, B, C, 0, R1, R2, d0)
sol = forward_trajectory(kf, u, y) # sol contains filtered state, predictions, pred cov, filter cov, loglik</code></pre><p>It can also be called in a loop like the <code>pf</code> above</p><pre><code class="language-julia hljs">for t = 1:T
    kf(u,y) # Performs both correct! and predict!
    # alternatively
    ll, e = correct!(kf, y, nothing, t) # Returns loglikelihood and prediction error (plus other things if you want)
    x     = state(kf)       # Access the state estimate
    R     = covariance(kf)  # Access the covariance of the estimate
    predict!(kf, u, nothing, t)
end</code></pre><p>The matrices in the Kalman filter may be <em>time varying</em>, such that <code>A[:, :, t]</code> is <span>$A(t)$</span>. They may also be provided as functions on the form <span>$A(t) = A(x, u, p, t)$</span>. This works for both dynamics and covariance matrices. When providing functions, the dimensions of the state, input and output, <code>nx, nu, ny</code>, must be provided as keyword arguments to the filter constructor since these cannot be inferred from the function signature.</p><p>The numeric type used in the Kalman filter is determined from the mean of the initial state distribution, so make sure that this has the correct type if you intend to use, e.g., <code>Float32</code> or <code>ForwardDiff.Dual</code> for automatic differentiation.</p><h2 id="Smoothing-using-KF"><a class="docs-heading-anchor" href="#Smoothing-using-KF">Smoothing using KF</a><a id="Smoothing-using-KF-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing-using-KF" title="Permalink"></a></h2><p>Kalman filters can also be used for smoothing </p><pre><code class="language-julia hljs">kf = KalmanFilter(A, B, C, 0, cov(df), cov(dg), d0)
smoothsol = smooth(kf, u, y) # Returns a smoothing solution including smoothed state and smoothed cov</code></pre><p>Plot and compare PF and KF</p><pre><code class="language-julia hljs"># plot(smoothsol) The smoothing solution object can also be plotted directly
plot(vecvec_to_mat(smoothsol.xT), lab=&quot;Kalman smooth&quot;, layout=2)
plot!(xbm&#39;, lab=&quot;pf smooth&quot;)
plot!(vecvec_to_mat(x), lab=&quot;true&quot;)</code></pre><img src="index-fb9216f0.svg" alt="Example block output"/><h2 id="Kalman-filter-tuning-tutorial"><a class="docs-heading-anchor" href="#Kalman-filter-tuning-tutorial">Kalman filter tuning tutorial</a><a id="Kalman-filter-tuning-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Kalman-filter-tuning-tutorial" title="Permalink"></a></h2><p>The tutorial <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">&quot;How to tune a Kalman filter&quot;</a> details how to figure out appropriate covariance matrices for the Kalman filter, as well as how to add disturbance models to the system model.</p><h1 id="Unscented-Kalman-Filter"><a class="docs-heading-anchor" href="#Unscented-Kalman-Filter">Unscented Kalman Filter</a><a id="Unscented-Kalman-Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Unscented-Kalman-Filter" title="Permalink"></a></h1><p>The <a href="api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> represents posterior distributions over <span>$x$</span> as Gaussian distributions just like the <a href="api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>, but propagates them through a nonlinear function <span>$f$</span> by a deterministic sampling of a small number of particles called <em>sigma points</em> (this is referred to as the <a href="https://en.wikipedia.org/wiki/Unscented_transform"><em>unscented transform</em></a>). This UKF thus handles nonlinear functions <span>$f,g$</span>, but only Gaussian disturbances and unimodal posteriors. The UKF will <em>by default</em> treat the noise as additive, but by using the <em>augmented UKF</em> form, non-additive noise may be handled as well. See the docstring of <a href="api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> for more details.</p><p>The UKF takes the same arguments as a regular <a href="api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>, but the matrices defining the dynamics are replaced by two functions, <code>dynamics</code> and <code>measurement</code>, working in the same way as for the <code>ParticleFilter</code> above (unless the augmented form is used).</p><pre><code class="language-julia hljs">ukf = UnscentedKalmanFilter(dynamics, measurement, cov(df), cov(dg), MvNormal(SA[1.,1.]); nu, ny)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnscentedKalmanFilter{false,false,false,false}
  Inplace dynamics: false
  Inplace measurement: false
  Augmented dynamics: false
  Augmented measurement: false
  nx: 2
  nu: 1
  ny: 1
  Ts: 1.0
  t: 0
  dynamics: dynamics
  measurement_model: UKFMeasurementModel{false, false, typeof(Main.measurement), PDMats.ScalMat{Float64}, typeof(-), typeof(weighted_mean), typeof(weighted_cov), typeof(LowLevelParticleFilters.cross_cov), LowLevelParticleFilters.SigmaPointCache{Vector{StaticArraysCore.SVector{2, Float64}}, Vector{StaticArraysCore.SVector{1, Float64}}}, TrivialParams})
  R1: [0.01 0.0; 0.0 0.01]
  d0: Distributions.MvNormal{Float64, PDMats.PDiagMat{Float64, StaticArraysCore.SVector{2, Float64}}, FillArrays.Zeros{Float64, 1, Tuple{Base.OneTo{Int64}}}}(
dim: 2
μ: Zeros(2)
Σ: [1.0 0.0; 0.0 1.0]
)

  predict_sigma_point_cache: LowLevelParticleFilters.SigmaPointCache{Vector{StaticArraysCore.SVector{2, Float64}}, Vector{StaticArraysCore.SVector{2, Float64}}})
  x: [0.0, 0.0]
  R: [1.0 0.0; 0.0 1.0]
  p: NullParameters()
  reject: nothing
  state_mean: weighted_mean
  state_cov: weighted_cov
  cholesky!: cholesky!
  names: SignalNames([&quot;x1&quot;, &quot;x2&quot;], [&quot;u1&quot;], [&quot;y1&quot;], &quot;UKF&quot;)
  weight_params: TrivialParams()
  R1x: nothing
</code></pre><div class="admonition is-info" id="Info-86a2588035ba1e99"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-86a2588035ba1e99" title="Permalink"></a></header><div class="admonition-body"><p>If your function <code>dynamics</code> describes a continuous-time ODE, do not forget to <strong>discretize</strong> it before passing it to the UKF. See <a href="discretization/#Discretization">Discretization</a> for more information.</p></div></div><p>The <a href="api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> has many customization options, see the docstring for more details. In particular, the UKF may be created with a linear measurement model as an optimization.</p><h1 id="Extended-Kalman-Filter"><a class="docs-heading-anchor" href="#Extended-Kalman-Filter">Extended Kalman Filter</a><a id="Extended-Kalman-Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Kalman-Filter" title="Permalink"></a></h1><p>The <a href="api/#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a> (<a href="https://en.wikipedia.org/wiki/Extended_Kalman_filter">EKF</a>) is similar to the UKF, but propagates Gaussian distributions by linearizing the dynamics and using the formulas for linear systems similar to the standard Kalman filter. This can be slightly faster than the UKF (not always), but also less accurate for strongly nonlinear systems. The linearization is performed automatically using ForwardDiff.jl unless the user provides Jacobian functions that compute <span>$A$</span> and <span>$C$</span>. In general, the UKF is recommended over the EKF unless the EKF is faster and computational performance is the top priority.</p><p>The EKF constructor has the following two signatures</p><pre><code class="language-julia hljs">ExtendedKalmanFilter(dynamics, measurement, R1, R2, d0=MvNormal(R1); nu::Int, p = LowLevelParticleFilters.NullParameters(), α = 1.0, check = true, Ajac = nothing, Cjac = nothing)
ExtendedKalmanFilter(kf, dynamics, measurement; Ajac = nothing, Cjac = nothing)</code></pre><p>The first constructor takes all the arguments required to initialize the extended Kalman filter, while the second one takes an already defined standard Kalman filter. using the first constructor, the user must provide the number of inputs to the system, <code>nu</code>.</p><p>where <code>kf</code> is a standard <a href="api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> from which the covariance properties are taken.</p><div class="admonition is-info" id="Info-86a2588035ba1e99"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-86a2588035ba1e99" title="Permalink"></a></header><div class="admonition-body"><p>If your function <code>dynamics</code> describes a continuous-time ODE, do not forget to <strong>discretize</strong> it before passing it to the UKF. See <a href="discretization/#Discretization">Discretization</a> for more information.</p></div></div><h1 id="AdvancedParticleFilter"><a class="docs-heading-anchor" href="#AdvancedParticleFilter">AdvancedParticleFilter</a><a id="AdvancedParticleFilter-1"></a><a class="docs-heading-anchor-permalink" href="#AdvancedParticleFilter" title="Permalink"></a></h1><p>The <a href="#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> works very much like the <a href="api/#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>, but admits more flexibility in its noise models.</p><p>The <a href="#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> type requires you to implement the same functions as the regular <a href="api/#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>, but in this case you also need to handle sampling from the noise distributions yourself. The function <code>dynamics</code> must have a method signature like below. It must provide one method that accepts state vector, control vector, parameter, time <em>and</em> <code>noise::Bool</code> that indicates whether or not to add noise to the state. If noise should be added, this should be done inside <code>dynamics</code> An example is given below</p><pre><code class="language-julia hljs">using Random
const rng = Random.Xoshiro()
function dynamics(x, u, p, t, noise=false) # It&#39;s important that `noise` defaults to false
    x = A*x .+ B*u # A simple linear dynamics model in discrete time
    if noise
        x += rand(rng, df) # it&#39;s faster to supply your own rng
    end
    x
end</code></pre><p>The <code>measurement_likelihood</code> function must have a method accepting state, input, measurement, parameter and time, and returning the log-likelihood of the measurement given the state, a simple example below:</p><pre><code class="language-julia hljs">function measurement_likelihood(x, u, y, p, t)
    logpdf(dg, C*x-y) # An example of a simple linear measurement model with normal additive noise
end</code></pre><p>This gives you very high flexibility. The noise model in either function can, for instance, be a function of the state, something that is not possible for the simple <a href="api/#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Any, Function, Any, Any, Any}"><code>ParticleFilter</code></a>. To be able to simulate the <a href="#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> like we did with the simple filter above, the <code>measurement</code> method with the signature <code>measurement(x,u,p,t,noise=false)</code> must be available and return a sample measurement given state (and possibly time). For our example measurement model above, this would look like this</p><pre><code class="language-julia hljs"># This function is only required for simulation
measurement(x, u, p, t, noise=false) = C*x + noise*rand(rng, dg)</code></pre><p>We now create the <a href="#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> and use it in the same way as the other filters:</p><pre><code class="language-julia hljs">apf = AdvancedParticleFilter(N, dynamics, measurement, measurement_likelihood, df, d0)
sol = forward_trajectory(apf, u, y, ny) # Perform batch filtering</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParticleFilteringSolution{AdvancedParticleFilter{PFstate{StaticArraysCore.SVector{2, Float64}, Float64}, typeof(Main.dynamics), typeof(Main.measurement), typeof(Main.measurement_likelihood), Distributions.ZeroMeanIsoNormal{Tuple{Base.OneTo{Int64}}}, Distributions.IsoNormal, DataType, Random.Xoshiro, LowLevelParticleFilters.NullParameters}, Vector{StaticArraysCore.SVector{1, Float64}}, Vector{StaticArraysCore.SVector{1, Float64}}, Matrix{StaticArraysCore.SVector{2, Float64}}, Matrix{Float64}, Matrix{Float64}, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}(AdvancedParticleFilter{PFstate{StaticArraysCore.SVector{2, Float64}, Float64}, typeof(Main.dynamics), typeof(Main.measurement), typeof(Main.measurement_likelihood), Distributions.ZeroMeanIsoNormal{Tuple{Base.OneTo{Int64}}}, Distributions.IsoNormal, DataType, Random.Xoshiro, LowLevelParticleFilters.NullParameters}(PFstate{StaticArraysCore.SVector{2, Float64}, Float64}(StaticArraysCore.SVector{2, Float64}[[0.11783621077549938, -0.20938797114020272], [0.4928671341545565, -0.5787963731213706], [0.5067485494849765, -0.13329245916485438], [0.45358059707098836, -0.27545930036098504], [0.4545334230636301, -0.4090971456350314], [0.4459547977040288, -0.29900542422294063], [0.5715210609514872, -0.3732635453210756], [0.46014906005110945, -0.30322263419425877], [0.586880992377858, -0.07480352633323792], [0.6097041951618861, -0.15839437112193283]  …  [0.6633139891486707, -0.3415612886903345], [0.4449913129756222, -0.08563232754659733], [0.37164435058155865, -0.38243837584002865], [0.4989526586270475, -0.5398966519979431], [0.590919670686074, -0.5071925737008612], [1.1824602445547425, -0.17129349876846384], [1.2018753085476133, -0.06334671351675576], [0.7518616116658542, -0.2806915953530029], [0.8906595817219929, -0.3244924281059963], [0.7977127922244724, -0.15794186988706002]], StaticArraysCore.SVector{2, Float64}[[0.11783621077549938, -0.20938797114020272], [0.4928671341545565, -0.5787963731213706], [0.5067485494849765, -0.13329245916485438], [0.45358059707098836, -0.27545930036098504], [0.4545334230636301, -0.4090971456350314], [0.4459547977040288, -0.29900542422294063], [0.5715210609514872, -0.3732635453210756], [0.46014906005110945, -0.30322263419425877], [0.586880992377858, -0.07480352633323792], [0.6097041951618861, -0.15839437112193283]  …  [0.6633139891486707, -0.3415612886903345], [0.4449913129756222, -0.08563232754659733], [0.37164435058155865, -0.38243837584002865], [0.4989526586270475, -0.5398966519979431], [0.590919670686074, -0.5071925737008612], [1.1824602445547425, -0.17129349876846384], [1.2018753085476133, -0.06334671351675576], [0.7518616116658542, -0.2806915953530029], [0.8906595817219929, -0.3244924281059963], [0.7977127922244724, -0.15794186988706002]], [-7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082  …  -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082, -7.600902459542082], [0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005  …  0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005], Base.RefValue{Float64}(0.0), [2, 7, 8, 9, 9, 9, 9, 9, 10, 10  …  1989, 1990, 1992, 1992, 1992, 1995, 1997, 1999, 1999, 1999], [6.252870842283546e-9, 0.0004433059687780216, 0.00049335198147567, 0.0007639931222619149, 0.0007654201965826733, 0.0007677158418010143, 0.0012160085111965076, 0.0017778656158604091, 0.0040666310580493685, 0.005202037717226694  …  0.9963194798217107, 0.997535601640007, 0.9975395674022108, 0.9975433189707377, 0.9978609784546852, 0.9982179066144509, 0.9987589534323856, 0.9987609631605404, 0.9998434575797154, 1.0000000000000016], Base.RefValue{Int64}(81)), Main.dynamics, Main.measurement, Main.measurement_likelihood, ZeroMeanIsoNormal(
dim: 2
μ: Zeros(2)
Σ: [0.010000000000000002 0.0; 0.0 0.010000000000000002]
)
, IsoNormal(
dim: 2
μ: [0.1899285619974648, -0.8048164305714557]
Σ: [4.0 0.0; 0.0 4.0]
)
, 0.5, LowLevelParticleFilters.ResampleSystematic, Random.Xoshiro(0x9c348e9c63ed5ae7, 0x6dd50cf183fe868e, 0xf62970f54f35d0c4, 0xebbb61f5b0a4959b, 0x8aec44a6103775c5), LowLevelParticleFilters.NullParameters(), false, 1.0, -1, -1), StaticArraysCore.SVector{1, Float64}[[0.6555358521572436], [0.6032031766490537], [-0.35123445761033845], [-0.5326983272747153], [-0.5191028670375376], [0.3678027290691326], [-1.296868820416953], [0.7534921358611685], [-0.16444944165321776], [-0.6888451004157357]  …  [1.632751324052247], [-0.10962903258803663], [-1.1549815836906716], [0.02857986359765412], [3.115918223703851], [-0.47531765032786044], [-1.628258288556395], [0.4621105612550945], [1.3693577927017182], [0.1557798566323104]], StaticArraysCore.SVector{1, Float64}[[-0.9557905050821636], [-0.7943305134707648], [-0.5005051030575152], [-0.4725764008095803], [0.09556138067022485], [-0.0009761256798803894], [0.08542605413321738], [0.4144873664202536], [0.09841995862638489], [0.6177281846374361]  …  [-0.35817684044570075], [-0.4807177663390705], [-0.8776539830109783], [-0.8184116428785099], [-0.7593332631030528], [-0.2908666163567845], [-0.1353075278437138], [-0.5117065892236529], [-0.36559924176873687], [-0.48756186162036524]], StaticArraysCore.SVector{2, Float64}[[0.4226581769355219, -1.9468528058964023] [-4.383518646982519, -1.0576954951015256] … [0.6360656645686166, 0.1653181235598263] [0.6057422595322501, 0.2875619852136055]; [0.41633182101530053, -1.9442683906978622] [-4.558144476150007, -1.089380253205115] … [0.1816564013223258, -0.3482847717807107] [0.13207037097094976, -0.2200974070207687]; … ; [3.3024036702130357, -0.9897284118695893] [3.4425756591582735, -0.49428644324028437] … [0.5755575738276293, -0.3829841356823327] [0.7385984964254879, -0.2682858719835349]; [1.0016660177244419, 0.020810558166200477] [3.427055128104764, -0.6285068578376575] … [0.07998330940670437, -0.2841244651475083] [0.1257771638122217, -0.20299864398318312]], [-17.566272489176498 -7.843368983385732 … -11.974953263595413 -18.890225143894654; -17.502323067377365 -8.064534425484942 … -7.421989369978704 -7.721264457072531; … ; -5.30311370695024 -8.101685615024513 … -6.822403102041756 -6.82848725359748; -17.21058689720928 -7.320073623612687 … -8.344921062005746 -8.762183528571656], [2.3499833776153205e-8 0.0003923450077723459 … 6.300048264304531e-6 6.252870842283546e-9; 2.5051727057589e-8 0.00031449750172848705 … 0.0005979584009998475 0.00044329971590717927; … ; 0.004976075718352899 0.0003030279189275782 … 0.0010891005552678412 0.001082494419174973; 3.3537993809295466e-8 0.0006621134622326626 … 0.00023760021585257898 0.0001565424202861431], -3.7432330119088784, 0.0:1.0:79.0)</code></pre><pre><code class="language-julia hljs">plot(sol, xreal=x)</code></pre><img src="index-8f224158.png" alt="Example block output"/><p>We can even use this type as an <a href="api/#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>AuxiliaryParticleFilter</code></a></p><pre><code class="language-julia hljs">apfa = AuxiliaryParticleFilter(apf)
sol = forward_trajectory(apfa, u, y, ny)
plot(sol, dim=1, xreal=x) # Same as above, but only plots a single dimension</code></pre><img src="index-199db7d5.png" alt="Example block output"/><p>See the tutorials section for more advanced examples, including state estimation for DAE (Differential-Algebraic Equation) systems.</p><h1 id="Troubleshooting-and-tuning"><a class="docs-heading-anchor" href="#Troubleshooting-and-tuning">Troubleshooting and tuning</a><a id="Troubleshooting-and-tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting-and-tuning" title="Permalink"></a></h1><h2 id="Particle-filters"><a class="docs-heading-anchor" href="#Particle-filters">Particle filters</a><a id="Particle-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-filters" title="Permalink"></a></h2><p>Tuning a particle filter can be quite the challenge. To assist with this, we provide som visualization tools</p><pre><code class="language-julia hljs">debugplot(pf,u[1:20],y[1:20], runall=true, xreal=x[1:20])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Time     Surviving    Effective nbr of particles
--------------------------------------------------------------
t:     1   1.000    2000.0
t:     2   1.000     261.4
t:     3   0.143    2000.0
t:     4   1.000    1238.3
t:     5   1.000     870.3
t:     6   1.000     427.1
t:     7   1.000     333.3
t:     8   1.000     249.6
t:     9   0.182    2000.0
t:    10   1.000     940.7
t:    11   1.000    1003.6
t:    12   1.000     831.4
t:    13   1.000     601.1
t:    14   1.000     515.6
t:    15   1.000     380.0
t:    16   1.000     306.7
t:    17   1.000     230.3
t:    18   0.160    2000.0
t:    19   1.000    1173.5
t:    20   1.000     674.1</code></pre><p>The plot displays all state variables and all measurements. The heatmap in the background represents the weighted particle distributions per time step. For the measurement sequences, the heatmap represent the distributions of predicted measurements. The blue dots corresponds to measured values. In this case, we simulated the data and we had access to the state as well, if we do not have that, just omit <code>xreal</code>. You can also manually step through the time-series using</p><ul><li><code>commandplot(pf,u,y; kwargs...)</code></li></ul><p>For options to the debug plots, see <code>?pplot</code>.</p><h2 id="Troubleshooting-Kalman-filters"><a class="docs-heading-anchor" href="#Troubleshooting-Kalman-filters">Troubleshooting Kalman filters</a><a id="Troubleshooting-Kalman-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting-Kalman-filters" title="Permalink"></a></h2><ul><li><strong>Filter state diverges</strong>: This may be due to an unstable system model, forgetting to discretize a continuous-time model, or inadequate integration of a nonlinear model (too large time step etc.).</li><li><strong>Covariance estimate blows up</strong>: If the estimated covariance for one or several state variables grows without bound, the system may be <em>unobservable</em>. Observability is a property of the dynamics and the measurement model (i.e., which sensors are available), see <a href="param_est_identifiability/#Identifiability">Identifiability</a> for more details. If the estimated mean blows up as well, inadequate integration may be at fault.</li><li>A persistent <strong>difference between predicted and filtered state estimates</strong>: This may have several causes<ul><li>The dynamics noise covariance is tuned too low, or the model is not controllable from the noise inputs (not enough degrees of freedom in the noise / the covariance matrix of the noise is singular).</li><li>Model error that is not accounted for by any disturbance model.</li><li>Sensor bias. This can be handled by an integrating disturbance model affecting the output.</li></ul></li><li>Sluggish filter performance (lag): <em>Increase</em> the dynamics noise covariance <span>$R_1$</span> or <em>decrease</em> the measurement noise covariance <span>$R_2$</span>.</li><li>Noisy state estimates: If the filter is affected too much by measurement noise, <em>decrease</em> the dynamics noise covariance <span>$R_1$</span> or <em>increase</em> the measurement noise covariance <span>$R_2$</span> (the opposite action to when the filter is too sluggish).</li><li>A commonly occurring error is <strong>&quot;Cholesky factorization failed&quot;</strong>, which may occur due to several different reasons<ul><li>The dynamics is diverging and the covariance matrices end up with NaNs or Infs. If this is the case, verify that the dynamics is correctly implemented and that the integration is sufficiently accurate, especially if using a fixed-step integrator like any of those from SeeToDee.jl.</li><li>The covariance matrix is poorly conditioned and numerical issues make causes it to lose positive definiteness. This issue is rare, but can be mitigated by using the <a href="api/#LowLevelParticleFilters.SqKalmanFilter"><code>SqKalmanFilter</code></a>, rescaling the dynamics or by using a different cholesky factorization method (available in UKF only).</li></ul></li></ul><p>See <a href="api/#LowLevelParticleFilters.sampleplot"><code>sampleplot</code></a> for help with sampling-based tuning and <a href="api/#LowLevelParticleFilters.validationplot"><code>validationplot</code></a> for tuning validation. </p><h2 id="Tuning-noise-parameters-through-optimization"><a class="docs-heading-anchor" href="#Tuning-noise-parameters-through-optimization">Tuning noise parameters through optimization</a><a id="Tuning-noise-parameters-through-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-noise-parameters-through-optimization" title="Permalink"></a></h2><p>See examples in <a href="@ref">Parameter Estimation</a>. See also <a href="api/#LowLevelParticleFilters.autotune_covariances"><code>autotune_covariances</code></a> and <a href="api/#LowLevelParticleFilters.validationplot"><code>validationplot</code></a> for validation of tuning.</p><h2 id="Tuning-through-simulation"><a class="docs-heading-anchor" href="#Tuning-through-simulation">Tuning through simulation</a><a id="Tuning-through-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-through-simulation" title="Permalink"></a></h2><p>It is possible to sample from the Bayesian model implied by a filter and its parameters by calling the function <a href="api/#LowLevelParticleFilters.simulate"><code>simulate</code></a>. A simple tuning strategy is to adjust the noise parameters such that a simulation looks &quot;similar&quot; to the data, i.e., the data must not be too unlikely under the model. See also <a href="api/#LowLevelParticleFilters.sampleplot"><code>sampleplot</code></a> that facilitates this procedure.</p><h1 id="Videos"><a class="docs-heading-anchor" href="#Videos">Videos</a><a id="Videos-1"></a><a class="docs-heading-anchor-permalink" href="#Videos" title="Permalink"></a></h1><p>Several video tutorials using this package are available in the playlists</p><ul><li><a href="https://www.youtube.com/playlist?list=PLC0QOsNQS8ha6SwaNOZDXyG9Bj8MPbF-q">System identification in Julia</a></li><li><a href="https://www.youtube.com/playlist?list=PLC0QOsNQS8hZtOQPHdtul3kpQwMOBL8Qc">Control systems in Julia</a></li></ul><p>Some examples featuring this package in particular are</p><hr/><p><strong>Using an optimizer to optimize the likelihood of an <a href="api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>:</strong></p><iframe style="height: 315px; width: 560px" src="https://www.youtube.com/embed/0RxQwepVsoM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><hr/><p><strong>Estimation of time-varying parameters:</strong></p><iframe style="height: 315px; width: 560px" src="https://www.youtube.com/embed/zJcOPPLqv4A?si=XCvpo3WD-4U3PJ2S" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><hr/><p><strong>Adaptive control by means of estimation of time-varying parameters:</strong></p><iframe style="height: 315px; width: 560px" src="https://www.youtube.com/embed/Ip_prmA7QTU?si=Fat_srMTQw5JtW2d" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="discretization/">Discretization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 09:50">Thursday 4 December 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
