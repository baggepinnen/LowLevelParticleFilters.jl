<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unscented transform · LowLevelParticleFilters Documentation</title><meta name="title" content="Unscented transform · LowLevelParticleFilters Documentation"/><meta property="og:title" content="Unscented transform · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="Unscented transform · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../measurement_models/">Multiple measurement models</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="../beetle_example_imm/">IMM-filter tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="../adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="../neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="../fault_detection/">Fault detection</a></li><li class="is-active"><a class="tocitem" href>Unscented transform</a><ul class="internal"><li><a class="tocitem" href="#Covariance-propagation-through-nonlinear-functions"><span>Covariance propagation through nonlinear functions</span></a></li><li><a class="tocitem" href="#Tuning-parameters"><span>Tuning parameters</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Unscented transform</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Unscented transform</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/ut.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Unscented-transform"><a class="docs-heading-anchor" href="#Unscented-transform">Unscented transform</a><a id="Unscented-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Unscented-transform" title="Permalink"></a></h1><p>In this section, we demonstrate how the unscented transform, used in the <a href="../api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>, propagates a normal distribution through a nonlinear function. </p><h2 id="Covariance-propagation-through-nonlinear-functions"><a class="docs-heading-anchor" href="#Covariance-propagation-through-nonlinear-functions">Covariance propagation through nonlinear functions</a><a id="Covariance-propagation-through-nonlinear-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-propagation-through-nonlinear-functions" title="Permalink"></a></h2><p>The propagation of a Gaussian distribution through an affine (or linear) function <span>$f(x) = Ax+b$</span> is trivial, the distribution <span>$N(μ, Σ)$</span> is transformed into <span>$N(Aμ + b, AΣA^T)$</span>, i.e., it remains Gaussian. This fact is what makes the standard <a href="../api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> so computationally efficient. However, when the function is nonlinear, the transformation is not as straightforward and the posterior is generally not Gaussian. The unscented transform (UT) is a method to <em>approximate</em> the transformation of a Gaussian distribution through a nonlinear function. The UT is based on the idea of propagating a set of <em>sigma points</em> through the function and then computing the mean and covariance of the resulting distribution. Below, we demonstrate how a normal distribution is transformed through a number of nonlinear functions.</p><p>For comparison, we also show how the <a href="../api/#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a> and <a href="../api/#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>ParticleFilter</code></a> propagate the covariance. EKF uses linearization while particle filters propagate a large number of samples. We load the <code>ForwardDiff</code> package to compute the Jacobian of the function.</p><pre><code class="language-julia hljs">using LowLevelParticleFilters, Plots
using LowLevelParticleFilters: sigmapoints
using ForwardDiff, Distributions
Plots.default(fillalpha=0.3) # This makes the covariance ellipse more transparent
kwargs = (; markersize=4, markeralpha=0.7, markerstrokewidth=0)

function ekf_propagate_plot(f, μ, Σ; kwargs...)
    x = μ
    A = ForwardDiff.jacobian(f, x)
    μ = f(x)
    Σ = A * Σ * A&#39;
    covplot!(μ, Σ; kwargs...)
end

function sample_propagate_plot(f, μ, Σ; kwargs...)
    xpart = rand(MvNormal(μ, Σ), 10000)
    ypart = f.(eachcol(xpart))
    scatter!(first.(ypart), last.(ypart); markerstrokealpha=0, markerstrokewidth=0, markeralpha=0.15, markersize=1, kwargs..., lab=&quot;&quot;)
    ym = mean(ypart)
    yS = cov(ypart)
    covplot!(ym, yS; kwargs...)
    scatter!([ym[1]], [ym[2]]; markersize=4, markershape=:x, kwargs..., lab=&quot;&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sample_propagate_plot (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">μ = [1.0, 2.0]
Σ = [1.0 0.5; 0.5 1.0]
x = sigmapoints(μ, Σ, TrivialParams())
n = length(x)
f1(x) = [x[1]^2+1, sin(x[2])]
y = f1.(x)
unscentedplot(x; lab=&quot;Input&quot;, c=:blue, fillalpha=0.1, kwargs...)
unscentedplot!(y; lab=&quot;Output UKF&quot;, c=:red, kwargs...)
ekf_propagate_plot(f1, μ, Σ; lab=&quot;Output EKF&quot;, c=:orange)
sample_propagate_plot(f1, μ, Σ; lab=&quot;Output particles&quot;, c=:green)
# Plot lines from each input point to each output point
plot!([first.(x)&#39;; first.(y)&#39;; fill(Inf, 1, n)][:], [last.(x)&#39;; last.(y)&#39;; fill(Inf, 1, n)][:], c=:black, alpha=0.5, primary=false)</code></pre><img src="ac8fc829.png" alt="Example block output"/><p>For this first function, <span>$f_1(x) = [x_1^2+1, \sin(x_2)]$</span>, the UT and linearization-based propagation produce somewhat similar results, but the posterior distribution of the UT is much closer to the particle distribution than the EKF.</p><pre><code class="language-julia hljs">f2(x) = [x[1]*x[2], x[1]+x[2]]
y = f2.(x)
unscentedplot(x; lab=&quot;Input&quot;, c=:blue, fillalpha=0.1, kwargs...)
unscentedplot!(y; lab=&quot;Output UKF&quot;, c=:red, kwargs...)
ekf_propagate_plot(f2, μ, Σ; lab=&quot;Output EKF&quot;, c=:orange)
sample_propagate_plot(f2, μ, Σ; lab=&quot;Output particles&quot;, c=:green)
plot!([first.(x)&#39;; first.(y)&#39;; fill(Inf, 1, n)][:], [last.(x)&#39;; last.(y)&#39;; fill(Inf, 1, n)][:], c=:black, alpha=0.5, primary=false, xlims=(-5, 12))</code></pre><img src="b7d4487b.png" alt="Example block output"/><p>For the second function, <span>$f_2(x) = [x_1 x_2, x_1+x_2]$</span>, the posterior distribution is highly non-Gaussian. Both the UT and EKF style propagation do reasonable jobs capturing the posterior mean, but the UT does a better, although far from perfect, job at capturing the posterior covariance.</p><pre><code class="language-julia hljs">f3((x,y)) = [sqrt((1 - x)^2 + (0.1 - y)^2), atan(0.9 - y, 1.0 - x)] # Robot localization measurement model
y = f3.(x)
unscentedplot(x; lab=&quot;Input&quot;, c=:blue, fillalpha=0.1, kwargs...)
unscentedplot!(y; lab=&quot;Output UKF&quot;, c=:red, kwargs...)
ekf_propagate_plot(f3, μ, Σ; lab=&quot;Output EKF&quot;, c=:orange)
sample_propagate_plot(f3, μ, Σ; lab=&quot;Output particles&quot;, c=:green)
plot!([first.(x)&#39;; first.(y)&#39;; fill(Inf, 1, n)][:], [last.(x)&#39;; last.(y)&#39;; fill(Inf, 1, n)][:], c=:black, alpha=0.5, primary=false)</code></pre><img src="9938a6c3.png" alt="Example block output"/><p>For the function <span>$f_3(x) = [\sqrt{(1 - x)^2 + (0.1 - y)^2}, \arctan(0.9 - y, 1.0 - x)]$</span>, the posterior distribution is once again highly non-Gaussian. The EKF misses to place any significant output probability mass in the region around the input, which the UT does by placing one sigma point in this region. When the particle distribution is approximated by a Gaussian, neither the UT or EKF does very well approximating this Gaussian.</p><h2 id="Tuning-parameters"><a class="docs-heading-anchor" href="#Tuning-parameters">Tuning parameters</a><a id="Tuning-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-parameters" title="Permalink"></a></h2><p>The unscented transform that underpins the <a href="../api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> may be tuned to adjust the spread of the points. By default, <a href="../api/#LowLevelParticleFilters.TrivialParams"><code>TrivialParams</code></a> are used, but one may also opt for the <a href="../api/#LowLevelParticleFilters.WikiParams"><code>WikiParams</code></a> or <a href="../api/#LowLevelParticleFilters.MerweParams"><code>MerweParams</code></a> which are more commonly used in the literature.</p><p>The code snippets below demonstrate how to create different sets of parameters and visualizes the sigma points generated by each set of parameters for a trivial normal 2D distribution, as well has how the points propagate through a simple function.</p><p>We start by visualizing the sigma points generated by the different parameters sets using their default parameters.</p><pre><code class="language-julia hljs">μ = [0.0, 0.0]
Σ = [1.0 0.0; 0.0 1.0]
wpars = WikiParams(α = 1.0, β = 0.0, κ = 1)
wxs = sigmapoints(μ, Σ, wpars)

mpars = MerweParams(α = 1.0, β = 2.0, κ = 0.0)
mxs = sigmapoints(μ, Σ, mpars)

tpars = TrivialParams()
txs = sigmapoints(μ, Σ, tpars)

unscentedplot(wxs, wpars; lab=&quot;Wiki&quot;, c=:green, kwargs...)
unscentedplot!(mxs, mpars; lab=&quot;Merwe&quot;, c=:red, kwargs...)
unscentedplot!(txs, tpars; lab=&quot;Trivial&quot;, c=:blue, kwargs...)</code></pre><img src="e4bbe3df.svg" alt="Example block output"/><p>In this plot, we don&#39;t see the Merwe points because they are all behind the Trivial points. The Wiki points are less spread out. They all represent exactly the same distribution though, all their covariance ellipses overlap. Different sets of points can represent the same probability distribution by means of different weights that are assigned to each point.</p><p>Below, we demonstrate how the points propagate through a simple function. We use the function <span>$f(x) = [\max(0, x[1]), x[2]]$</span> which is a simple function that forces the first state component to be positive.</p><pre><code class="language-julia hljs">f(x) = [max(zero(x[1]), x[1]), x[2]]
wxs2 = f.(wxs) # Propagate the points through the function
mxs2 = f.(mxs)
txs2 = f.(txs)
unscentedplot(wxs2, wpars; lab=&quot;Wiki&quot;, c=:green ,kwargs...)
unscentedplot!(mxs2, mpars; lab=&quot;Merwe&quot;, c=:red ,kwargs...)
unscentedplot!(txs2, tpars; lab=&quot;Trivial&quot;, c=:blue ,kwargs...)</code></pre><img src="d82a8bc1.svg" alt="Example block output"/><p>We now see that the Merwe points resulted in a large covariance of the output. We see that the posterior mean is skewed positively due to the clamping of <span>$f$</span>, but the mean is skewed less for the trivial parameters than the Wiki parameters, with Merwe somewhere inbetween.</p><p>By tweaking the parameters, we can obtain different behavior, below we show the spread of the points for different values of <span>$α, β, κ$</span></p><pre><code class="language-julia hljs">wpars = WikiParams(α = 1, β = -3.0, κ = 10)
wxs = sigmapoints(μ, Σ, wpars)

mpars = MerweParams(α = 1, β = -3.0, κ = 10)
mxs = sigmapoints(μ, Σ, mpars)

unscentedplot(wxs, wpars; lab=&quot;Wiki&quot;, c=:green, kwargs...)
unscentedplot!(mxs, mpars; lab=&quot;Merwe&quot;, c=:red, kwargs...)
unscentedplot!(txs, tpars; lab=&quot;Trivial&quot;, c=:blue, kwargs...)</code></pre><img src="b4ea908e.svg" alt="Example block output"/><p>This time, the Wiki and Merwe parameters are much more spread out than the Trivial parameters. When we propagate these points through the function:</p><pre><code class="language-julia hljs">wxs2 = f.(wxs)
mxs2 = f.(mxs)
txs2 = f.(txs)
unscentedplot(wxs2, wpars; lab=&quot;Wiki&quot;, c=:green, kwargs...)
unscentedplot!(mxs2, mpars; lab=&quot;Merwe&quot;, c=:red, kwargs...)
unscentedplot!(txs2, tpars; lab=&quot;Trivial&quot;, c=:blue, kwargs...)</code></pre><img src="9f8fae18.svg" alt="Example block output"/><p>we see that the Wiki and Merwe parameters produced a posterior mean close to zero, while the Trivial parameters are more positively skewed.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fault_detection/">« Fault detection</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 11 March 2025 07:13">Tuesday 11 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
