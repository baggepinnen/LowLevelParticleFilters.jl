<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IMM-filter tutorial · LowLevelParticleFilters Documentation</title><meta name="title" content="IMM-filter tutorial · LowLevelParticleFilters Documentation"/><meta property="og:title" content="IMM-filter tutorial · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="IMM-filter tutorial · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../measurement_models/">Multiple measurement models</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li class="is-active"><a class="tocitem" href>IMM-filter tutorial</a><ul class="internal"><li><a class="tocitem" href="#Tuning-by-optimization"><span>Tuning by optimization</span></a></li></ul></li><li><a class="tocitem" href="../rbpf_example/">Rao-Blackwellized PF tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="../adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="../neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="../fault_detection/">Fault detection</a></li><li><a class="tocitem" href="../ut/">Unscented transform</a></li><li><a class="tocitem" href="../disturbance_gallery/">Disturbance gallery</a></li><li><a class="tocitem" href="../sample_rate/">Influence of sample rate on performance</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>IMM-filter tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IMM-filter tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/beetle_example_imm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Filtering-the-track-of-a-moving-beetle-using-IMM"><a class="docs-heading-anchor" href="#Filtering-the-track-of-a-moving-beetle-using-IMM">Filtering the track of a moving beetle using IMM</a><a id="Filtering-the-track-of-a-moving-beetle-using-IMM-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-the-track-of-a-moving-beetle-using-IMM" title="Permalink"></a></h1><p>This tutorial is very similar to <a href="../beetle_example/#Smoothing-the-track-of-a-moving-beetle">Smoothing the track of a moving beetle</a>, but uses an Interacting Multiple Models (IMM) filter to model the mode switching of the beetle. The IMM filter is a mixture model, in this case with internal Unscented Kalman filters, where each Kalman filter represents a different mode of the system. The IMM filter is able to switch between these modes based on the likelihood of the mode given the data.</p><p>This is an example of smoothing the 2-dimensional trajectory of a moving dung beetle. The example spurred off of <a href="https://discourse.julialang.org/t/smoothing-tracks-with-a-kalman-filter/24209?u=yakir12">this Discourse topic</a>. For more information about the research behind this example, see <a href="https://www.lunduniversity.lu.se/article/artificial-light-disrupts-dung-beetles-sense-direction">Artificial light disrupts dung beetles’ sense of direction</a> and <a href="https://pubmed.ncbi.nlm.nih.gov/32902692/">A dung beetle that path integrates without the use of landmarks</a>. Special thanks to Yakir Gagnon for providing this example.</p><p>In this example we will describe the position coordinates, <span>$x$</span> and <span>$y$</span>, of the beetle as functions of its velocity, <span>$v_t$</span>, and direction, <span>$θ_t$</span>:</p><p class="math-container">\[\begin{aligned}
x_{t+1} &amp;= x_t + \cos(θ_t)v_t \\
y_{t+1} &amp;= y_t + \sin(θ_t)v_t \\
v_{t+1} &amp;= v_t + e_t \\
θ_{t+1} &amp;= θ_t + w_t
\end{aligned}\]</p><p>where <span>$e_t ∼ N(0,σ_e), w_t ∼ N(0,σ_w)$</span> The beetle further has two &quot;modes&quot;, one where it&#39;s moving towards a goal, and one where it&#39;s searching in a more erratic manner. Figuring out when this mode switch occurs is the goal of the filtering. The mode will be encoded as two different models, where the difference between the models lies in the amount of dynamic noise affecting the angle of the beetle, i.e., in the searching mode, the beetle has more angle noise. The mode switching is modeled as a stochastic process with a binomial distribution (coin flip) describing the likelihood of a switch from mode 0 (moving to goal) and mode 1 (searching). Once the beetle has started searching, it stays in that mode, i.e., the searching mode is &quot;sticky&quot; or &quot;terminal&quot;.</p><p>The image below shows an example video from which the data is obtained <img src="https://global.discourse-cdn.com/julialang/original/3X/7/9/79a9255c4fc79677249fce7321c8c70f3df46431.gif" alt="Bettle"/></p><p>We load a single experiment from file for the purpose of this example (in practice, there may be hundreds of experiments)</p><pre><code class="language-julia hljs">using LowLevelParticleFilters, LinearAlgebra, StaticArrays, Distributions, Plots, Random
using DelimitedFiles
cd(@__DIR__)
path = &quot;../track.csv&quot;
xyt = readdlm(path)
tosvec(y) = reinterpret(SVector{length(y[1]),Float64}, reduce(hcat,y))[:] |&gt; copy # helper function
y = tosvec(collect(eachrow(xyt[:,1:2])))</code></pre><p>We then define some properties of the dynamics and the filter. We will use an <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> since we want to have fine-grained control over the noise sampling for the mode switch.</p><pre><code class="language-julia hljs">nx = 4 # Dimension of state: we have position (2d), speed and angle
ny = 2 # Dimension of measurements, we can measure the x and the y
@inline pos(s) = s[SVector(1,2)]
@inline vel(s) = s[3]
@inline ϕ(s) = s[4]</code></pre><p>We then define the probability distributions we need. The IMM filter takes a transition-probability matrix, <span>$P$</span>, and an initial mixing probability, <span>$μ$</span>. <span>$P$</span> is a Markov (stochastic) matrix, where each row sums to one, and <code>P[i, j]</code> is the probability of switching from mode <code>i</code> to mode <code>j</code>. <code>μ</code> is a vector of probabilities, where <code>μ[i]</code> is the probability of starting in mode <code>i</code>. We also define the noise distributions for the dynamics and the measurements. The dynamics noise is modeled as a Gaussian distribution with a standard deviation of <code>dvσ</code> for the velocity and <code>ϕσ</code> for the angle. The measurement noise is modeled as a Gaussian distribution with a standard deviation of <code>dgσ</code>. The initial state is modeled as a Gaussian distribution with a mean at the first measurement and a standard deviation of <code>d0</code>.</p><pre><code class="language-julia hljs">dgσ = 1.0 # the deviation of the measurement noise distribution
dvσ = 0.3 # the deviation of the dynamics noise distribution
ϕσ  = 0.5
P = [0.995 0.005; 0.0 1] # Transition probability matrix, we model the search mode as &quot;terminal&quot;
μ = [1.0, 0.0] # Initial mixing probabilities
R1 = Diagonal([1e-1, 1e-1, dvσ, ϕσ].^2)
R2 = dgσ^2*I(ny) # Measurement noise covariance matrix
d0 = MvNormal(SVector(y[1]..., 0.5, atan((y[2]-y[1])...)), [3.,3,2,2])</code></pre><p>We now define the dynamics, which is directly defined in discrete time. The third argument is a parameter we call <code>modegain</code>, which is used to scale the amount of noise in the angle of the beetle depending on the mode in which it is in. The last argument is a boolean that tells the dynamics function which mode it is in, we will close over this argument when defining the dynamics for the individual Kalman filters that are part of the IMM, one will use <code>m = false</code> and one will use <code>m = true</code>.</p><pre><code class="language-julia hljs">@inline function dynamics(s,_,modegain,t,w,m)
    # current state
    v = vel(s)
    a = ϕ(s)
    p = pos(s)

    y_noise, x_noise, v_noise, ϕ_noise = w

    # next state
    v⁺ = max(0.999v + v_noise, 0.0)
    a⁺ = a + (ϕ_noise*(1 + m*modegain))/(1 + v⁺) # next state velocity is used here
    p⁺ = p + SVector(y_noise, x_noise) + SVector(sincos(a))*v⁺ # current angle but next velocity
    SVector(p⁺[1], p⁺[2], v⁺, a⁺) # all next state
end
@inline measurement(s,u,p,t) = s[SVector(1,2)] # We observe the position coordinates with the measurement</code></pre><p>In this example, we have no control inputs, we thus define a vector of only zeros. We then solve the forward filtering problem and plot the results.</p><pre><code class="language-julia hljs">u = zeros(length(y)) # no control inputs
kffalse = UnscentedKalmanFilter{false,false,true,false}((x,u,p,t,w)-&gt;dynamics(x,u,p,t,w,false), measurement, R1, R2, d0; ny, nu=0, p=10)
kftrue = UnscentedKalmanFilter{false,false,true,false}((x,u,p,t,w)-&gt;dynamics(x,u,p,t,w,true), measurement, R1, R2, d0; ny, nu=0, p=10)

imm = IMM([kffalse, kftrue], P, μ; p = 10)

T = length(y)
sol = forward_trajectory(imm, u, y, interact=true)
figx = plot(sol, plotu=false, plotRt=true)
figmode = plot(sol.extra&#39;, title=&quot;Mode&quot;)
plot(figx, figmode)</code></pre><img src="9e8e79b0.png" alt="Example block output"/><p>If you have followed the particle filter tutorial <a href="../beetle_example/#Smoothing-the-track-of-a-moving-beetle">Smoothing the track of a moving beetle</a>, you will notice that the result here is much worse. We used noise parameters similar to in the particle-gilter example, but those were tuned fo the particle filter. Below, we will attempt to optimize the performance of the IMM filter.</p><h2 id="Tuning-by-optimization"><a class="docs-heading-anchor" href="#Tuning-by-optimization">Tuning by optimization</a><a id="Tuning-by-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-by-optimization" title="Permalink"></a></h2><p>We will attempt to optimize the dynamics and measurement noise covariance matrices and the <code>modegain</code> parameter. We code this up in two functions, one that takes the parameter vector and returns an <a href="../api/#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter, and one that calculates the loss given the filter. We will optimize the log-likelihood of the data given the filter.</p><pre><code class="language-julia hljs">params = [log10.(diag(R1)); log10(1); log10(10)]

function get_opt_kf(p)
    T = eltype(p)
    R1i = Diagonal(SVector{4}(exp10.(p[1:4])))
    R2i = SMatrix{2,2}(exp10(p[5])*R2)
    d0i = MvNormal(SVector{4, T}(T.(d0.μ)), SMatrix{4,4}(T.(d0.Σ)))
    modegain = 2+exp10(p[6])
    Pi = SMatrix{2,2, Float64,4}(P)
    # sigmoid(x) = 1/(1+exp(-x))
    # switch_prob = sigmoid(p[7])
    # Pi = [1-switch_prob switch_prob; 0 1]
    kffalse = UnscentedKalmanFilter{false,false,true,false}((x,u,p,t,w)-&gt;dynamics(x,u,p,t,w,false), measurement, R1i, R2i, d0i; ny, nu=0)
    kftrue = UnscentedKalmanFilter{false,false,true,false}((x,u,p,t,w)-&gt;dynamics(x,u,p,t,w,true), measurement, R1i, R2i, d0i; ny, nu=0)

    IMM([kffalse, kftrue], Pi, T.(μ), p=modegain)
end
function cost(pars)
    try
        imm = get_opt_kf(pars)
        T = length(y)
        ll = loglik(imm, u[1:T], y[1:T], interact=true) - 1/2*logdet(imm.models[1].R1)
        return -ll
    catch e
        # rethrow() # If you only get Inf, you can uncomment this line to see the error message
        return eltype(pars)(Inf)
	end
end

using Optim
Random.seed!(0)
res = Optim.optimize(
    cost,
    params,
    ParticleSwarm(), # Use a gradient-free optimizer. ForwardDiff works, but the algorithm is numerically difficult to compute gradients through and may suffer from overflows in the gradient computation
    Optim.Options(
        show_trace        = true,
        show_every        = 5,
        iterations        = 100,
        time_limit        = 30,
    ),
)

imm = get_opt_kf(res.minimizer)

sol = forward_trajectory(imm, u, y)
plot(sol.extra&#39;, title=&quot;Mode (optimized filter)&quot;)</code></pre><img src="f80511fe.svg" alt="Example block output"/><p>If it went well, the filter should be in mode 1 (the <code>false</code> mode) from the start until around 200 time steps, at which point it should switch to model 2 (<code>true</code>). This method of detecting the mode switch of the beetle appears to be somewhat less robust than the particle filter, but is significantly cheaper computationally. </p><p>The IMM filter does not stick in mode 2 perpetually after having reached it since it never actually becomes fully confident that mode 2 has been reached, but detecting the first switch is sufficient to know that the switch has occurred. </p><p>The log-likelihood of the solution</p><pre><code class="language-julia hljs">sol.ll</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-1660.8132416661103</code></pre><p>should be similar to that of the particle-filter in the tutorial <a href="../beetle_example/#Smoothing-the-track-of-a-moving-beetle">Smoothing the track of a moving beetle</a>, which was around -1660.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../beetle_example/">« Particle-filter tutorial</a><a class="docs-footer-nextpage" href="../rbpf_example/">Rao-Blackwellized PF tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 31 July 2025 18:01">Thursday 31 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
