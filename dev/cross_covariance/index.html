<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cross-covariance between dynamics and measurement · LowLevelParticleFilters Documentation</title><meta name="title" content="Cross-covariance between dynamics and measurement · LowLevelParticleFilters Documentation"/><meta property="og:title" content="Cross-covariance between dynamics and measurement · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="Cross-covariance between dynamics and measurement · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../measurement_models/">Multiple measurement models</a></li><li><span class="tocitem">Parameter estimation</span><ul><li><a class="tocitem" href="../parameter_estimation/">Overview</a></li><li><a class="tocitem" href="../param_est_ml/">Maximum-likelihood and MAP</a></li><li><a class="tocitem" href="../param_est_bayesian/">Bayesian inference</a></li><li><a class="tocitem" href="../param_est_joint/">Joint state and parameter estimation</a></li><li><a class="tocitem" href="../param_est_mukf/">MUKF for parameter estimation</a></li><li><a class="tocitem" href="../param_est_optimizer/">Using an optimizer</a></li><li><a class="tocitem" href="../param_est_identifiability/">Identifiability</a></li></ul></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="../beetle_example_imm/">IMM-filter tutorial</a></li><li><a class="tocitem" href="../rbpf_example/">Rao-Blackwellized filter tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="../adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="../neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="../friction_nn_example/">SciML: Adaptive Universal Differential Equation</a></li><li><a class="tocitem" href="../thermal_nn_example/">SciML: Learning a sunshine disturbance model</a></li><li><a class="tocitem" href="../fault_detection/">Fault detection</a></li><li><a class="tocitem" href="../ut/">Unscented transform</a></li><li><a class="tocitem" href="../disturbance_gallery/">Disturbance gallery</a></li><li><a class="tocitem" href="../sample_rate/">Influence of sample rate on performance</a></li><li class="is-active"><a class="tocitem" href>Cross-covariance between dynamics and measurement</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Measurement-models-with-R12-support"><span>Measurement models with R12 support</span></a></li><li><a class="tocitem" href="#Example:-Scalar-system-with-correlated-noise"><span>Example: Scalar system with correlated noise</span></a></li><li><a class="tocitem" href="#Comparing-EKF-with-and-without-R12"><span>Comparing EKF with and without R12</span></a></li><li><a class="tocitem" href="#Comparing-estimation-performance"><span>Comparing estimation performance</span></a></li><li><a class="tocitem" href="#Using-R12-with-UnscentedKalmanFilter"><span>Using R12 with UnscentedKalmanFilter</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Cross-covariance between dynamics and measurement</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cross-covariance between dynamics and measurement</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/cross_covariance.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Cross-covariance-between-process-and-measurement-noise"><a class="docs-heading-anchor" href="#Cross-covariance-between-process-and-measurement-noise">Cross-covariance between process and measurement noise</a><a id="Cross-covariance-between-process-and-measurement-noise-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-covariance-between-process-and-measurement-noise" title="Permalink"></a></h1><p>In standard Kalman filter formulations, the process noise <span>$w$</span> and measurement noise <span>$v$</span> are assumed to be uncorrelated. However, in some applications, these noise sources may be correlated. This tutorial demonstrates how to model and account for cross-covariance between process and measurement noise using the <code>R12</code> parameter.</p><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The standard discrete-time stochastic state-space model is</p><p class="math-container">\[\begin{aligned}
x_{k+1} &amp;= f(x_k, u_k) + w_k \\
y_k &amp;= h(x_k, u_k) + v_k
\end{aligned}\]</p><p>where <span>$w_k \sim N(0, R_1)$</span> is the process noise and <span>$v_k \sim N(0, R_2)$</span> is the measurement noise. The standard assumption is that <span>$E[w_k v_j^T] = 0$</span> for all <span>$k, j$</span>.</p><p>When process and measurement noise are correlated, we have</p><p class="math-container">\[\text{Cov}\begin{pmatrix} w_k \\ v_k \end{pmatrix} = \begin{pmatrix} R_1 &amp; R_{12} \\ R_{12}^T &amp; R_2 \end{pmatrix}\]</p><p>where <span>$R_{12} = E[w_k v_k^T]$</span> is the cross-covariance matrix (following the notation in Simon&#39;s &quot;Optimal State Estimation&quot;, Section 7.1).</p><p>This correlation can arise in several scenarios:</p><ul><li>When process and measurement noise share a common source</li><li>Systems with feedback loops where measurement noise influences the process</li></ul><h2 id="Measurement-models-with-R12-support"><a class="docs-heading-anchor" href="#Measurement-models-with-R12-support">Measurement models with R12 support</a><a id="Measurement-models-with-R12-support-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-models-with-R12-support" title="Permalink"></a></h2><p>The following measurement models support the <code>R12</code> cross-covariance parameter:</p><ul><li><a href="../api/#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}} where IPM"><code>EKFMeasurementModel</code></a>: Linearizing measurement model, used by default in <a href="../api/#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a></li><li><a href="../api/#LowLevelParticleFilters.LinearMeasurementModel"><code>LinearMeasurementModel</code></a>: A linear measurement model</li><li><a href="../api/#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}, NTuple{9, Any}} where IPM"><code>IEKFMeasurementModel</code></a>: Iteratively linearizing measurement model, used by default in <a href="../api/#LowLevelParticleFilters.IteratedExtendedKalmanFilter"><code>IteratedExtendedKalmanFilter</code></a></li></ul><p>The <a href="../api/#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a> does not support <code>R12</code> directly since the unscented transform uses sigma-point propagation rather than analytical covariance formulas. However, you can use an <code>EKFMeasurementModel</code> or <code>LinearMeasurementModel</code> with an <a href="../api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> to get R12 support while still using the unscented transform for the prediction step.</p><h2 id="Example:-Scalar-system-with-correlated-noise"><a class="docs-heading-anchor" href="#Example:-Scalar-system-with-correlated-noise">Example: Scalar system with correlated noise</a><a id="Example:-Scalar-system-with-correlated-noise-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Scalar-system-with-correlated-noise" title="Permalink"></a></h2><p>We demonstrate the effect of R12 using a simple scalar system:</p><p class="math-container">\[\begin{aligned}
x_{k+1} &amp;= 0.8 x_k + w_k \\
y_k &amp;= x_k + v_k \\
\text{Cov}\begin{pmatrix} w_k \\ v_k \end{pmatrix} &amp;= \begin{pmatrix} 1.0 &amp; 0.25 \\ 0.25 &amp; 0.1 \end{pmatrix}
\end{aligned}\]</p><pre><code class="language-julia hljs">using LowLevelParticleFilters, LinearAlgebra, Plots, Statistics, Random
using LowLevelParticleFilters: SimpleMvNormal
using StaticArrays

# System parameters
A   = SA[0.8;;]
B   = SA[0.0;;]
C   = SA[1.0;;]
R1  = SA[1.0;;]   # Process noise covariance
R2  = SA[0.1;;]   # Measurement noise covariance
R12 = SA[0.25;;]  # Cross-covariance

# Initial state distribution
d0 = SimpleMvNormal(SA[0.0], SA[1.0;;])

# Dynamics and measurement functions
dynamics(x, u, p, t)    = A * x
measurement(x, u, p, t) = C * x</code></pre><h2 id="Comparing-EKF-with-and-without-R12"><a class="docs-heading-anchor" href="#Comparing-EKF-with-and-without-R12">Comparing EKF with and without R12</a><a id="Comparing-EKF-with-and-without-R12-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-EKF-with-and-without-R12" title="Permalink"></a></h2><p>We now create two Extended Kalman Filters: one that ignores the cross-covariance (standard approach) and one that accounts for it.</p><pre><code class="language-julia hljs"># EKF without R12 (ignoring correlation)
ekf_no_r12 = ExtendedKalmanFilter(dynamics, measurement, R1, R2, d0; nu=1)

# EKF with R12
ekf_with_r12 = ExtendedKalmanFilter(dynamics, measurement, R1, R2, d0; nu=1, R12=R12)

u = fill([], 100) # No control inputs

x, u, y = simulate(ekf_with_r12, u) # Simulate data using the filter with R12

# Run both filters
sol_no_r12   = forward_trajectory(ekf_no_r12, u, y)
sol_with_r12 = forward_trajectory(ekf_with_r12, u, y)</code></pre><h2 id="Comparing-estimation-performance"><a class="docs-heading-anchor" href="#Comparing-estimation-performance">Comparing estimation performance</a><a id="Comparing-estimation-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-estimation-performance" title="Permalink"></a></h2><p>The filter that accounts for the cross-covariance achieves a lower steady-state estimation variance. This is expected because it correctly uses all available information about the noise correlation structure.</p><p>We can compare the actual estimation errors:</p><pre><code class="language-julia hljs"># Estimation errors
err_no_r12   = x .- sol_no_r12.xt   |&gt; stack
err_with_r12 = x .- sol_with_r12.xt |&gt; stack

println(&quot;RMS error without R12: &quot;, round(sqrt(mean(abs2, err_no_r12)), digits=4))
println(&quot;RMS error with R12: &quot;,  round(sqrt(mean(abs2, err_with_r12)), digits=4))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RMS error without R12: 0.2426
RMS error with R12: 0.1591</code></pre><pre><code class="language-julia hljs">plot(err_no_r12&#39;, label=&quot;Without R12&quot;, xlabel=&quot;Time step&quot;, ylabel=&quot;Estimation error&quot;, alpha=0.7)
plot!(err_with_r12&#39;, label=&quot;With R12&quot;, alpha=0.7)</code></pre><img src="ebde2fec.png" alt="Example block output"/><h2 id="Using-R12-with-UnscentedKalmanFilter"><a class="docs-heading-anchor" href="#Using-R12-with-UnscentedKalmanFilter">Using R12 with UnscentedKalmanFilter</a><a id="Using-R12-with-UnscentedKalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#Using-R12-with-UnscentedKalmanFilter" title="Permalink"></a></h2><p>The <a href="../api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> uses sigma-point propagation and its native <a href="../api/#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a> does not yet support R12. However, you can combine an UKF with an <a href="../api/#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}} where IPM"><code>EKFMeasurementModel</code></a> or <a href="../api/#LowLevelParticleFilters.LinearMeasurementModel"><code>LinearMeasurementModel</code></a> to get R12 support in the correction step:</p><pre><code class="language-julia hljs"># Create an EKFMeasurementModel with R12
mm_ekf_r12 = EKFMeasurementModel{Float64, false}(measurement, R2; nx=1, ny=1, R12=R12)

# Create UKF with this measurement model
ukf_with_r12 = UnscentedKalmanFilter(dynamics, mm_ekf_r12, R1, d0; nu=1, ny=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnscentedKalmanFilter{false,false,false,false}
  Inplace dynamics: false
  Inplace measurement: false
  Augmented dynamics: false
  Augmented measurement: false
  nx: 1
  nu: 1
  ny: 1
  Ts: 1.0
  t: 0
  dynamics: dynamics
  measurement_model: EKFMeasurementModel{false, typeof(Main.measurement), StaticArraysCore.SMatrix{1, 1, Float64, 1}, LowLevelParticleFilters.var&quot;#106#110&quot;{typeof(Main.measurement)}, StaticArraysCore.SMatrix{1, 1, Float64, 1}, Nothing})
  R1: [1.0;;]
  d0: SimpleMvNormal{SVector{1, Float64}, SMatrix{1, 1, Float64, 1}}([0.0], [1.0;;])
  predict_sigma_point_cache: LowLevelParticleFilters.SigmaPointCache{Vector{StaticArraysCore.SVector{1, Float64}}, Vector{StaticArraysCore.SVector{1, Float64}}})
  x: [0.0]
  R: [1.0;;]
  p: NullParameters()
  reject: nothing
  state_mean: weighted_mean
  state_cov: weighted_cov
  cholesky!: cholesky!
  names: SignalNames([&quot;x1&quot;], [&quot;u1&quot;], [&quot;y1&quot;], &quot;UKF&quot;)
  weight_params: TrivialParams()
  R1x: nothing
</code></pre><p>Similarly, you can use a <a href="../api/#LowLevelParticleFilters.LinearMeasurementModel"><code>LinearMeasurementModel</code></a> with R12:</p><pre><code class="language-julia hljs">mm_linear_r12 = LinearMeasurementModel(C, 0, R2; nx=1, ny=1, R12=R12)
ukf_linear_r12 = UnscentedKalmanFilter(dynamics, mm_linear_r12, R1, d0; nu=1, ny=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnscentedKalmanFilter{false,false,false,false}
  Inplace dynamics: false
  Inplace measurement: false
  Augmented dynamics: false
  Augmented measurement: false
  nx: 1
  nu: 1
  ny: 1
  Ts: 1.0
  t: 0
  dynamics: dynamics
  measurement_model: LinearMeasurementModel{StaticArraysCore.SMatrix{1, 1, Float64, 1}, Int64, StaticArraysCore.SMatrix{1, 1, Float64, 1}, StaticArraysCore.SMatrix{1, 1, Float64, 1}, Nothing})
  R1: [1.0;;]
  d0: SimpleMvNormal{SVector{1, Float64}, SMatrix{1, 1, Float64, 1}}([0.0], [1.0;;])
  predict_sigma_point_cache: LowLevelParticleFilters.SigmaPointCache{Vector{StaticArraysCore.SVector{1, Float64}}, Vector{StaticArraysCore.SVector{1, Float64}}})
  x: [0.0]
  R: [1.0;;]
  p: NullParameters()
  reject: nothing
  state_mean: weighted_mean
  state_cov: weighted_cov
  cholesky!: cholesky!
  names: SignalNames([&quot;x1&quot;], [&quot;u1&quot;], [&quot;y1&quot;], &quot;UKF&quot;)
  weight_params: TrivialParams()
  R1x: nothing
</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>When process and measurement noise are correlated:</p><ol><li><p>Ignoring the correlation (setting R12=0) leads to suboptimal estimation with higher estimation-error variance.</p></li><li><p>The <code>R12</code> parameter can be specified in:</p><ul><li><a href="../api/#LowLevelParticleFilters.LinearMeasurementModel"><code>LinearMeasurementModel</code></a></li><li><a href="../api/#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a></li><li><a href="../api/#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}} where IPM"><code>EKFMeasurementModel</code></a></li><li><a href="../api/#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}, NTuple{9, Any}} where IPM"><code>IEKFMeasurementModel</code></a></li></ul></li><li><p>To use R12 with <a href="../api/#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>, provide an <code>EKFMeasurementModel</code>, <code>LinearMeasurementModel</code>, or <code>IEKFMeasurementModel</code> instead of the default <code>UKFMeasurementModel</code>.</p></li><li><p>The mathematical formulas used when R12 is present follow Simon&#39;s &quot;Optimal State Estimation&quot; Section 7.1:</p><ul><li>Innovation covariance: <span>$S = C R C^T + C R_{12} + R_{12}^T C^T + R_2$</span></li><li>Kalman gain: <span>$K = (R C^T + R_{12}) S^{-1}$</span></li><li>Updated covariance: <span>$R^+ = (I - K C) R - K R_{12}^T$</span></li></ul></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sample_rate/">« Influence of sample rate on performance</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 15 January 2026 15:40">Thursday 15 January 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
