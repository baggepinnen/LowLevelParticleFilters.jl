<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LowLevelParticleFilters Documentation</title><meta name="title" content="API · LowLevelParticleFilters Documentation"/><meta property="og:title" content="API · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="API · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../measurement_models/">Multiple measurement models</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="../beetle_example_imm/">IMM-filter tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="../adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="../neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="../fault_detection/">Fault detection</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.AdvancedParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>LowLevelParticleFilters.AuxiliaryParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}"><code>LowLevelParticleFilters.CompositeMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}} where IPM"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>LowLevelParticleFilters.ExtendedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>LowLevelParticleFilters.IMM</code></a></li><li><a href="#LowLevelParticleFilters.KalmanFilter"><code>LowLevelParticleFilters.KalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>LowLevelParticleFilters.KalmanFilteringSolution</code></a></li><li><a href="#LowLevelParticleFilters.LinearMeasurementModel"><code>LowLevelParticleFilters.LinearMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.ParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.ParticleFilteringSolution"><code>LowLevelParticleFilters.ParticleFilteringSolution</code></a></li><li><a href="#LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}"><code>LowLevelParticleFilters.SignalNames</code></a></li><li><a href="#LowLevelParticleFilters.SignalNames"><code>LowLevelParticleFilters.SignalNames</code></a></li><li><a href="#LowLevelParticleFilters.SqKalmanFilter"><code>LowLevelParticleFilters.SqKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}} where {IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>LowLevelParticleFilters.UnscentedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>LowLevelParticleFilters.combine!</code></a></li><li><a href="#LowLevelParticleFilters.commandplot"><code>LowLevelParticleFilters.commandplot</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.covplot"><code>LowLevelParticleFilters.covplot</code></a></li><li><a href="#LowLevelParticleFilters.debugplot"><code>LowLevelParticleFilters.debugplot</code></a></li><li><a href="#LowLevelParticleFilters.densityplot"><code>LowLevelParticleFilters.densityplot</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>LowLevelParticleFilters.interact!</code></a></li><li><a href="#LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Any, Any, Any}"><code>LowLevelParticleFilters.log_likelihood_fun</code></a></li><li><a href="#LowLevelParticleFilters.loglik"><code>LowLevelParticleFilters.loglik</code></a></li><li><a href="#LowLevelParticleFilters.logsumexp!"><code>LowLevelParticleFilters.logsumexp!</code></a></li><li><a href="#LowLevelParticleFilters.mean_trajectory-Tuple{Any, Vector, Vector}"><code>LowLevelParticleFilters.mean_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mean_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.metropolis"><code>LowLevelParticleFilters.metropolis</code></a></li><li><a href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_cov</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_mean</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_trajs</code></a></li><li><a href="#LowLevelParticleFilters.unscentedplot"><code>LowLevelParticleFilters.unscentedplot</code></a></li><li><a href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a></li><li><a href="#LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.update!</code></a></li><li><a href="#LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}"><code>LowLevelParticleFilters.weighted_cov</code></a></li><li><a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any}"><code>LowLevelParticleFilters.weighted_mean</code></a></li><li><a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>LowLevelParticleFilters.weighted_mean</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM}"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}" href="#LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.AdvancedParticleFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvancedParticleFilter(N::Integer, dynamics::Function, measurement::Function, measurement_likelihood, dynamics_density, initial_density; p = NullParameters(), threads = false, kwargs...)</code></pre><p>This type represents a standard particle filter but affords extra flexibility compared to the <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>ParticleFilter</code></a> type, e.g., non-additive noise in the dynamics and measurement functions.</p><p>See the docs for more information: https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/#AdvancedParticleFilter-1</p><p><strong>Arguments:</strong></p><ul><li><code>N</code>: Number of particles</li><li><code>dynamics</code>: A discrete-time dynamics function <code>(x, u, p, t, noise=false) -&gt; x⁺</code>. It&#39;s important that the <code>noise</code> argument defaults to <code>false</code>.</li><li><code>measurement</code>: A measurement function <code>(x, u, p, t, noise=false) -&gt; y</code>. It&#39;s important that the <code>noise</code> argument defaults to <code>false</code>.</li><li><code>measurement_likelihood</code>: A function <code>(x, u, y, p, t)-&gt;logl</code> to evaluate the log-likelihood of a measurement.</li><li><code>dynamics_density</code>: This field is not used by the advanced filter and can be set to <code>nothing</code>.</li><li><code>initial_density</code>: The distribution of the initial state.</li><li><code>threads</code>: use threads to propagate particles in parallel. Only activate this if your dynamics is thread-safe. <code>SeeToDee.SimpleColloc</code> is not thread-safe by default due to the use of internal caches, but <code>SeeToDee.Rk4</code> is.</li></ul><p><strong>Extended help</strong></p><p><strong>Multiple measurement models</strong></p><p>The <code>measurement_likelihood</code> function is used to evaluate the likelihood of a measurement. If you have multiple sensors and want to perform individual <code>correct!</code> steps for each, call <code>correct!(..., g = custom_likelihood_function)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/PFtypes.jl#L172-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple" href="#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>LowLevelParticleFilters.AuxiliaryParticleFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AuxiliaryParticleFilter(args...; kwargs...)</code></pre><p>Takes exactly the same arguments as <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>ParticleFilter</code></a>, or an instance of <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>ParticleFilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/PFtypes.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}" href="#LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}"><code>LowLevelParticleFilters.CompositeMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeMeasurementModel(model1, model2, ...)</code></pre><p>A composite measurement model that combines multiple measurement models. This model acts as all component models concatenated. The tuple returned from <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a> will be</p><ul><li><code>ll</code>: The sum of the log-likelihood of all component models</li><li><code>e</code>: The concatenated innovation vector</li><li><code>S</code>: A vector of the innovation covariance matrices of the component models</li><li><code>Sᵪ</code>: A vector of the Cholesky factorizations of the innovation covariance matrices of the component models</li><li><code>K</code>: A vector of the Kalman gains of the component models</li></ul><p>If all sensors operate on at the same rate, and all measurement models are of the same type, it&#39;s more efficient to use a single measurement model with a vector-valued measurement function.</p><p><strong>Fields:</strong></p><ul><li><code>models</code>: A tuple of measurement models</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/measurement_model.jl#L11-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}} where IPM" href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}} where IPM"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EKFMeasurementModel{IPM}(measurement, R2, ny, Cjac, cache = nothing)</code></pre><p>A measurement model for the Extended Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>IPM</code>: A boolean indicating if the measurement function is inplace</li><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>Cjac</code>: The Jacobian of the measurement function <code>Cjac(x, u, p, t)</code>. If none is provided, ForwardDiff will be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/measurement_model.jl#L249-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}" href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EKFMeasurementModel{T,IPM}(measurement::M, R2; nx, ny, Cjac = nothing)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/measurement_model.jl#L281-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.ExtendedKalmanFilter" href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>LowLevelParticleFilters.ExtendedKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtendedKalmanFilter(kf, dynamics, measurement; Ajac, Cjac)
ExtendedKalmanFilter(dynamics, measurement, R1,R2,d0=MvNormal(Matrix(R1)); nu::Int, p = NullParameters(), α = 1.0, check = true)</code></pre><p>A nonlinear state estimator propagating uncertainty using linearization.</p><p>The constructor to the extended Kalman filter takes dynamics and measurement functions, and either covariance matrices, or a <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. If the former constructor is used, the number of inputs to the system dynamics, <code>nu</code>, must be explicitly provided with a keyword argument.</p><p>By default, the filter will internally linearize the dynamics using ForwardDiff. User provided Jacobian functions can be provided as keyword arguments <code>Ajac</code> and <code>Cjac</code>. These functions should have the signature <code>(x,u,p,t)::AbstractMatrix</code> where <code>x</code> is the state, <code>u</code> is the input, <code>p</code> is the parameters, and <code>t</code> is the time.</p><p>The dynamics and measurement function are on the following form</p><pre><code class="nohighlight hljs">x(t+1) = dynamics(x, u, p, t) + w
y      = measurement(x, u, p, t) + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>See also <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> which is typically more accurate than <code>ExtendedKalmanFilter</code>. See <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> for detailed instructions on how to set up a Kalman filter <code>kf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/ekf.jl#L10-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}" href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>LowLevelParticleFilters.IMM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMM(models, P, μ; check = true, p = NullParameters(), interact = true)</code></pre><p>Interacting Multiple Model (IMM) filter. This filter is a combination of multiple Kalman-type filters, each with its own state and covariance. The IMM filter is a probabilistically weighted average of the states and covariances of the individual filters. The weights are determined by the probability matrix <code>P</code> and the mixing probabilities <code>μ</code>.</p><p>This implmentation allows for any combination of Kalman-type estimators to be used in the internal ensemble of models, and is not limited to linear estimators. This class of models encompasses others, such as </p><ul><li>Jump Markov Linear Systems (JMLS)</li><li>Multiple-model filters (interactivity can be turned off by setting <code>interact=false</code>)</li><li>Multiple Hypothesis Tracking (MHT)</li></ul><div class="admonition is-warning"><header class="admonition-header">Experimental</header><div class="admonition-body"><p>This filter is currently considered experimental and the user interface may change in the future without respecting semantic versioning.</p></div></div><p>In addition to the <a href="#StatsAPI.predict!"><code>predict!</code></a> and <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a> steps, the IMM filter has an <a href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>interact!</code></a> method that updates the states and covariances of the individual filters based on the mixing probabilities. The <a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>combine!</code></a> method combines the states and covariances of the individual filters into a single state and covariance. These four functions are typically called in either of the orders</p><ul><li><code>correct!, combine!, interact!, predict!</code> (as is done in <a href="#LowLevelParticleFilters.update!"><code>update!</code></a>)</li><li><code>interact!, predict!, correct!, combine!</code> (as is done in the reference cited below)</li></ul><p>These two orders are cyclic permutations of each other, and the order used in <a href="#LowLevelParticleFilters.update!"><code>update!</code></a> is chosen to align with the order used in the other filters, where the initial condition is corrected using the first measurement, i.e., we assume the first measurement updates <span>$x(0|-1)$</span> to <span>$x(0|0)$</span>.</p><p>The initial (combined) state and covariance of the IMM filter is made up of the weighted average of the states and covariances of the individual filters. The weights are the initial mixing probabilities <code>μ</code>.</p><p>Ref: &quot;Interacting multiple model methods in target tracking: a survey&quot;, E. Mazor; A. Averbuch; Y. Bar-Shalom; J. Dayan</p><p><strong>Arguments:</strong></p><ul><li><code>models</code>: An array of Kalman-type filters, such as <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>, <a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a>, <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>, etc. The state of each model must have the same meaning, such that forming a weighted average makes sense.</li><li><code>P</code>: The mode-transition probability matrix. <code>P[i,j]</code> is the probability of transitioning from mode <code>i</code> to mode <code>j</code> (each row must sum to one).</li><li><code>μ</code>: The initial mixing probabilities. <code>μ[i]</code> is the probability of being in mode <code>i</code> at the initial contidion (must sum to one).</li><li><code>check</code>: If <code>true</code>, check that the inputs are valid. If <code>false</code>, skip the checks.</li><li><code>p</code>: Parameters for the filter. NOTE: this <code>p</code> is shared among all internal filters. The internal <code>p</code> of each filter will be overridden by this one.</li><li><code>interact</code>: If <code>true</code>, the filter will run the interaction as part of <a href="#LowLevelParticleFilters.update!"><code>update!</code></a> and <a href="#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>. If <code>false</code>, the filter will not run the interaction step. This choice can be overridden by passing the keyword argument <code>interact</code> to the respective functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/imm.jl#L18-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.KalmanFilter" href="#LowLevelParticleFilters.KalmanFilter"><code>LowLevelParticleFilters.KalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanFilter(A,B,C,D,R1,R2,d0=MvNormal(R1); p = NullParameters(), α=1, check=true)</code></pre><p>The matrices <code>A,B,C,D</code> define the dynamics</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w
y  = Cx + Du + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices can be time varying such that, e.g., <code>A[:, :, t]</code> contains the <span>$A$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Afun(x, u, p, t) -&gt; A</code></pre><p>For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p>α is an optional &quot;forgetting factor&quot;, if this is set to a value &gt; 1, such as 1.01-1.2, the filter will, in addition to the covariance inflation due to <span>$R_1$</span>, exhibit &quot;exponential forgetting&quot; similar to a <a href="https://en.wikipedia.org/wiki/Recursive_least_squares_filter">Recursive Least-Squares (RLS) estimator</a>. It is thus possible to get a RLS-like algorithm by setting <span>$R_1=0, R_2 = 1/α$</span> and <span>$α &gt; 1$</span> (<span>$α$</span> is the inverse of the traditional RLS parameter <span>$α = 1/λ$</span>). The exact form of the covariance update is</p><p class="math-container">\[R(t+1|t) = α AR(t)A^T + R_1\]</p><p>If <code>check = true (default)</code> the function will check that the eigenvalues of <code>A</code> are less than 2 in absolute value. Large eigenvalues may be an indication that the system matrices are representing a continuous-time system and the user has forgotten to discretize it. Turn off this check by setting <code>check = false</code>.</p><p><strong>Tutorials on Kalman filtering</strong></p><p>The tutorial <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">&quot;How to tune a Kalman filter&quot;</a> details how to figure out appropriate covariance matrices for the Kalman filter, as well as how to add disturbance models to the system model. See also the <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/adaptive_kalmanfilter/">tutorial in the documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/kalman.jl#L41-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.KalmanFilteringSolution" href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>LowLevelParticleFilters.KalmanFilteringSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanFilteringSolution{Tx,Txt,TR,TRt,Tll} &lt;: AbstractFilteringSolution</code></pre><p><strong>Fields</strong></p><ul><li><code>x</code>: predictions <span>$x(t+1|t)$</span> (plotted if <code>plotx=true</code>)</li><li><code>xt</code>: filtered estimates <span>$x(t|t)$</span> (plotted if <code>plotxt=true</code>)</li><li><code>R</code>: predicted covariance matrices <span>$R(t+1|t)$</span> (plotted if <code>plotR=true</code>)</li><li><code>Rt</code>: filter covariances <span>$R(t|t)$</span> (plotted if <code>plotRt=true</code>)</li><li><code>ll</code>: loglikelihood</li><li><code>e</code>: prediction errors <span>$e(t|t-1) = y - ŷ(t|t-1)$</span> (plotted if <code>plote=true</code>)</li></ul><p><strong>Plot</strong></p><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol, plotx=true, plotxt=true, plotR=true, plotRt=true, plote=true, plotu=true, ploty=true, plotyh=true, plotyht=true, name=&quot;&quot;)</code></pre><p>where</p><ul><li><code>plotx</code>: Plot the predictions <code>x(t|t-1)</code></li><li><code>plotxt</code>: Plot the filtered estimates <code>x(t|t)</code></li><li><code>plotR</code>: Plot the predicted covariances <code>R(t|t-1)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li><code>plotRt</code>: Plot the filter covariances <code>R(t|t)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li><code>plote</code>: Plot the prediction errors <code>e(t|t-1) = y - ŷ(t|t-1)</code></li><li><code>plotu</code>: Plot the input</li><li><code>ploty</code>: Plot the measurements</li><li><code>plotyh</code>: Plot the predicted measurements <code>ŷ(t|t-1)</code></li><li><code>plotyht</code>: Plot the filtered measurements <code>ŷ(t|t)</code></li><li><code>name</code>: a string that is prepended to the labels of the plots, which is useful when plotting multiple solutions in the same plot.</li></ul><p>To modify the signal names used in legend entries, construct an instance of <a href="#LowLevelParticleFilters.SignalNames"><code>SignalNames</code></a> and pass this to the filter (or directly to the plot command) using the <code>names</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/solutions.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.LinearMeasurementModel" href="#LowLevelParticleFilters.LinearMeasurementModel"><code>LowLevelParticleFilters.LinearMeasurementModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearMeasurementModel{CT, DT, RT, CAT}</code></pre><p>A linear measurement model <span>$y = C*x + D*u + e$</span>.</p><p><strong>Fields:</strong></p><ul><li><code>C</code> </li><li><code>D</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/measurement_model.jl#L325-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}" href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.ParticleFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleFilter(N::Integer, dynamics, measurement, dynamics_density, measurement_density, initial_density; threads = false, p = NullParameters(), kwargs...)</code></pre><p>See the docs for more information: https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/#Particle-filter-1</p><p><strong>Arguments:</strong></p><ul><li><code>N</code>: Number of particles</li><li><code>dynamics</code>: A discrete-time dynamics function <code>(x, u, p, t) -&gt; x⁺</code></li><li><code>measurement</code>: A measurement function <code>(x, u, p, t) -&gt; y</code></li><li><code>dynamics_density</code>: A probability-density function for additive noise in the dynamics. Use <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> for non-additive noise.</li><li><code>measurement_density</code>: A probability-density function for additive measurement noise. Use <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> for non-additive noise.</li><li><code>initial_density</code>: Distribution of the initial state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/PFtypes.jl#L49-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.ParticleFilteringSolution" href="#LowLevelParticleFilters.ParticleFilteringSolution"><code>LowLevelParticleFilters.ParticleFilteringSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleFilteringSolution{F, Tu, Ty, Tx, Tw, Twe, Tll} &lt;: AbstractFilteringSolution</code></pre><p><strong>Fields:</strong></p><ul><li><code>f</code>: The filter used to produce the solution.</li><li><code>u</code>: Input</li><li><code>y</code>: Output / measurements</li><li><code>x</code>: Particles, the size of this array is <code>(N,T)</code>, where <code>N</code> is the number of particles and <code>T</code> is the number of time steps. Each element represents a weighted state hypothesis with weight given by <code>we</code>.</li><li><code>w</code>: Weights (log space). These are used for internal computations.</li><li><code>we</code>: Weights (exponentiated / original space). These are the ones to use to compute weighted means etc., they sum to one for each time step.</li><li><code>ll</code>: Log likelihood</li></ul><p><strong>Plot</strong></p><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol; nbinsy=30, xreal=nothing, dim=nothing, ploty=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/solutions.jl#L145-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.SignalNames" href="#LowLevelParticleFilters.SignalNames"><code>LowLevelParticleFilters.SignalNames</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SignalNames(; x, u, y, name)</code></pre><p>A structure representing the names of the signals in a system.</p><ul><li><code>x::Vector{String}</code>: Names of the state variables</li><li><code>u::Vector{String}</code>: Names of the input variables</li><li><code>y::Vector{String}</code>: Names of the output variables</li><li><code>name::String</code>: Name of the system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/signalnames.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}" href="#LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}"><code>LowLevelParticleFilters.SignalNames</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SignalNames(sn::SignalNames, name)</code></pre><p>Copy the <code>SignalNames</code> structure and change the name of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/signalnames.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.SqKalmanFilter" href="#LowLevelParticleFilters.SqKalmanFilter"><code>LowLevelParticleFilters.SqKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SqKalmanFilter(A,B,C,D,R1,R2,d0=MvNormal(R1); p = NullParameters(), α=1)</code></pre><p>A standard Kalman filter on square-root form. This filter may have better numerical performance when the covariance matrices are ill-conditioned.</p><p>The matrices <code>A,B,C,D</code> define the dynamics</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w
y  = Cx + Du + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices can be time varying such that, e.g., <code>A[:, :, t]</code> contains the <span>$A$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Afun(x, u, p, t) -&gt; A</code></pre><p>The internal fields storing covariance matrices are for this filter storing the upper-triangular Cholesky factor.</p><p>α is an optional &quot;forgetting factor&quot;, if this is set to a value &gt; 1, such as 1.01-1.2, the filter will, in addition to the covariance inflation due to <span>$R_1$</span>, exhibit &quot;exponential forgetting&quot; similar to a <a href="https://en.wikipedia.org/wiki/Recursive_least_squares_filter">Recursive Least-Squares (RLS) estimator</a>. It is thus possible to get a RLS-like algorithm by setting <span>$R_1=0, R_2 = 1/α$</span> and <span>$α &gt; 1$</span> (<span>$α$</span> is the inverse of the traditional RLS parameter <span>$α = 1/λ$</span>). The form of the covariance update is</p><p class="math-container">\[R(t+1|t) = α AR(t)A^T + R_1\]</p><p>Ref: &quot;A Square-Root Kalman Filter Using Only QR Decompositions&quot;, Kevin Tracy https://arxiv.org/abs/2208.06452</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/sq_kalman.jl#L19-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}} where {IPM, AUGM}" href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}} where {IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UKFMeasurementModel{inplace_measurement,augmented_measurement}(measurement, R2, ny, ne, innovation, mean, cov, cross_cov, cache = nothing)</code></pre><p>A measurement model for the Unscented Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>ne</code>: If <code>augmented_measurement</code> is <code>true</code>, the number of measurement noise variables</li><li><code>innovation(y::AbstractVector, yh::AbstractVector)</code> where the arguments represent (measured output, predicted output)</li><li><code>mean(ys::AbstractVector{&lt;:AbstractVector})</code>: computes the mean of the vector of vectors of output sigma points.</li><li><code>cov(ys::AbstractVector{&lt;:AbstractVector}, y::AbstractVector)</code>: computes the covariance matrix of the output sigma points.</li><li><code>cross_cov(xs::AbstractVector{&lt;:AbstractVector}, x::AbstractVector, ys::AbstractVector{&lt;:AbstractVector}, y::AbstractVector)</code> where the arguments represents (state sigma points, mean state, output sigma points, mean output). The function should return the <strong>cross-covariance</strong> matrix between the state and output sigma points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/measurement_model.jl#L90-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}" href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UKFMeasurementModel{T,IPM,AUGM}(measurement, R2; nx, ny, ne = nothing, innovation = -, mean = safe_mean, cov = safe_cov, cross_cov = cross_cov, static = nothing)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li><li><code>AUGM</code> is a boolean indicating if the measurement model is augmented</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/measurement_model.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}" href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>LowLevelParticleFilters.UnscentedKalmanFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnscentedKalmanFilter(dynamics, measurement, R1, R2, d0=MvNormal(Matrix(R1)); p = NullParameters(), ny, nu)
UnscentedKalmanFilter{IPD,IPM,AUGD,AUGM}(dynamics, measurement_model::AbstractMeasurementModel, R1, d0=SimpleMvNormal(R1); p=NullParameters(), nu)</code></pre><p>A nonlinear state estimator propagating uncertainty using the unscented transform.</p><p>The dynamics and measurement function are on <em>either</em> of the following forms</p><pre><code class="nohighlight hljs">x&#39; = dynamics(x, u, p, t) + w
y  = measurement(x, u, p, t) + e</code></pre><pre><code class="nohighlight hljs">x&#39; = dynamics(x, u, p, t, w)
y  = measurement(x, u, p, t, e)</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code>. The former (default) assums that the noise is additive and added <em>after</em> the dynamics and measurement updates, while the latter assumes that the dynamics functions take an additional argument corresponding to the noise term. The latter form (sometimes refered to as the &quot;augmented&quot; form) is useful when the noise is multiplicative or when the noise is added <em>before</em> the dynamics and measurement updates. See &quot;Augmented UKF&quot; below for more details on how to use this form.</p><p>The matrices <code>R1, R2</code> can be time varying such that, e.g., <code>R1[:, :, t]</code> contains the <span>$R_1$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Rfun(x, u, p, t) -&gt; R</code></pre><p>For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p><code>ny, nu</code> indicate the number of outputs and inputs.</p><p><strong>Custom type of <code>u</code></strong></p><p>The input <code>u</code> may be of any type, e.g., a named tuple or a custom struct. The <code>u</code> provided in the input data is passed directly to the dynamics and measurement functions, so as long as the type is compatible with the dynamics it will work out. The one exception where this will not work is when calling <code>simulate</code>, which assumes that <code>u</code> is an array.</p><p><strong>Augmented UKF</strong></p><p>If the noise is not additive, one may use the augmented form of the UKF. In this form, the dynamics functions take additional input arguments that correspond to the noise terms. To enable this form, the typed constructor</p><pre><code class="nohighlight hljs">UnscentedKalmanFilter{inplace_dynamics,inplace_measurement,augmented_dynamics,augmented_measurement}(...)</code></pre><p>is used, where the Boolean type parameters have the following meaning</p><ul><li><code>inplace_dynamics</code>: If <code>true</code>, the dynamics function operates in-place, i.e., it modifies the first argument in <code>dynamics(dx, x, u, p, t)</code>. Default is <code>false</code>.</li><li><code>inplace_measurement</code>: If <code>true</code>, the measurement function operates in-place, i.e., it modifies the first argument in <code>measurement(y, x, u, p, t)</code>. Default is <code>false</code>.</li><li><code>augmented_dynamics</code>: If <code>true</code> the dynamics function is augmented with an additional noise input <code>w</code>, i.e., <code>dynamics(x, u, p, t, w)</code>. Default is <code>false</code>.</li><li><code>augmented_measurement</code>: If <code>true</code> the measurement function is agumented with an additional noise input <code>e</code>, i.e., <code>measurement(x, u, p, t, e)</code>. Default is <code>false</code>. (If the measurement noise has fewer degrees of freedom than the number of measurements, you may failure in Cholesky factorizations, see &quot;Custom Cholesky factorization&quot; below).</li></ul><p>Use of augmented dynamics incurs extra computational cost. The number of sigma points used is <code>2L+1</code> where <code>L</code> is the length of the augmented state vector. Without augmentation, <code>L = nx</code>, with augmentation <code>L = nx + nw</code> and <code>L = nx + ne</code> for dynamics and measurement, respectively.</p><p><strong>Sigma-point rejection</strong></p><p>For problems with challenging dynamics, a mechanism for rejection of sigma points after the dynamics update is provided. A function <code>reject(x) -&gt; Bool</code> can be provided through the keyword argument <code>reject</code> that returns <code>true</code> if a sigma point for <span>$x(t+1)$</span> should be rejected, e.g., if an instability or non-finite number is detected. A rejected point is replaced by the propagated mean point (the mean point cannot be rejected). This function may be provided either to the constructor of the UKF or passed to the <a href="#StatsAPI.predict!"><code>predict!</code></a> function.</p><p><strong>Custom measurement models</strong></p><p>By default, standard arithmetic mean and <code>e(y, yh) = y - yh</code> are used as mean and innovation functions.</p><p>By passing and explicitly created <a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a>, one may provide custom functions that compute the mean, the covariance and the innovation. This is useful in situations where the state or a measurement lives on a manifold. One may further override the mean and covariance functions for the state sigma points by passing the keyword arguments <code>state_mean</code> and <code>state_cov</code> to the constructor.</p><ul><li><code>state_mean(xs::AbstractVector{&lt;:AbstractVector})</code> computes the mean of the vector of vectors of state sigma points.</li><li><code>state_cov(xs::AbstractVector{&lt;:AbstractVector}, m = mean(xs))</code> where the first argument represent state sigma points and the second argument, which must be optional, represents the mean of those points. The function should return the covariance matrix of the state sigma points.</li></ul><p>See <a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a> for more details on how to set up a custom measurement model. Pass the custom measurement model as the second argument to the UKF constructor.</p><p><strong>Custom Cholesky factorization</strong></p><p>The UnscentedKalmanFilter supports providing a custom function to compute the Cholesky factorization of the covariance matrices for use in sigma-point generation.</p><p>If either of the following conditions are met, you may experience failure in internal Cholesky factorizations:</p><ul><li>The dynamics noise or measurement noise covariance matrices (<span>$R_1, R_2$</span>) are singular</li><li>The measurement is augmented and the measurement noise has fewer degrees of freedom than the number of measurements</li><li>(Under specific technical conditions) The dynamics is augmented and the dynamics noise has fewer degrees of freedom than the number of state variables. The technical conditions are easiest to understand in the linear-systems case, where it corresponds to the Riccati equation associated with the Kalman gain not having a solution. This may happen when the pair <span>$(A, R1)$</span> has uncontrollable modes on the unit circle, for example, when there are integrating modes that are not affected through the noise.</li></ul><p>The error message may look like</p><pre><code class="nohighlight hljs">ERROR: PosDefException: matrix is not positive definite; Factorization failed.</code></pre><p>In such situations, it is advicable to reconsider the noise model and covariance matrices, alternatively, you may provide a custom Cholesky factorization function to the UKF constructor through the keyword argument <code>cholesky!</code>. The function should have the signature <code>cholesky!(A::AbstractMatrix)::Cholesky</code>. A useful alternative factorizaiton when covariance matrices are expected to be singular is <code>cholesky! = R-&gt;cholesky!(Positive, Matrix(R))</code> where the &quot;positive&quot; Cholesky factorization is provided by the package PositiveFactorizations.jl, which must be manually installed and loaded by the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/ukf.jl#L91-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.combine!-Tuple{IMM}" href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>LowLevelParticleFilters.combine!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine!(imm::IMM)</code></pre><p>Combine the models of the IMM filter into a single state <code>imm.x</code> and covariance <code>imm.R</code>. This is done by taking a weighted average of the states and covariances of the individual models, where the weights are the mixing probabilities <code>μ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/imm.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.commandplot" href="#LowLevelParticleFilters.commandplot"><code>LowLevelParticleFilters.commandplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">commandplot(pf, u, y, p=parameters(pf); kwargs...)</code></pre><p>Produce a helpful plot. For customization options (<code>kwargs...</code>), see <code>?pplot</code>. After each time step, a command from the user is requested.</p><ul><li>q: quit</li><li>s n: step <code>n</code> steps</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/LowLevelParticleFilters.jl#L82-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correct!(kf::SqKalmanFilter, u, y, p = parameters(kf), t::Real = index(kf); R2 = get_mat(kf.R2, kf.x, u, p, t))</code></pre><p>For the square-root Kalman filter, a custom provided <code>R2</code> must be the upper triangular Cholesky factor of the covariance matrix of the measurement noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/sq_kalman.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(; ll, e, S, Sᵪ, K) = correct!(kf::AbstractKalmanFilter, u, y, p = parameters(kf), t::Integer = index(kf), R2)</code></pre><p>The correct step for a Kalman filter returns not only the log likelihood <code>ll</code> and the prediction error <code>e</code>, but also the covariance of the output <code>S</code>, its Cholesky factor <code>Sᵪ</code> and the Kalman gain <code>K</code>.</p><p>If <code>R2</code> stored in <code>kf</code> is a function <code>R2(x, u, p, t)</code>, this function is evaluated at the state <em>before</em> the correction is performed. The measurement noise covariance matrix <code>R2</code> stored in the filter object can optionally be overridden by passing the argument <code>R2</code>, in this case <code>R2</code> must be a matrix.</p><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L81-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll, e = correct!(pf, u, y, p = parameters(f), t = index(f))</code></pre><p>Update state/weights based on measurement <code>y</code>,  returns log-likelihood and prediction error (the error is always 0 for particle filters).</p><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a>. For <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a>, this can be realized by passing a custom <code>measurement_likelihood</code> function as the keyword argument <code>g</code> to <code>correct!</code>, or by calling the lower-level function <code>measurement_equation!</code> with a custom <code>measurement_likelihood</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L135-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}" href="#LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll, lls, rest = correct!(imm::IMM, u, y, args; kwargs)</code></pre><p>The correct step of the IMM filter corrects each model with the measurements <code>y</code> and control input <code>u</code>. The mixing probabilities <code>imm.μ</code> are updated based on the likelihood of each model given the measurements and the transition probability matrix <code>P</code>.</p><p>The returned tuple consists of the sum of the log-likelihood of all models, the vector of individual log-likelihoods and an array of the rest of the return values from the correct step of each model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/imm.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}" href="#LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correct!(ukf::UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, u, y, p = parameters(ukf), t::Real = index(ukf) * ukf.Ts; R2 = get_mat(ukf.R2, ukf.x, u, p, t), mean, cross_cov, innovation)</code></pre><p>The correction step for an <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> allows the user to override, <code>R2</code>, <code>mean</code>, <code>cross_cov</code>, <code>innovation</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>u</code>: The input</li><li><code>y</code>: The measurement</li><li><code>p</code>: The parameters</li><li><code>t</code>: The current time</li><li><code>R2</code>: The measurement noise covariance matrix, or a function that returns the covariance matrix <code>(x,u,p,t)-&gt;R2</code>.</li><li><code>mean</code>: The function that computes the mean of the output sigma points.</li><li><code>cross_cov</code>: The function that computes the cross-covariance of the state and output sigma points.</li><li><code>innovation</code>: The function that computes the innovation between the measured output and the predicted output.</li></ul><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/ukf.jl#L355-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.covplot" href="#LowLevelParticleFilters.covplot"><code>LowLevelParticleFilters.covplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">covplot(μ, Σ; n_std = 2, dims=1:2)
covplot(kf; n_std = 2, dims=1:2)</code></pre><p>Plot the covariance ellipse of the state <code>μ</code> and covariance <code>Σ</code>. <code>dims</code> indicate the two dimensions to plot, and defaults to the first two dimensions.</p><p>If a Kalman-type filter is passed, the state and covariance are extracted from the filter.</p><p>See also <code>unscentedplot</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/LowLevelParticleFilters.jl#L126-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.debugplot" href="#LowLevelParticleFilters.debugplot"><code>LowLevelParticleFilters.debugplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">debugplot(pf, u, y, p=parameters(pf); runall=false, kwargs...)</code></pre><p>Produce a helpful plot. For customization options (<code>kwargs...</code>), see <code>?pplot</code>.</p><ul><li><code>runall=false:</code> if true, runs all time steps befor displaying (faster), if false, displays the plot after each time step.</li></ul><p>The generated plot becomes quite heavy. Initially, try limiting your input to 100 time steps to verify that it doesn&#39;t crash.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/LowLevelParticleFilters.jl#L95-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.densityplot" href="#LowLevelParticleFilters.densityplot"><code>LowLevelParticleFilters.densityplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">densityplot(x,[w])</code></pre><p>Plot (weighted) particles densities</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/plotting.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.forward_trajectory" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sol = forward_trajectory(pf, u::AbstractVector, y::AbstractVector, p=parameters(pf))</code></pre><p>Run the particle filter for a sequence of inputs and measurements (offline / batch filtering). Return a solution with <code>x,w,we,ll = particles, weights, expweights and loglikelihood</code></p><p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, you may transform the output particles to <code>Matrix{MonteCarloMeasurements.Particles}</code> using <code>Particles(x,we)</code>. Internally, the particles are then resampled such that they all have unit weight. This is conventient for making use of the <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/#Plotting-1">plotting facilities of MonteCarloMeasurements.jl</a>.</p><p><code>sol</code> can be plotted</p><pre><code class="nohighlight hljs">plot(sol::ParticleFilteringSolution; nbinsy=30, xreal=nothing, dim=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L259-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.forward_trajectory" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">forward_trajectory(imm::IMM, u, y, p = parameters(imm); interact = true)</code></pre><p>When performing batch filtering using an <a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter, one may</p><ul><li>Override the <code>interact</code> parameter of the filter</li><li>Access the mode probabilities along the trajectory as the <code>sol.extra</code> field. This is a matrix of size <code>(n_modes, T)</code> where <code>T</code> is the length of the trajectory (length of <code>u</code> and <code>y</code>).</li></ul><p>The returned solution object is of type <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> and has the following fields:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/imm.jl#L257-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.forward_trajectory" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sol = forward_trajectory(kf::AbstractKalmanFilter, u::Vector, y::Vector, p=parameters(kf))</code></pre><p>Run a Kalman filter forward to perform (offline / batch) filtering along an entire trajectory <code>u, y</code>.</p><p>Returns a KalmanFilteringSolution: with the following</p><ul><li><code>x</code>: predictions <span>$x(t|t-1)$</span></li><li><code>xt</code>: filtered estimates <span>$x(t|t)$</span></li><li><code>R</code>: predicted covariance matrices <span>$R(t|t-1)$</span></li><li><code>Rt</code>: filter covariances <span>$R(t|t)$</span></li><li><code>ll</code>: loglik</li></ul><p><code>sol</code> can be plotted</p><pre><code class="nohighlight hljs">plot(sol::KalmanFilteringSolution; plotx = true, plotxt=true, plotu=true, ploty=true)</code></pre><p>See <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> for more details.</p><p><strong>Extended help</strong></p><p><strong>Very large systems</strong></p><p>If your system is very large, i.e., the dimension of the state is very large, and the arrays <code>u,y</code> are long, this function may use a lot of memory to store all covariance matrices <code>R, Rt</code>. If you do not need all the information retained by this function, you may opt to call one of the functions</p><ul><li><a href="#LowLevelParticleFilters.loglik"><code>loglik</code></a></li><li><a href="@ref"><code>LowLevelParticleFilters.sse</code></a></li><li><a href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a></li></ul><p>That store significantly less information. The amount of computation performed by all of these functions is identical, the only difference lies in what is stored and returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L209-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.interact!-Tuple{IMM}" href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>LowLevelParticleFilters.interact!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact!(imm::IMM)</code></pre><p>The interaction step of the IMM filter updates the state and covariance of each internal model based on the mixing probabilities <code>imm.μ</code> and the transition probability matrix <code>imm.P</code>.</p><p>Models with small mixing probabilities will have their states and covariances updated more towards the states and covariances of models with higher mixing probabilities, and vice versa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/imm.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Any, Any, Any}" href="#LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Any, Any, Any}"><code>LowLevelParticleFilters.log_likelihood_fun</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll(θ) = log_likelihood_fun(filter_from_parameters(θ::Vector)::Function, priors::Vector{Distribution}, u, y, p)</code></pre><p>returns function θ -&gt; p(y|θ)p(θ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.loglik" href="#LowLevelParticleFilters.loglik"><code>LowLevelParticleFilters.loglik</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll = loglik(filter, u, y, p=parameters(filter))</code></pre><p>Calculate log-likelihood for entire sequences <code>u,y</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.logsumexp!" href="#LowLevelParticleFilters.logsumexp!"><code>LowLevelParticleFilters.logsumexp!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll = logsumexp!(w, we [, maxw])</code></pre><p>Normalizes the weight vector <code>w</code> and returns the weighted log-likelihood</p><p>https://arxiv.org/pdf/1412.8695.pdf eq 3.8 for p(y) https://discourse.julialang.org/t/fast-logsumexp/22827/7?u=baggepinnen for stable logsumexp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/utils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.mean_trajectory-Tuple{Any, Vector, Vector}" href="#LowLevelParticleFilters.mean_trajectory-Tuple{Any, Vector, Vector}"><code>LowLevelParticleFilters.mean_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x,ll = mean_trajectory(pf, u::Vector{Vector}, y::Vector{Vector}, p=parameters(pf))</code></pre><p>This method resets the particle filter to the initial state distribution upon start</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}" href="#LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mean_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_trajectory(sol::ParticleFilteringSolution)
mean_trajectory(x::AbstractMatrix, we::AbstractMatrix)</code></pre><p>Compute the weighted mean along the trajectory of a particle-filter solution. Returns a matrix of size <code>T × nx</code>. If <code>x</code> and <code>we</code> are supplied, the weights are expected to be in the original space (not log space).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L320-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.metropolis" href="#LowLevelParticleFilters.metropolis"><code>LowLevelParticleFilters.metropolis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metropolis(ll::Function(θ), R::Int, θ₀::Vector, draw::Function(θ) = naive_sampler(θ₀))</code></pre><p>Performs MCMC sampling using the marginal Metropolis (-Hastings) algorithm <code>draw = θ -&gt; θ&#39;</code> samples a new parameter vector given an old parameter vector. The distribution must be symmetric, e.g., a Gaussian. <code>R</code> is the number of iterations. See <code>log_likelihood_fun</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">filter_from_parameters(θ) = ParticleFilter(N, dynamics, measurement, MvNormal(n,exp(θ[1])), MvNormal(p,exp(θ[2])), d0)
priors = [Normal(0,0.1),Normal(0,0.1)]
ll     = log_likelihood_fun(filter_from_parameters,priors,u,y,1)
θ₀ = log.([1.,1.]) # Initial point
draw = θ -&gt; θ .+ rand(MvNormal(0.1ones(2))) # Function that proposes new parameters (has to be symmetric)
burnin = 200 # If using threaded call, provide number of burnin iterations
# @time theta, lls = metropolis(ll, 2000, θ₀, draw) # Run single threaded
# thetam = reduce(hcat, theta)&#39;
@time thetalls = LowLevelParticleFilters.metropolis_threaded(burnin, ll, 5000, θ₀, draw) # run on all threads, will provide (2000-burnin)*nthreads() samples
histogram(exp.(thetalls[:,1:2]), layout=3)
plot!(thetalls[:,3], subplot=3) # if threaded call, log likelihoods are in the last column</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L158-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}" href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(kf::AbstractKalmanFilter; x0)</code></pre><p>Reset the initial distribution of the state. Optionally, a new mean vector <code>x0</code> can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/kalman.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}" href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Reset the filter to initial state and covariance/distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}" href="#LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(kf::SqKalmanFilter; x0)</code></pre><p>Reset the initial distribution of the state. Optionally, a new mean vector <code>x0</code> can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/sq_kalman.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.simulate" href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x,u,y = simulate(f::AbstractFilter, T::Int, du::Distribution, p=parameters(f), [N]; dynamics_noise=true, measurement_noise=true)
x,u,y = simulate(f::AbstractFilter, u, p=parameters(f); dynamics_noise=true, measurement_noise=true)</code></pre><p>Simulate dynamical system forward in time <code>T</code> steps, or for the duration of <code>u</code>. Returns state sequence, inputs and measurements.</p><ul><li><code>u</code> is an input-signal trajectory, alternatively, <code>du</code> is a distribution of random inputs.</li></ul><p>A simulation can be considered a draw from the prior distribution over the evolution of the system implied by the selected noise models. Such a simulation is useful in order to evaluate whether or not the noise models are reasonable.</p><p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, the argument <code>N::Int</code> can be supplied, in which case <code>N</code> simulations are done and the result is returned in the form of <code>Vector{MonteCarloMeasurements.Particles}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L354-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smooth" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xb,ll = smooth(pf, M, u, y, p=parameters(pf))
xb,ll = smooth(pf, xf, wf, wef, ll, M, u, y, p=parameters(pf))</code></pre><p>Perform particle smoothing using forward-filtering, backward simulation. Return smoothed particles and loglikelihood. See also <a href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>smoothed_trajs</code></a>, <a href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>smoothed_mean</code></a>, <a href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>smoothed_cov</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smooth" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xT,RT,ll = smooth(sol, kf)
xT,RT,ll = smooth(kf::KalmanFilter, u::Vector, y::Vector, p=parameters(kf))
xT,RT,ll = smooth(kf::ExtendedKalmanFilter, u::Vector, y::Vector, p=parameters(kf))</code></pre><p>Returns smoothed estimates of state <code>x</code> and covariance <code>R</code> given all input output data <code>u,y</code> or an existing solution <code>sol</code> obtained from <a href="#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smoothed_cov-Tuple{Any}" href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_cov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothed_cov(xb)</code></pre><p>Helper function to calculate the covariance of smoothed particle trajectories</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smoothed_mean-Tuple{Any}" href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothed_mean(xb)</code></pre><p>Helper function to calculate the mean of smoothed particle trajectories</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smoothed_trajs-Tuple{Any}" href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_trajs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothed_trajs(xb)</code></pre><p>Helper function to get particle trajectories as a 3-dimensions array (N,M,T) instead of matrix of vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.unscentedplot" href="#LowLevelParticleFilters.unscentedplot"><code>LowLevelParticleFilters.unscentedplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unscentedplot(ukf;          n_std = 2, N = 100, dims=1:2)
unscentedplot(sigmapoints;  n_std = 2, N = 100, dims=1:2)</code></pre><p>Plot the sigma points and their corresponding covariance ellipse. <code>dims</code> indicate the two dimensions to plot, and defaults to the first two dimensions.</p><p>If an UKF is passed, the sigma points after the last dynamics update are extracted from the filter. To plot the sigma points of the output, pass those in manually, they are available as <code>ukf.measurement_model.cache.x0</code> and <code>ukf.measurement_model.cache.x1</code>, denoting the input and output points of the measurement model.</p><p>Note: The covariance of the sigma points does not in general equal the predicted covariance of the state, since the state covariance is updated as <code>cov(sigmapoints) + R1</code>. Only when <code>AUGD = true</code> (augmented dynamics), the covariance of the state is given by the first <code>nx</code> sigmapoints.</p><p>See also <code>covplot</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/LowLevelParticleFilters.jl#L108-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.update!" href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll, e = update!(f::AbstractFilter, u, y, p = parameters(f), t = index(f))</code></pre><p>Perform one step of <code>predict!</code> and <code>correct!</code>, returns log-likelihood and prediction error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}" href="#LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(imm::IMM, u, y, p, t; correct_kwargs = (;), predict_kwargs = (;), interact = true)</code></pre><p>The combined udpate for an <a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter performs the following steps:</p><ol><li>Correct each model with the measurements <code>y</code> and control input <code>u</code>.</li><li>Combine the models into a single state and covariance.</li><li>Interact the models to update their respective state and covariance.</li><li>Predict each model to the next time step.</li></ol><p>This differs slightly from the udpate step of other filters, where at the end of an update the state of the filter is the one-step ahead <em>predicted</em> value, whereas here each individual filter has a predicted state, but the <a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>combine!</code></a> step of the IMM filter hasn&#39;t been performed on the predictions yet. The state of the IMM filter is thus <span>$x(t|t)$</span> and not <span>$x(t+1|t)$</span> like it is for other filters, and each filter internal to the IMM.</p><p><strong>Arguments:</strong></p><ul><li><code>correct_kwargs</code>: An optional named tuple of keyword arguments that are sent to <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a>.</li><li><code>predict_kwargs</code>: An optional named tuple of keyword arguments that are sent to <a href="#StatsAPI.predict!"><code>predict!</code></a>.</li><li><code>interact</code>: Whether or not to run the interaction step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/imm.jl#L193-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}" href="#LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}"><code>LowLevelParticleFilters.weighted_cov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_cov(x,we)</code></pre><p>Similar to <a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>weighted_mean</code></a>, but returns covariances</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}" href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>LowLevelParticleFilters.weighted_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x̂ = weighted_mean(x,we)</code></pre><p>Calculated weighted mean of particle trajectories. <code>we</code> are expweights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L394-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.weighted_mean-Tuple{Any}" href="#LowLevelParticleFilters.weighted_mean-Tuple{Any}"><code>LowLevelParticleFilters.weighted_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x̂ = weighted_mean(pf)
x̂ = weighted_mean(s::PFstate)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L419-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(kf::SqKalmanFilter, u, p = parameters(kf), t::Real = index(kf); R1 = get_mat(kf.R1, kf.x, u, p, t), α = kf.α)</code></pre><p>For the square-root Kalman filter, a custom provided <code>R1</code> must be the upper triangular Cholesky factor of the covariance matrix of the process noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/sq_kalman.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(f, u, p = parameters(f), t = index(f))</code></pre><p>Move filter state forward in time using dynamics equation and input vector <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(kf::AbstractKalmanFilter, u, p = parameters(kf), t::Integer = index(kf); R1, α = kf.α)</code></pre><p>Perform the prediction step (updating the state estimate to <span>$x(t+1|t)$</span>). If <code>R1</code> stored in <code>kf</code> is a function <code>R1(x, u, p, t)</code>, this function is evaluated at the state <em>before</em> the prediction is performed. The dynamics noise covariance matrix <code>R1</code> stored in <code>kf</code> can optionally be overridden by passing the argument <code>R1</code>, in this case <code>R1</code> must be a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/filtering.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM}" href="#StatsAPI.predict!-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM}"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(ukf::UnscentedKalmanFilter, u, p = parameters(ukf), t::Real = index(ukf) * ukf.Ts; R1 = get_mat(ukf.R1, ukf.x, u, p, t), reject, mean, cov, dynamics)</code></pre><p>The prediction step for an <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> allows the user to override, <code>R1</code> and any of the functions, reject, mean, cov, dynamics`.</p><p><strong>Arguments:</strong></p><ul><li><code>u</code>: The input</li><li><code>p</code>: The parameters</li><li><code>t</code>: The current time</li><li><code>R1</code>: The dynamics noise covariance matrix, or a function that returns the covariance matrix.</li><li><code>reject</code>: A function that takes a sigma point and returns <code>true</code> if it should be rejected.</li><li><code>mean</code>: The function that computes the mean of the state sigma points.</li><li><code>cov</code>: The function that computes the covariance of the state sigma points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/ukf.jl#L217-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.prediction_errors!" href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prediction_errors!(res, f::AbstractFilter, u, y, p = parameters(f), λ = 1)</code></pre><p>Calculate the prediction errors and store the result in <code>res</code>. Similar to <a href="@ref"><code>sse</code></a>, this function is useful for sum-of-squares optimization. In contrast to <code>sse</code>, this function returns the residuals themselves rather than their sum of squares. This is useful for Gauss-Newton style optimizers, such as <a href="https://github.com/matthieugomez/LeastSquaresOptim.jl">LeastSquaresOptim.LevenbergMarquardt</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>res</code>: A vector of length <code>ny*length(y)</code>. Note, for each datapoint in <code>u</code> and <code>u</code>, there are <code>ny</code> outputs, and thus <code>ny</code> residuals.</li><li><code>f</code>: Any filter</li><li><code>λ</code>: A weighting factor to minimize <code>dot(e, λ, e</code>). A commonly used metric is <code>λ = Diagonal(1 ./ (mag.^2))</code>, where <code>mag</code> is a vector of the &quot;typical magnitude&quot; of each output. Internally, the square root of <code>W = sqrt(λ)</code> is calculated so that the residuals stored in <code>res</code> are <code>W*e</code>.</li></ul><p>See example in <a href="../parameter_estimation/#Solving-using-Gauss-Newton-optimization">Solving using Gauss-Newton optimization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/43d0205b1ee244478627dae3a99b7013d82b4c8e/src/smoothing.jl#L87-L98">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fault_detection/">« Fault detection</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 24 February 2025 07:09">Monday 24 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
