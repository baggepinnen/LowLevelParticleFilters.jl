<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LowLevelParticleFilters Documentation</title><meta name="title" content="API · LowLevelParticleFilters Documentation"/><meta property="og:title" content="API · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="API · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../measurement_models/">Multiple measurement models</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="../beetle_example_imm/">IMM-filter tutorial</a></li><li><a class="tocitem" href="../rbpf_example/">Rao-Blackwellized PF tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="../adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="../neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="../friction_nn_example/">SciML: Adaptive Universal Differential Equation</a></li><li><a class="tocitem" href="../thermal_nn_example/">SciML: Learning a sunshine disturbance model</a></li><li><a class="tocitem" href="../fault_detection/">Fault detection</a></li><li><a class="tocitem" href="../ut/">Unscented transform</a></li><li><a class="tocitem" href="../disturbance_gallery/">Disturbance gallery</a></li><li><a class="tocitem" href="../sample_rate/">Influence of sample rate on performance</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.AdvancedParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>LowLevelParticleFilters.AuxiliaryParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}"><code>LowLevelParticleFilters.CompositeMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}} where IPM"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>LowLevelParticleFilters.ExtendedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}} where IPM"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>LowLevelParticleFilters.IMM</code></a></li><li><a href="#LowLevelParticleFilters.KalmanFilter"><code>LowLevelParticleFilters.KalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>LowLevelParticleFilters.KalmanFilteringSolution</code></a></li><li><a href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>LowLevelParticleFilters.KalmanSmoothingSolution</code></a></li><li><a href="#LowLevelParticleFilters.LinearMeasurementModel"><code>LowLevelParticleFilters.LinearMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.MerweParams"><code>LowLevelParticleFilters.MerweParams</code></a></li><li><a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.ParticleFilter</code></a></li><li><a href="#LowLevelParticleFilters.ParticleFilteringSolution"><code>LowLevelParticleFilters.ParticleFilteringSolution</code></a></li><li><a href="#LowLevelParticleFilters.RBMeasurementModel"><code>LowLevelParticleFilters.RBMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.RBPF-Union{Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Int64, Any, Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD}"><code>LowLevelParticleFilters.RBPF</code></a></li><li><a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.RBParticle</code></a></li><li><a href="#LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}"><code>LowLevelParticleFilters.SignalNames</code></a></li><li><a href="#LowLevelParticleFilters.SignalNames"><code>LowLevelParticleFilters.SignalNames</code></a></li><li><a href="#LowLevelParticleFilters.SqExtendedKalmanFilter"><code>LowLevelParticleFilters.SqExtendedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.SqKalmanFilter"><code>LowLevelParticleFilters.SqKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.TrivialParams"><code>LowLevelParticleFilters.TrivialParams</code></a></li><li><a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a></li><li><a href="#LowLevelParticleFilters.UKFWeights"><code>LowLevelParticleFilters.UKFWeights</code></a></li><li><a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>LowLevelParticleFilters.UnscentedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.WikiParams"><code>LowLevelParticleFilters.WikiParams</code></a></li><li><a href="#LowLevelParticleFilters.IteratedExtendedKalmanFilter"><code>LowLevelParticleFilters.IteratedExtendedKalmanFilter</code></a></li><li><a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>LowLevelParticleFilters.combine!</code></a></li><li><a href="#LowLevelParticleFilters.commandplot"><code>LowLevelParticleFilters.commandplot</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{SqExtendedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a></li><li><a href="#LowLevelParticleFilters.covplot"><code>LowLevelParticleFilters.covplot</code></a></li><li><a href="#LowLevelParticleFilters.debugplot"><code>LowLevelParticleFilters.debugplot</code></a></li><li><a href="#LowLevelParticleFilters.densityplot"><code>LowLevelParticleFilters.densityplot</code></a></li><li><a href="#LowLevelParticleFilters.double_integrator_covariance"><code>LowLevelParticleFilters.double_integrator_covariance</code></a></li><li><a href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>LowLevelParticleFilters.double_integrator_covariance_smooth</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>LowLevelParticleFilters.interact!</code></a></li><li><a href="#LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Vararg{Any}}"><code>LowLevelParticleFilters.log_likelihood_fun</code></a></li><li><a href="#LowLevelParticleFilters.loglik"><code>LowLevelParticleFilters.loglik</code></a></li><li><a href="#LowLevelParticleFilters.loglik_x"><code>LowLevelParticleFilters.loglik_x</code></a></li><li><a href="#LowLevelParticleFilters.logsumexp!"><code>LowLevelParticleFilters.logsumexp!</code></a></li><li><a href="#LowLevelParticleFilters.mean_trajectory-Tuple{Any, Vector, Vector}"><code>LowLevelParticleFilters.mean_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mean_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.metropolis"><code>LowLevelParticleFilters.metropolis</code></a></li><li><a href="#LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mode_trajectory</code></a></li><li><a href="#LowLevelParticleFilters.n_integrator_covariance"><code>LowLevelParticleFilters.n_integrator_covariance</code></a></li><li><a href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>LowLevelParticleFilters.n_integrator_covariance_smooth</code></a></li><li><a href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a></li><li><a href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_cov</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_mean</code></a></li><li><a href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_trajs</code></a></li><li><a href="#LowLevelParticleFilters.unscentedplot"><code>LowLevelParticleFilters.unscentedplot</code></a></li><li><a href="#LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.update!</code></a></li><li><a href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a></li><li><a href="#LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}"><code>LowLevelParticleFilters.weighted_cov</code></a></li><li><a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>LowLevelParticleFilters.weighted_mean</code></a></li><li><a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any}"><code>LowLevelParticleFilters.weighted_mean</code></a></li><li><a href="#LowLevelParticleFilters.weighted_quantile-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.weighted_quantile</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!-Union{Tuple{IPD}, Tuple{SqExtendedKalmanFilter{IPD}, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any, Real}} where IPD"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!-Union{Tuple{CF}, Tuple{MF}, Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM, MF, CF}"><code>StatsAPI.predict!</code></a></li><li><a href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}" href="#LowLevelParticleFilters.AdvancedParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.AdvancedParticleFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvancedParticleFilter(N::Integer, dynamics::Function, measurement::Function, measurement_likelihood, dynamics_density, initial_density; p = NullParameters(), threads = false, kwargs...)</code></pre><p>This type represents a standard particle filter but affords extra flexibility compared to the <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>ParticleFilter</code></a> type, e.g., non-additive noise in the dynamics and measurement functions.</p><p>See the docs for more information: https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/#AdvancedParticleFilter-1</p><p><strong>Arguments:</strong></p><ul><li><code>N</code>: Number of particles</li><li><code>dynamics</code>: A discrete-time dynamics function <code>(x, u, p, t, noise=false) -&gt; x⁺</code>. It&#39;s important that the <code>noise</code> argument defaults to <code>false</code>.</li><li><code>measurement</code>: A measurement function <code>(x, u, p, t, noise=false) -&gt; y</code>. It&#39;s important that the <code>noise</code> argument defaults to <code>false</code>.</li><li><code>measurement_likelihood</code>: A function <code>(x, u, y, p, t)-&gt;logl</code> to evaluate the log-likelihood of a measurement.</li><li><code>dynamics_density</code>: This field is not used by the advanced filter and can be set to <code>nothing</code>.</li><li><code>initial_density</code>: The distribution of the initial state.</li><li><code>threads</code>: use threads to propagate particles in parallel. Only activate this if your dynamics is thread-safe. <code>SeeToDee.SimpleColloc</code> is not thread-safe by default due to the use of internal caches, but <code>SeeToDee.Rk4</code> is.</li></ul><p><strong>Extended help</strong></p><p><strong>Multiple measurement models</strong></p><p>The <code>measurement_likelihood</code> function is used to evaluate the likelihood of a measurement. If you have multiple sensors and want to perform individual <code>correct!</code> steps for each, call <code>correct!(..., g = custom_likelihood_function)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/PFtypes.jl#L180-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple" href="#LowLevelParticleFilters.AuxiliaryParticleFilter-Tuple"><code>LowLevelParticleFilters.AuxiliaryParticleFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AuxiliaryParticleFilter(args...; kwargs...)</code></pre><p>Takes exactly the same arguments as <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>ParticleFilter</code></a>, or an instance of <a href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>ParticleFilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/PFtypes.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}" href="#LowLevelParticleFilters.CompositeMeasurementModel-Tuple{Any, Vararg{Any}}"><code>LowLevelParticleFilters.CompositeMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeMeasurementModel(model1, model2, ...)</code></pre><p>A composite measurement model that combines multiple measurement models. This model acts as all component models concatenated. The tuple returned from <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a> will be</p><ul><li><code>ll</code>: The sum of the log-likelihood of all component models</li><li><code>e</code>: The concatenated innovation vector</li><li><code>S</code>: A vector of the innovation covariance matrices of the component models</li><li><code>Sᵪ</code>: A vector of the Cholesky factorizations of the innovation covariance matrices of the component models</li><li><code>K</code>: A vector of the Kalman gains of the component models</li></ul><p>If all sensors operate on at the same rate, and all measurement models are of the same type, it&#39;s more efficient to use a single measurement model with a vector-valued measurement function.</p><p><strong>Fields:</strong></p><ul><li><code>models</code>: A tuple of measurement models</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L11-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}} where IPM" href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}} where IPM"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EKFMeasurementModel{IPM}(measurement, R2, ny, Cjac, cache = nothing)</code></pre><p>A measurement model for the Extended Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>IPM</code>: A boolean indicating if the measurement function is inplace</li><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>Cjac</code>: The Jacobian of the measurement function <code>Cjac(x, u, p, t)</code>. If none is provided, ForwardDiff will be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L259-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}" href="#LowLevelParticleFilters.EKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.EKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EKFMeasurementModel{T,IPM}(measurement::M, R2; nx, ny, Cjac = nothing)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L291-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.ExtendedKalmanFilter" href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>LowLevelParticleFilters.ExtendedKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtendedKalmanFilter(kf, dynamics, measurement; Ajac, Cjac)
ExtendedKalmanFilter(dynamics, measurement, R1,R2,d0=MvNormal(Matrix(R1)); nu::Int, p = NullParameters(), α = 1.0, check = true)</code></pre><p>A nonlinear state estimator propagating uncertainty using linearization.</p><p>The constructor to the extended Kalman filter takes dynamics and measurement functions, and either covariance matrices, or a <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. If the former constructor is used, the number of inputs to the system dynamics, <code>nu</code>, must be explicitly provided with a keyword argument.</p><p>By default, the filter will internally linearize the dynamics using ForwardDiff. User provided Jacobian functions can be provided as keyword arguments <code>Ajac</code> and <code>Cjac</code>. These functions should have the signature <code>(x,u,p,t)::AbstractMatrix</code> where <code>x</code> is the state, <code>u</code> is the input, <code>p</code> is the parameters, and <code>t</code> is the time.</p><p>The dynamics and measurement function are on the following form</p><pre><code class="nohighlight hljs">x(t+1) = dynamics(x, u, p, t) + w
y      = measurement(x, u, p, t) + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices <code>R1, R2</code> can be time varying such that, e.g., <code>R1[:, :, t]</code> contains the <span>$R_1$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Rfun(x, u, p, t) -&gt; R</code></pre><p>This allows for, e.g., handling functions where the dynamics disturbance <span>$w$</span> is an input argument to the function, by linearizing the dynamics w.r.t. the disturbance input in a function for <span>$R_1$</span>, like this (assuming the dynamics have the function signalture <code>f(x, u, p, t, w)</code>):</p><pre><code class="nohighlight hljs">function R1fun(x,u,p,t)
    Bw = ForwardDiff.jacobian(w-&gt;f(x, u, p, t, w), zeros(length(w)))
    Bw * R1 * Bw&#39;
end</code></pre><p>When providing functions, the dimensions of the state, input and output, <code>nx, nu, ny</code> must be provided as keyword arguments to the <code>ExtendedKalmanFilter</code> constructor since these cannot be inferred from the function signature. For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p>See also <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> which is typically more accurate than <code>ExtendedKalmanFilter</code>. See <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> for detailed instructions on how to set up a Kalman filter <code>kf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ekf.jl#L10-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}} where IPM" href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{IPM}, NTuple{4, Any}, NTuple{5, Any}, NTuple{6, Any}, NTuple{7, Any}, NTuple{8, Any}} where IPM"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IEKFMeasurementModel{IPM}(measurement, R2, ny, Cjac, cache = nothing)</code></pre><p>A measurement model for the Iterated Extended Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>IPM</code>: A boolean indicating if the measurement function is inplace</li><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>Cjac</code>: The Jacobian of the measurement function <code>Cjac(x, u, p, t)</code>. If none is provided, ForwardDiff will be used.</li><li><code>step</code>: The step size in the Gauss-Newton method. Should be Float64 between 0 and 1.</li><li><code>maxiters</code>: The maximum number of iterations of the Gauss-Newton method inside the IEKF</li><li><code>epsilon</code>: The convergence criterion for the Gauss-Newton method inside the IEKF</li><li><code>cache</code>: A cache for the Jacobian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L396-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}" href="#LowLevelParticleFilters.IEKFMeasurementModel-Union{Tuple{M}, Tuple{IPM}, Tuple{T}, Tuple{M, Any}} where {T, IPM, M}"><code>LowLevelParticleFilters.IEKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IEKFMeasurementModel{T,IPM}(measurement::M, R2; nx, ny, Cjac = nothing, step = 1.0, maxiters = 10, epsilon = 1e-8)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L438-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}" href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>LowLevelParticleFilters.IMM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMM(models, P, μ; check = true, p = NullParameters(), interact = true)</code></pre><p>Interacting Multiple Model (IMM) filter. This filter is a combination of multiple Kalman-type filters, each with its own state and covariance. The IMM filter is a probabilistically weighted average of the states and covariances of the individual filters. The weights are determined by the probability matrix <code>P</code> and the mixing probabilities <code>μ</code>.</p><p>This implmentation allows for any combination of Kalman-type estimators to be used in the internal ensemble of models, and is not limited to linear estimators. This class of models encompasses others, such as </p><ul><li>Jump Markov Linear Systems (JMLS)</li><li>Multiple-model filters (interactivity can be turned off by setting <code>interact=false</code>)</li><li>Multiple Hypothesis Tracking (MHT)</li></ul><div class="admonition is-warning" id="Experimental-f701a5ff962ea4d4"><header class="admonition-header">Experimental<a class="admonition-anchor" href="#Experimental-f701a5ff962ea4d4" title="Permalink"></a></header><div class="admonition-body"><p>This filter is currently considered experimental and the user interface may change in the future without respecting semantic versioning.</p></div></div><p>In addition to the <a href="#StatsAPI.predict!"><code>predict!</code></a> and <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a> steps, the IMM filter has an <a href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>interact!</code></a> method that updates the states and covariances of the individual filters based on the mixing probabilities. The <a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>combine!</code></a> method combines the states and covariances of the individual filters into a single state and covariance. These four functions are typically called in either of the orders</p><ul><li><code>correct!, combine!, interact!, predict!</code> (as is done in <a href="#LowLevelParticleFilters.update!"><code>update!</code></a>)</li><li><code>interact!, predict!, correct!, combine!</code> (as is done in the reference cited below)</li></ul><p>These two orders are cyclic permutations of each other, and the order used in <a href="#LowLevelParticleFilters.update!"><code>update!</code></a> is chosen to align with the order used in the other filters, where the initial condition is corrected using the first measurement, i.e., we assume the first measurement updates <span>$x(0|-1)$</span> to <span>$x(0|0)$</span>.</p><p>The initial (combined) state and covariance of the IMM filter is made up of the weighted average of the states and covariances of the individual filters. The weights are the initial mixing probabilities <code>μ</code>.</p><p>Ref: &quot;Interacting multiple model methods in target tracking: a survey&quot;, E. Mazor; A. Averbuch; Y. Bar-Shalom; J. Dayan</p><p><strong>Arguments:</strong></p><ul><li><code>models</code>: An array of Kalman-type filters, such as <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>, <a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a>, <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a>, etc. The state of each model must have the same meaning, such that forming a weighted average makes sense.</li><li><code>P</code>: The mode-transition probability matrix. <code>P[i,j]</code> is the probability of transitioning from mode <code>i</code> to mode <code>j</code> (each row must sum to one).</li><li><code>μ</code>: The initial mixing probabilities. <code>μ[i]</code> is the probability of being in mode <code>i</code> at the initial contidion (must sum to one).</li><li><code>check</code>: If <code>true</code>, check that the inputs are valid. If <code>false</code>, skip the checks.</li><li><code>p</code>: Parameters for the filter. NOTE: this <code>p</code> is shared among all internal filters. The internal <code>p</code> of each filter will be overridden by this one.</li><li><code>interact</code>: If <code>true</code>, the filter will run the interaction as part of <a href="#LowLevelParticleFilters.update!"><code>update!</code></a> and <a href="#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>. If <code>false</code>, the filter will not run the interaction step. This choice can be overridden by passing the keyword argument <code>interact</code> to the respective functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/imm.jl#L18-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.KalmanFilter" href="#LowLevelParticleFilters.KalmanFilter"><code>LowLevelParticleFilters.KalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanFilter(A,B,C,D,R1,R2,d0=MvNormal(R1); p = NullParameters(), α=1, check=true)</code></pre><p>The matrices <code>A,B,C,D</code> define the dynamics</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w
y  = Cx + Du + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices can be time varying such that, e.g., <code>A[:, :, t]</code> contains the <span>$A$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Afun(x, u, p, t) -&gt; A</code></pre><p>When providing functions, the dimensions of the state, input and output, <code>nx, nu, ny</code> must be provided as keyword arguments to the <code>KalmanFilter</code> constructor since these cannot be inferred from the function signature. For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p>α is an optional &quot;forgetting factor&quot;, if this is set to a value &gt; 1, such as 1.01-1.2, the filter will, in addition to the covariance inflation due to <span>$R_1$</span>, exhibit &quot;exponential forgetting&quot; similar to a <a href="https://en.wikipedia.org/wiki/Recursive_least_squares_filter">Recursive Least-Squares (RLS) estimator</a>. It is thus possible to get a RLS-like algorithm by setting <span>$R_1=0, R_2 = 1/α$</span> and <span>$α &gt; 1$</span> (<span>$α$</span> is the inverse of the traditional RLS parameter <span>$α = 1/λ$</span>). The exact form of the covariance update is</p><p class="math-container">\[R(t+1|t) = α AR(t)A^T + R_1\]</p><p>If <code>check = true (default)</code> the function will check that the eigenvalues of <code>A</code> are less than 2 in absolute value. Large eigenvalues may be an indication that the system matrices are representing a continuous-time system and the user has forgotten to discretize it. Turn off this check by setting <code>check = false</code>.</p><p><strong>Tutorials on Kalman filtering</strong></p><p>The tutorial <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">&quot;How to tune a Kalman filter&quot;</a> details how to figure out appropriate covariance matrices for the Kalman filter, as well as how to add disturbance models to the system model. See also the <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/adaptive_kalmanfilter/">tutorial in the documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/kalman.jl#L47-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.KalmanFilteringSolution" href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>LowLevelParticleFilters.KalmanFilteringSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanFilteringSolution &lt;: AbstractFilteringSolution</code></pre><p><strong>Fields</strong></p><ul><li><code>x</code>: predictions <span>$x(t+1|t)$</span> (plotted if <code>plotx=true</code>)</li><li><code>xt</code>: filtered estimates <span>$x(t|t)$</span> (plotted if <code>plotxt=true</code>)</li><li><code>R</code>: predicted covariance matrices <span>$R(t+1|t)$</span> (plotted if <code>plotR=true</code>)</li><li><code>Rt</code>: filter covariances <span>$R(t|t)$</span> (plotted if <code>plotRt=true</code>)</li><li><code>ll</code>: loglikelihood</li><li><code>e</code>: prediction errors <span>$e(t|t-1) = y - ŷ(t|t-1)$</span> (plotted if <code>plote=true</code>)</li><li><code>K</code>: Kalman gain</li><li><code>S</code>: Cholesky factorization of innovation covariance</li></ul><p><strong>Plot</strong></p><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol, plotx=true, plotxt=true, plotR=true, plotRt=true, plote=true, plotu=true, ploty=true, plotyh=true, plotyht=true, name=&quot;&quot;)</code></pre><p>where</p><ul><li><code>plotx</code>: Plot the predictions <code>x(t|t-1)</code></li><li><code>plotxt</code>: Plot the filtered estimates <code>x(t|t)</code></li><li><code>plotR</code>: Plot the predicted covariances <code>R(t|t-1)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li><code>plotRt</code>: Plot the filter covariances <code>R(t|t)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li><code>plote</code>: Plot the prediction errors <code>e(t|t-1) = y - ŷ(t|t-1)</code></li><li><code>plotu</code>: Plot the input</li><li><code>ploty</code>: Plot the measurements</li><li><code>plotyh</code>: Plot the predicted measurements <code>ŷ(t|t-1)</code></li><li><code>plotyht</code>: Plot the filtered measurements <code>ŷ(t|t)</code></li><li><code>name</code>: a string that is prepended to the labels of the plots, which is useful when plotting multiple solutions in the same plot.</li><li><code>σ = 1.96</code> The number of standard deviations covered by covariance ribbons</li></ul><p>To modify the signal names used in legend entries, construct an instance of <a href="#LowLevelParticleFilters.SignalNames"><code>SignalNames</code></a> and pass this to the filter (or directly to the plot command) using the <code>names</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/solutions.jl#L17-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.KalmanSmoothingSolution" href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>LowLevelParticleFilters.KalmanSmoothingSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct KalmanSmoothingSolution</code></pre><p>A structure representing the solution to a Kalman smoothing problem.</p><p><strong>Fields</strong></p><ul><li><code>sol</code>: A solution object containing the results of the <em>filtering</em> process.</li><li><code>xT</code>: The smoothed state estimate.</li><li><code>RT</code>: The smoothed state covariance.</li></ul><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol; plotxT=true, plotRT=true, kwargs...)</code></pre><p>where</p><ul><li><code>plotxT</code>: Plot the smoothed estimates <code>x(t|T)</code></li><li><code>plotRT</code>: Plot the smoothed covariances <code>R(t|T)</code> as ribbons at ±2σ (1.96 σ to be precise)</li><li>The rest of the keyword arguments are the same as for <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a></li></ul><p>When plotting a smoothing solution, the filtering solution is also plotted. The same keyword arguments as for <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> may be used to control which signals are plotted</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/solutions.jl#L179-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.LinearMeasurementModel" href="#LowLevelParticleFilters.LinearMeasurementModel"><code>LowLevelParticleFilters.LinearMeasurementModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearMeasurementModel{CT, DT, RT, CAT}</code></pre><p>A linear measurement model <span>$y = C*x + D*u + e$</span>.</p><p><strong>Fields:</strong></p><ul><li><code>C</code> </li><li><code>D</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L335-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.MerweParams" href="#LowLevelParticleFilters.MerweParams"><code>LowLevelParticleFilters.MerweParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MerweParams(; α = 1.0, β = 2.0, κ = 0.0)
MerweParams(; ακ = 1.0, β = 2.0) # Simplified interface with only one parameter for ακ</code></pre><p>Unscented transform parameters suggested by van der Merwe et al.</p><ul><li><code>α</code>: Scaling parameter (0,1] for the spread of the sigma points. Reduce <code>α</code> to reduce the spread.</li><li><code>β</code>: Incorporates prior knowledge of the distribution of the state.</li><li><code>κ</code>: Secondary scaling parameter that is usually set to 0. Increase <code>κ</code> to increase the spread of the sigma points.</li></ul><p>If <span>$α^2 (L + κ) &lt; L$</span> where <span>$L$</span> is the dimension of the sigma points, the center mean weight is negative. This is allowed, but may in some cases lead to an indefinite covariance matrix.</p><p>The spread of the points are <span>$α^2 (L + κ)$</span> where <span>$L$</span> is the dimension of each point. Visualize the spread by</p><pre><code class="language-julia hljs">using Plots
μ = [0.0, 0.0]
Σ = [1.0 0.0; 0.0 1.0]
pars = LowLevelParticleFilters.MerweParams(α = 1e-3, β = 2.0, κ = 0.0)
xs = LowLevelParticleFilters.sigmapoints(μ, Σ, pars)
unscentedplot(xs, pars)</code></pre><p>A simplified tuning rule </p><ul><li>If a decrease in the spread of the sigma points is desired, use <span>$κ = 0$</span> and <span>$α &lt; 1$</span>.</li><li>If an increase in the spread of the sigma points is desired, use <span>$κ &gt; 0$</span> and <span>$α = 1$</span>.</li></ul><p>This rule may be used when using the interface with only a single function argument <span>$ακ$</span>. See Nielsen, K. et al., 2021, &quot;UKF Parameter Tuning for Local Variation Smoothing&quot; for more details.</p><p>See also <a href="#LowLevelParticleFilters.WikiParams"><code>WikiParams</code></a> and <a href="#LowLevelParticleFilters.TrivialParams"><code>TrivialParams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ukf.jl#L56-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}" href="#LowLevelParticleFilters.ParticleFilter-Tuple{Integer, Function, Function, Any, Any, Any}"><code>LowLevelParticleFilters.ParticleFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleFilter(N::Integer, dynamics, measurement, dynamics_density, measurement_density, initial_density; threads = false, p = NullParameters(), kwargs...)</code></pre><p>See the docs for more information: https://baggepinnen.github.io/LowLevelParticleFilters.jl/stable/#Particle-filter-1</p><p><strong>Arguments:</strong></p><ul><li><code>N</code>: Number of particles</li><li><code>dynamics</code>: A discrete-time dynamics function <code>(x, u, p, t) -&gt; x⁺</code></li><li><code>measurement</code>: A measurement function <code>(x, u, p, t) -&gt; y</code></li><li><code>dynamics_density</code>: A probability-density function for additive noise in the dynamics. Use <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> for non-additive noise.</li><li><code>measurement_density</code>: A probability-density function for additive measurement noise. Use <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a> for non-additive noise.</li><li><code>initial_density</code>: Distribution of the initial state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/PFtypes.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.ParticleFilteringSolution" href="#LowLevelParticleFilters.ParticleFilteringSolution"><code>LowLevelParticleFilters.ParticleFilteringSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParticleFilteringSolution{F, Tu, Ty, Tx, Tw, Twe, Tll} &lt;: AbstractFilteringSolution</code></pre><p><strong>Fields:</strong></p><ul><li><code>f</code>: The filter used to produce the solution.</li><li><code>u</code>: Input</li><li><code>y</code>: Output / measurements</li><li><code>x</code>: Particles, the size of this array is <code>(N,T)</code>, where <code>N</code> is the number of particles and <code>T</code> is the number of time steps. Each element represents a weighted state hypothesis with weight given by <code>we</code>.</li><li><code>w</code>: Weights (log space). These are used for internal computations.</li><li><code>we</code>: Weights (exponentiated / original space). These are the ones to use to compute weighted means etc., they sum to one for each time step.</li><li><code>ll</code>: Log likelihood</li></ul><p><strong>Plot</strong></p><p>The solution object can be plotted</p><pre><code class="nohighlight hljs">plot(sol; nbinsy=30, xreal=nothing, dim=nothing, ploty=true, q=nothing)</code></pre><p>By default, a weighted 2D histogram is plotted, one for each state variable. If a vector of quantiles are provided in <code>q</code>, the quantiles are plotted instead of the histogram. If <code>xreal</code> is provided, the true state is plotted as a scatter plot on top of the histogram. If <code>dim</code> is provided, only the specified dimension is plotted. If <code>ploty</code> is true, the measurements are plotted as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/solutions.jl#L262-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.RBMeasurementModel" href="#LowLevelParticleFilters.RBMeasurementModel"><code>LowLevelParticleFilters.RBMeasurementModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RBMeasurementModel{IPM}(measurement, R2, ny)</code></pre><p>A measurement model for the Rao-Blackwellized particle filter.</p><p><strong>Fields:</strong></p><ul><li><code>measurement</code>: The contribution from the nonlinar state to the output, <span>$g$</span> in <span>$y = g(x^n, u, p, t) + C x^l + e$</span></li><li><code>R2</code>: The probability distribution of the measurement noise. If <code>C == 0</code>, this may be any distribution, otherwise it must be an instance of <code>MvNormal</code> or <code>SimpleMvNormal</code>.</li><li><code>ny</code>: The number of outputs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/rbpf.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.RBPF-Union{Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Int64, Any, Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD}" href="#LowLevelParticleFilters.RBPF-Union{Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Int64, Any, Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD}"><code>LowLevelParticleFilters.RBPF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RBPF{IPD,IPM,AUGD}(N::Int, kf, dynamics, nl_measurement_model::AbstractMeasurementModel, R1n, d0n; An, nu::Int, Ts=1.0, p=NullParameters(), names, rng = Xoshiro(), resample_threshold=0.1)</code></pre><p>Rao-Blackwellized particle filter, also called &quot;Marginalized particle filter&quot;. The filter is effectively a particle filter where each particle is a Kalman filter that is responsible for the estimation of a linear sub structure.</p><div class="admonition is-warning" id="Experimental-f701a5ff962ea4d4"><header class="admonition-header">Experimental<a class="admonition-anchor" href="#Experimental-f701a5ff962ea4d4" title="Permalink"></a></header><div class="admonition-body"><p>This filter is currently considered experimental and the user interface may change in the future without respecting semantic versioning.</p></div></div><p>The filter assumes that the dynamics follow &quot;model 2&quot; in the reference below, i.e., the dynamics is described by</p><p class="math-container">\[ \begin{align}
     x_{t+1}^n &amp;= f_n(x_t^n, u, p, t) + A_n(x_t^n, u, p, t) x_t^l + w_t^n, \quad &amp;w_t^n \sim \mathcal{N}(0, R_1^n) \\
     x_{t+1}^l &amp;= A(...) x_t^l + Bu + w_t^l, \quad &amp;w_t^l \sim \mathcal{N}(0, R_1^l) \\
     y_t &amp;= g(x_t^n, u, p, t) + C(...) x_t^l + e_t, \quad &amp;e_t \sim \mathcal{N}(0, R_2)
 \end{align}\]</p><p>where <span>$x^n$</span> is a subset of the state that has nonlinear dynamics, and <span>$x^l$</span> is the linear part of the state. The entire state vector is represented by a special type <a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>RBParticle</code></a> that behaves like the vector <code>[xn; xl]</code>, but stores <code>xn, xl</code> and the covariance <code>R</code> or <code>xl</code> separately.</p><ul><li><code>N</code>: Number of particles</li><li><code>kf</code>: The internal Kalman filter that will be used for the linear part. This encodes the dynamics of the linear subspace. The matrices <span>$A, B, C, D, R_1^l$</span> of the Kalman filter may be functions of <code>x, u, p, t</code> that return a matrix. The state <code>x</code> received by such functions is of type <a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>RBParticle</code></a> with the fields <code>xn</code> and <code>xl</code>.</li><li><code>dynamics</code>: The nonlinear part <span>$f_n$</span> of the dynamics of the nonlinear substate <code>f(xn, u, p, t)</code></li><li><code>nl_measurement_model</code>: An instance of <a href="#LowLevelParticleFilters.RBMeasurementModel"><code>RBMeasurementModel</code></a> that stores <span>$g$</span> and the measurement noise distribution <span>$R_2$</span>.</li><li><code>R1n</code>: The noise distribution of the nonlinear state dynamics, this may be a covariance matrix or a distribution. If <code>An = nothing</code>, this may be any distribution, otherwise it must be an instance of <code>MvNormal</code> or <code>SimpleMvNormal</code>.</li><li><code>d0n</code>: The initial distribution of the nonlinear state <span>$x_0^n$</span>.</li><li><code>An</code>: The matrix that describes the linear effect on the nonlinear state, i.e., <span>$A_n x^l$</span>. This may be a matrix or a function of <span>$x, u, p, t$</span> that returns a matrix. Pass <code>An = nothing</code> if there is no linear effect on the nonlinear state. The <code>x</code> received by such a function is of type <a href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>RBParticle</code></a> with the fields <code>xn</code> and <code>xl</code>.</li><li><code>nu</code>: The number of control inputs</li><li><code>Ts</code>: The sampling time</li><li><code>p</code>: Parameters</li><li><code>names</code>: Signal names, an instance of <a href="#LowLevelParticleFilters.SignalNames"><code>SignalNames</code></a></li><li><code>rng</code>: Random number generator</li><li><code>resample_threshold</code>: The threshold for resampling</li></ul><p>Based on the article <a href="https://people.isy.liu.se/rt/schon/Publications/SchonGN2004.pdf">&quot;Marginalized Particle Filters for Mixed Linear/Nonlinear State-space Models&quot; by Thomas Schön, Fredrik Gustafsson, and Per-Johan Nordlund</a></p><p><strong>Extended help</strong></p><p>The paper contains an even more general model, where the linear part is linearly affected by the nonlinear state. It further details a number of special cases in which possible simplifications arise. </p><ul><li>If <code>C == 0</code> and <code>D == 0</code>, the measurement is not used by the Kalman filter and we may thus have an arbitrary probability distribution for the measurement noise.</li><li>If <code>An == 0</code>, the nonlinear state is not affected by the linear state and we may have an arbitrary probability distribution for the nonlinear state noise <code>R1n</code>. Otherwise <code>R1n</code> must be Gaussian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/rbpf.jl#L81-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}" href="#LowLevelParticleFilters.RBParticle-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.RBParticle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RBParticle(xn, xl, R) &lt;: AbstractVector</code></pre><p>A struct that represents the state of a Rao-Blackwellized particle filter. The struct is an abstract vector, and when indexed like a vector it behaves as <code>[xn; xl]</code>. To access nonlinear or linear substate individually, access the fields <code>xn</code> and <code>xl</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>xn</code>: The nonlinear state vector</li><li><code>xl</code>: The linear state vector</li><li><code>R</code>: The covariance matrix for the linear state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/rbpf.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.SignalNames" href="#LowLevelParticleFilters.SignalNames"><code>LowLevelParticleFilters.SignalNames</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SignalNames(; x, u, y, name)</code></pre><p>A structure representing the names of the signals in a system.</p><ul><li><code>x::Vector{String}</code>: Names of the state variables</li><li><code>u::Vector{String}</code>: Names of the input variables</li><li><code>y::Vector{String}</code>: Names of the output variables</li><li><code>name::String</code>: Name of the system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/signalnames.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}" href="#LowLevelParticleFilters.SignalNames-Tuple{SignalNames, Any}"><code>LowLevelParticleFilters.SignalNames</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SignalNames(sn::SignalNames, name)</code></pre><p>Copy the <code>SignalNames</code> structure and change the name of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/signalnames.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.SqExtendedKalmanFilter" href="#LowLevelParticleFilters.SqExtendedKalmanFilter"><code>LowLevelParticleFilters.SqExtendedKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SqExtendedKalmanFilter(kf, dynamics, measurement; Ajac, Cjac)
SqExtendedKalmanFilter(dynamics, measurement, R1,R2,d0=MvNormal(Matrix(R1)); nu::Int, p = NullParameters(), α = 1.0, check = true)</code></pre><p>A nonlinear state estimator propagating uncertainty using linearization with square-root covariance representation.</p><p>This filter combines the Extended Kalman Filter&#39;s ability to handle nonlinear dynamics with the Square-root Kalman Filter&#39;s numerical stability. It maintains the covariance in Cholesky factorized form, ensuring positive definiteness and improved numerical conditioning.</p><p>The constructor takes dynamics and measurement functions, and either covariance matrices or a <a href="#LowLevelParticleFilters.SqKalmanFilter"><code>SqKalmanFilter</code></a>. If the former constructor is used, the number of inputs to the system dynamics, <code>nu</code>, must be explicitly provided.</p><p>By default, the filter will internally linearize the dynamics using ForwardDiff. User provided Jacobian functions can be provided as keyword arguments <code>Ajac</code> and <code>Cjac</code>. These functions should have the signature <code>(x,u,p,t)::AbstractMatrix</code> where <code>x</code> is the state, <code>u</code> is the input, <code>p</code> is the parameters, and <code>t</code> is the time.</p><p>The dynamics and measurement function are on the following form:</p><pre><code class="nohighlight hljs">x(t+1) = dynamics(x, u, p, t) + w
y      = measurement(x, u, p, t) + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>For the square-root formulation, <code>R1</code> and <code>R2</code> can be provided as:</p><ul><li>Regular covariance matrices (will be converted to Cholesky factors internally)</li><li><code>UpperTriangular</code> matrices representing the Cholesky factors</li></ul><p>See also <a href="#LowLevelParticleFilters.ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a> for the standard formulation and <a href="#LowLevelParticleFilters.SqKalmanFilter"><code>SqKalmanFilter</code></a> for the linear square-root filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_ekf.jl#L15-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.SqKalmanFilter" href="#LowLevelParticleFilters.SqKalmanFilter"><code>LowLevelParticleFilters.SqKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SqKalmanFilter(A,B,C,D,R1,R2,d0=MvNormal(R1); p = NullParameters(), α=1)</code></pre><p>A standard Kalman filter on square-root form. This filter may have better numerical performance when the covariance matrices are ill-conditioned.</p><p>The matrices <code>A,B,C,D</code> define the dynamics</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w
y  = Cx + Du + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><p>The matrices can be time varying such that, e.g., <code>A[:, :, t]</code> contains the <span>$A$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Afun(x, u, p, t) -&gt; A</code></pre><p>The covariance matrices <code>R1</code> and <code>R2</code> are the covariance matrices of the process noise and measurement noise, respectively. They can be provided as a matrix, as an <code>UpperTriangular</code> matrix representing the Cholesky factor. If <code>R1</code> or <code>R2</code> is a function, it must return the upper triangular Cholesky factor of the covariance matrix at the given time index.</p><p>The internal fields storing covariance matrices are for this filter storing the upper-triangular Cholesky factor.</p><p>α is an optional &quot;forgetting factor&quot;, if this is set to a value &gt; 1, such as 1.01-1.2, the filter will, in addition to the covariance inflation due to <span>$R_1$</span>, exhibit &quot;exponential forgetting&quot; similar to a <a href="https://en.wikipedia.org/wiki/Recursive_least_squares_filter">Recursive Least-Squares (RLS) estimator</a>. It is thus possible to get a RLS-like algorithm by setting <span>$R_1=0, R_2 = 1/α$</span> and <span>$α &gt; 1$</span> (<span>$α$</span> is the inverse of the traditional RLS parameter <span>$α = 1/λ$</span>). The form of the covariance update is</p><p class="math-container">\[R(t+1|t) = α AR(t)A^T + R_1\]</p><p>Ref: &quot;A Square-Root Kalman Filter Using Only QR Decompositions&quot;, Kevin Tracy https://arxiv.org/abs/2208.06452</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_kalman.jl#L19-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.TrivialParams" href="#LowLevelParticleFilters.TrivialParams"><code>LowLevelParticleFilters.TrivialParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TrivialParams()</code></pre><p>Unscented transform parameters representing a trivial choice of weights, where all weights are equal.</p><p>See also <a href="#LowLevelParticleFilters.WikiParams"><code>WikiParams</code></a> and <a href="#LowLevelParticleFilters.MerweParams"><code>MerweParams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ukf.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}" href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UKFMeasurementModel{inplace_measurement,augmented_measurement}(measurement, R2, ny, ne, innovation, mean, cov, cross_cov, weight_params, cache = nothing)</code></pre><p>A measurement model for the Unscented Kalman Filter.</p><p><strong>Arguments:</strong></p><ul><li><code>measurement</code>: The measurement function <code>y = h(x, u, p, t)</code></li><li><code>R2</code>: The measurement noise covariance matrix</li><li><code>ny</code>: The number of measurement variables</li><li><code>ne</code>: If <code>augmented_measurement</code> is <code>true</code>, the number of measurement noise variables</li><li><code>innovation(y::AbstractVector, yh::AbstractVector)</code> where the arguments represent (measured output, predicted output)</li><li><code>mean(ys::AbstractVector{&lt;:AbstractVector})</code>: computes the mean of the vector of vectors of output sigma points.</li><li><code>cov(ys::AbstractVector{&lt;:AbstractVector}, y::AbstractVector)</code>: computes the covariance matrix of the output sigma points.</li><li><code>cross_cov(xs::AbstractVector{&lt;:AbstractVector}, x::AbstractVector, ys::AbstractVector{&lt;:AbstractVector}, y::AbstractVector, W::UKFWeights)</code> where the arguments represents (state sigma points, mean state, output sigma points, mean output, weights). The function should return the weighted <strong>cross-covariance</strong> matrix between the state and output sigma points.</li><li><code>weight_params</code>: A type that holds the parameters for the unscented-transform weights. See <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> and <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/dev/ut/">Docs: Unscented transform</a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L93-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}" href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, Tuple{T}, Tuple{Any, Any}} where {T, IPM, AUGM}"><code>LowLevelParticleFilters.UKFMeasurementModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UKFMeasurementModel{T,IPM,AUGM}(measurement, R2; nx, ny, ne = nothing, innovation = -, mean = weighted_mean, cov = weighted_cov, cross_cov = cross_cov, static = nothing)</code></pre><ul><li><code>T</code> is the element type used for arrays</li><li><code>IPM</code> is a boolean indicating if the measurement function is inplace</li><li><code>AUGM</code> is a boolean indicating if the measurement model is augmented</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/measurement_model.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.UKFWeights" href="#LowLevelParticleFilters.UKFWeights"><code>LowLevelParticleFilters.UKFWeights</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UKFWeights</code></pre><p>Weights for the Unscented Transform.</p><p>Sigmapoints are by convention ordered such that the center (mean) point is first.</p><p><strong>Fields</strong></p><ul><li><code>wm</code>: center weight when computing mean</li><li><code>wc</code>: center weight when computing covariance</li><li><code>wmi</code>: off-center weight when computing mean</li><li><code>wci</code>: off-center weight when computing covariance</li><li><code>W</code>: Cholesky weight</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ukf.jl#L120-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}" href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>LowLevelParticleFilters.UnscentedKalmanFilter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnscentedKalmanFilter(dynamics, measurement, R1, R2, d0=MvNormal(Matrix(R1)); p = NullParameters(), ny, nu, weight_params)
UnscentedKalmanFilter{IPD,IPM,AUGD,AUGM}(dynamics, measurement_model::AbstractMeasurementModel, R1, d0=SimpleMvNormal(R1); p=NullParameters(), nu, weight_params)</code></pre><p>A nonlinear state estimator propagating uncertainty using the unscented transform.</p><p>The dynamics and measurement function are on <em>either</em> of the following forms</p><pre><code class="nohighlight hljs">x&#39; = dynamics(x, u, p, t) + w
y  = measurement(x, u, p, t) + e</code></pre><pre><code class="nohighlight hljs">x&#39; = dynamics(x, u, p, t, w)
y  = measurement(x, u, p, t, e)</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code>. The former (default) assums that the noise is additive and added <em>after</em> the dynamics and measurement updates, while the latter assumes that the dynamics functions take an additional argument corresponding to the noise term. The latter form (sometimes refered to as the &quot;augmented&quot; form) is useful when the noise is multiplicative or when the noise is added <em>before</em> the dynamics and measurement updates. See &quot;Augmented UKF&quot; below for more details on how to use this form. In both cases should the noise be modeled as discrete-time white noise, see Discretization: <a href="../discretization/#Covariance-matrices">Covariance matrices</a>.</p><p>The matrices <code>R1, R2</code> can be time varying such that, e.g., <code>R1[:, :, t]</code> contains the <span>$R_1$</span> matrix at time index <code>t</code>. They can also be given as functions on the form</p><pre><code class="nohighlight hljs">Rfun(x, u, p, t) -&gt; R</code></pre><p>For maximum performance, provide statically sized matrices from StaticArrays.jl</p><p><code>ny, nu</code> indicate the number of outputs and inputs.</p><p><strong>Custom type of <code>u</code></strong></p><p>The input <code>u</code> may be of any type, e.g., a named tuple or a custom struct. The <code>u</code> provided in the input data is passed directly to the dynamics and measurement functions, so as long as the type is compatible with the dynamics it will work out. The one exception where this will not work is when calling <code>simulate</code>, which assumes that <code>u</code> is an array.</p><p><strong>Augmented UKF</strong></p><p>If the noise is not additive, one may use the augmented form of the UKF. In this form, the dynamics functions take additional input arguments that correspond to the noise terms. To enable this form, the typed constructor</p><pre><code class="nohighlight hljs">UnscentedKalmanFilter{inplace_dynamics,inplace_measurement,augmented_dynamics,augmented_measurement}(...)</code></pre><p>is used, where the Boolean type parameters have the following meaning</p><ul><li><code>inplace_dynamics</code>: If <code>true</code>, the dynamics function operates in-place, i.e., it modifies the first argument in <code>dynamics(dx, x, u, p, t)</code>. Default is <code>false</code>.</li><li><code>inplace_measurement</code>: If <code>true</code>, the measurement function operates in-place, i.e., it modifies the first argument in <code>measurement(y, x, u, p, t)</code>. Default is <code>false</code>.</li><li><code>augmented_dynamics</code>: If <code>true</code> the dynamics function is augmented with an additional noise input <code>w</code>, i.e., <code>dynamics(x, u, p, t, w)</code>. Default is <code>false</code>.</li><li><code>augmented_measurement</code>: If <code>true</code> the measurement function is agumented with an additional noise input <code>e</code>, i.e., <code>measurement(x, u, p, t, e)</code>. Default is <code>false</code>. (If the measurement noise has fewer degrees of freedom than the number of measurements, you may failure in Cholesky factorizations, see &quot;Custom Cholesky factorization&quot; below).</li></ul><p>Use of augmented dynamics incurs extra computational cost. The number of sigma points used is <code>2L+1</code> where <code>L</code> is the length of the augmented state vector. Without augmentation, <code>L = nx</code>, with augmentation <code>L = nx + nw</code> and <code>L = nx + ne</code> for dynamics and measurement, respectively.</p><p><strong>Weight tuning</strong></p><p>The spread of the sigma points is controlled by <code>weight_params::UTParams</code>. See <a href="https://baggepinnen.github.io/LowLevelParticleFilters.jl/dev/ut/">Docs: Unscented transform</a> for a tutorial. The default is <a href="#LowLevelParticleFilters.TrivialParams"><code>TrivialParams</code></a> for unweighted sigma points, other options are <a href="#LowLevelParticleFilters.WikiParams"><code>WikiParams</code></a> and <a href="#LowLevelParticleFilters.MerweParams"><code>MerweParams</code></a>.</p><p><strong>Sigma-point rejection</strong></p><p>For problems with challenging dynamics, a mechanism for rejection of sigma points after the dynamics update is provided. A function <code>reject(x) -&gt; Bool</code> can be provided through the keyword argument <code>reject</code> that returns <code>true</code> if a sigma point for <span>$x(t+1)$</span> should be rejected, e.g., if an instability or non-finite number is detected. A rejected point is replaced by the propagated mean point (the mean point cannot be rejected). This function may be provided either to the constructor of the UKF or passed to the <a href="#StatsAPI.predict!"><code>predict!</code></a> function.</p><p><strong>Enforcing contraints using sigma-point projection</strong></p><p>Constraints on the state (or output) may be enforced by projecting the sigma points onto the constraint set during the dynamics (or measurement) update. In general, two projections per update are required, one after the generation of the sigma points but before the dynamics is applied, and one after the dynamics update. No functionality for this is provided in this package, but the projection may be readibly implemented manually in the dynamics function, e.g.,</p><pre><code class="language-julia hljs">function dynamics(x, u, p, t)
    x  = project(x)  # Sigma points may have been generated outside the constraint set
    xp = f(x, u, p, t)
    xp = project(xp) # The dynamics may have moved the points outside the constraint set
    return xp
end</code></pre><p>Equality constraints can alternatively be handled by making use of a pseudo-measurement <span>$0 = C_{con}x$</span> with close to zero covariance.</p><p><strong>Custom measurement models</strong></p><p>By default, standard arithmetic mean and <code>e(y, yh) = y - yh</code> are used as mean and innovation functions.</p><p>By passing and explicitly created <a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a>, one may provide custom functions that compute the mean, the covariance and the innovation. This is useful in situations where the state or a measurement lives on a manifold. One may further override the mean and covariance functions for the state sigma points by passing the keyword arguments <code>state_mean</code> and <code>state_cov</code> to the constructor.</p><ul><li><code>state_mean(xs::AbstractVector{&lt;:AbstractVector}, w::UKFWeights)</code> computes the weighted mean of the vector of vectors of state sigma points.</li><li><code>state_cov(xs::AbstractVector{&lt;:AbstractVector}, m, w::UKFWeights)</code> where the first argument represent state sigma points and the second argument, represents the weighted mean of those points. The function should return the covariance matrix of the state sigma points weighted by <code>w</code>.</li></ul><p>See <a href="#LowLevelParticleFilters.UKFMeasurementModel-Union{Tuple{AUGM}, Tuple{IPM}, NTuple{8, Any}, NTuple{9, Any}, NTuple{10, Any}} where {IPM, AUGM}"><code>UKFMeasurementModel</code></a> for more details on how to set up a custom measurement model. Pass the custom measurement model as the second argument to the UKF constructor.</p><p><strong>Custom Cholesky factorization</strong></p><p>The UnscentedKalmanFilter supports providing a custom function to compute the Cholesky factorization of the covariance matrices for use in sigma-point generation.</p><p>If either of the following conditions are met, you may experience failure in internal Cholesky factorizations:</p><ul><li>The dynamics noise or measurement noise covariance matrices (<span>$R_1, R_2$</span>) are singular</li><li>The measurement is augmented and the measurement noise has fewer degrees of freedom than the number of measurements</li><li>(Under specific technical conditions) The dynamics is augmented and the dynamics noise has fewer degrees of freedom than the number of state variables. The technical conditions are easiest to understand in the linear-systems case, where it corresponds to the Riccati equation associated with the Kalman gain not having a solution. This may happen when the pair <span>$(A, R1)$</span> has uncontrollable modes on the unit circle, for example, when there are integrating modes that are not affected through the noise.</li></ul><p>The error message may look like</p><pre><code class="nohighlight hljs">ERROR: PosDefException: matrix is not positive definite; Factorization failed.</code></pre><p>In such situations, it is advicable to reconsider the noise model and covariance matrices, alternatively, you may provide a custom Cholesky factorization function to the UKF constructor through the keyword argument <code>cholesky!</code>. The function should have the signature <code>cholesky!(A::AbstractMatrix)::Cholesky</code>. A useful alternative factorizaiton when covariance matrices are expected to be singular is <code>cholesky! = R-&gt;cholesky!(Positive, Matrix(R))</code> where the &quot;positive&quot; Cholesky factorization is provided by the package PositiveFactorizations.jl, which must be manually installed and loaded by the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ukf.jl#L290-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.WikiParams" href="#LowLevelParticleFilters.WikiParams"><code>LowLevelParticleFilters.WikiParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WikiParams(; α = 1.0, β = 0.0, κ = 1.0)
WikiParams(; ακ = 1.0, β = 0.0) # Simplified interface with only one parameter for ακ</code></pre><p>Unscented transform parameters suggested at <a href="https://en.wikipedia.org/wiki/Kalman_filter#Sigma_points">Wiki: Kalman<em>filter#Sigma</em>points</a>.</p><ul><li><code>α</code>: Scaling parameter (0,1] for the spread of the sigma points. Reduce <code>α</code> to reduce the spread.</li><li><code>β</code>: Incorporates prior knowledge of the distribution of the state.</li><li><code>κ</code>: Secondary scaling parameter that is usually set to 3nx/2 or 1. Increase <code>κ</code> to increase the spread of the sigma points.</li></ul><p>If <span>$α^2 κ &lt; L$</span> where <span>$L$</span> is the dimension ofthe sigma points, the center mean weight is negative. This is allowed, but may in some cases lead to an indefinite covariance matrix.</p><p>The spread of the points are <span>$α^2 κ$</span>, that is, independent on the point dimension. Visualize the spread by</p><pre><code class="language-julia hljs">using Plots
μ = [0.0, 0.0]
Σ = [1.0 0.0; 0.0 1.0]
pars = LowLevelParticleFilters.WikiParams(α = 1.0, β = 0.0, κ = 1.0)
xs = LowLevelParticleFilters.sigmapoints(μ, Σ, pars)
unscentedplot(xs, pars)</code></pre><p>A simplified tuning rule </p><ul><li>If a decrease in the spread of the sigma points is desired, use <span>$κ = 1$</span> and <span>$α &lt; 1$</span>.</li><li>If an increase in the spread of the sigma points is desired, use <span>$κ &gt; 1$</span> and <span>$α = 1$</span>.</li></ul><p>This rule may be used when using the interface with only a single function argument <span>$ακ$</span>. See Nielsen, K. et al., 2021, &quot;UKF Parameter Tuning for Local Variation Smoothing&quot; for more details.</p><p>See also <a href="#LowLevelParticleFilters.MerweParams"><code>MerweParams</code></a> and <a href="#LowLevelParticleFilters.TrivialParams"><code>TrivialParams</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ukf.jl#L2-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.IteratedExtendedKalmanFilter" href="#LowLevelParticleFilters.IteratedExtendedKalmanFilter"><code>LowLevelParticleFilters.IteratedExtendedKalmanFilter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IteratedExtendedKalmanFilter(kf, dynamics, measurement; Ajac, Cjac, step, maxiters, epsilon)
IteratedExtendedKalmanFilter(dynamics, measurement, R1,R2,d0=SimpleMvNormal(Matrix(R1)); nu::Int, ny=size(R2,1), Cjac = nothing, step = 1.0, maxiters=10, epsilon=1e-8)</code></pre><p>A nonlinear state estimator propagating uncertainty using linearization. Returns an <code>ExtendedKalmanFilter</code> object but with Gauss-Newton based iterating measurement correction step.</p><p>The constructor to the iterated version of extended Kalman filter takes dynamics and measurement functions, and either covariance matrices, or a <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. If the former constructor is used, the number of inputs to the system dynamics, <code>nu</code>, must be explicitly provided with a keyword argument.</p><p>By default, the filter will internally linearize the dynamics using ForwardDiff. User provided Jacobian functions can be provided as keyword arguments <code>Ajac</code> and <code>Cjac</code>. These functions should have the signature <code>(x,u,p,t)::AbstractMatrix</code> where <code>x</code> is the state, <code>u</code> is the input, <code>p</code> is the parameters, and <code>t</code> is the time.</p><p>The dynamics and measurement function are of the following form</p><pre><code class="nohighlight hljs">x(t+1) = dynamics(x, u, p, t) + w
y      = measurement(x, u, p, t) + e</code></pre><p>where <code>w ~ N(0, R1)</code>, <code>e ~ N(0, R2)</code> and <code>x(0) ~ d0</code></p><ul><li><code>step</code> is the step size for the Gauss-Newton iterations. Float between 0 and 1. Default is 1.0 which should be good enough for most applications. For more challenging applications, a smaller step size might be necessary.</li><li><code>maxiters</code> is the maximum number of iterations. Default is 10. Usually a small number of iterations is needed. If higher number is needed, consider using UKF.</li><li><code>epsilon</code> is the convergence criterion. Default is 1e-8</li></ul><p>See also <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> which is more robust than <code>IteratedExtendedKalmanFilter</code>. See <a href="#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> for detailed instructions on how to set up a Kalman filter <code>kf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/iekf.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.combine!-Tuple{IMM}" href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>LowLevelParticleFilters.combine!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine!(imm::IMM)</code></pre><p>Combine the models of the IMM filter into a single state <code>imm.x</code> and covariance <code>imm.R</code>. This is done by taking a weighted average of the states and covariances of the individual models, where the weights are the mixing probabilities <code>μ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/imm.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.commandplot" href="#LowLevelParticleFilters.commandplot"><code>LowLevelParticleFilters.commandplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">commandplot(pf, u, y, p=parameters(pf); kwargs...)</code></pre><p>Produce a helpful plot. For customization options (<code>kwargs...</code>), see <code>?pplot</code>. After each time step, a command from the user is requested.</p><ul><li>q: quit</li><li>s n: step <code>n</code> steps</li></ul><div class="admonition is-info" id="Note-d6f7826f6f13af13"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d6f7826f6f13af13" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/LowLevelParticleFilters.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll, e = correct!(pf, u, y, p = parameters(f), t = index(f))</code></pre><p>Update state/weights based on measurement <code>y</code>,  returns log-likelihood and prediction error (the error is always 0 for particle filters).</p><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a>. For <a href="../#AdvancedParticleFilter"><code>AdvancedParticleFilter</code></a>, this can be realized by passing a custom <code>measurement_likelihood</code> function as the keyword argument <code>g</code> to <code>correct!</code>, or by calling the lower-level function <code>measurement_equation!</code> with a custom <code>measurement_likelihood</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L135-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correct!(kf::SqKalmanFilter, u, y, p = parameters(kf), t::Real = index(kf); R2 = get_mat(kf.R2, kf.x, u, p, t))</code></pre><p>For the square-root Kalman filter, a custom provided <code>R2</code> must be the upper triangular Cholesky factor of the covariance matrix of the measurement noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_kalman.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!" href="#LowLevelParticleFilters.correct!"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(; ll, e, S, Sᵪ, K) = correct!(kf::AbstractKalmanFilter, u, y, p = parameters(kf), t::Integer = index(kf), R2)</code></pre><p>The correct step for a Kalman filter returns not only the log likelihood <code>ll</code> and the prediction error <code>e</code>, but also the covariance of the output <code>S</code>, its Cholesky factor <code>Sᵪ</code> and the Kalman gain <code>K</code>.</p><p>If <code>R2</code> stored in <code>kf</code> is a function <code>R2(x, u, p, t)</code>, this function is evaluated at the state <em>before</em> the correction is performed. The measurement noise covariance matrix <code>R2</code> stored in the filter object can optionally be overridden by passing the argument <code>R2</code>, in this case <code>R2</code> must be a matrix.</p><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L81-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}" href="#LowLevelParticleFilters.correct!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll, lls, rest = correct!(imm::IMM, u, y, args; kwargs)</code></pre><p>The correct step of the IMM filter corrects each model with the measurements <code>y</code> and control input <code>u</code>. The mixing probabilities <code>imm.μ</code> are updated based on the likelihood of each model given the measurements and the transition probability matrix <code>P</code>.</p><p>The returned tuple consists of the sum of the log-likelihood of all models, the vector of individual log-likelihoods and an array of the rest of the return values from the correct step of each model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/imm.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!-Tuple{SqExtendedKalmanFilter, Any, Any, Any, Real}" href="#LowLevelParticleFilters.correct!-Tuple{SqExtendedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correct!(kf::SqExtendedKalmanFilter, u, y, p, t; R2)</code></pre><p>Correction step for the Square-root Extended Kalman Filter. Linearizes the measurement and updates the state and Cholesky factor of covariance using QR decomposition.</p><p>If a custom <code>R2</code> is provided, it must be the upper triangular Cholesky factor (of type <code>UpperTriangular</code>) of the covariance matrix of the measurement noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_ekf.jl#L187-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}" href="#LowLevelParticleFilters.correct!-Tuple{UnscentedKalmanFilter, Any, Any, Any, Real}"><code>LowLevelParticleFilters.correct!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correct!(ukf::UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, u, y, p = parameters(ukf), t::Real = index(ukf) * ukf.Ts; R2 = get_mat(ukf.R2, ukf.x, u, p, t), mean, cross_cov, innovation)</code></pre><p>The correction step for an <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> allows the user to override, <code>R2</code>, <code>mean</code>, <code>cross_cov</code>, <code>innovation</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>u</code>: The input</li><li><code>y</code>: The measurement</li><li><code>p</code>: The parameters</li><li><code>t</code>: The current time</li><li><code>R2</code>: The measurement noise covariance matrix, or a function that returns the covariance matrix <code>(x,u,p,t)-&gt;R2</code>.</li><li><code>mean</code>: The function that computes the weighted mean of the output sigma points.</li><li><code>cross_cov</code>: The function that computes the weighted cross-covariance of the state and output sigma points.</li><li><code>innovation</code>: The function that computes the innovation between the measured output and the predicted output.</li></ul><p><strong>Extended help</strong></p><p>To perform separate measurement updates for different sensors, see the <a href="../measurement_models/#measurement_models">&quot;Measurement models&quot; in the documentation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ukf.jl#L608-L625">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.covplot" href="#LowLevelParticleFilters.covplot"><code>LowLevelParticleFilters.covplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">covplot(μ, Σ; n_std = 2, dims=1:2)
covplot(kf; n_std = 2, dims=1:2)</code></pre><p>Plot the covariance ellipse of the state <code>μ</code> and covariance <code>Σ</code>. <code>dims</code> indicate the two dimensions to plot, and defaults to the first two dimensions.</p><p>If a Kalman-type filter is passed, the state and covariance are extracted from the filter.</p><p>See also <code>unscentedplot</code>.</p><div class="admonition is-info" id="Note-d6f7826f6f13af13"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d6f7826f6f13af13" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/LowLevelParticleFilters.jl#L142-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.debugplot" href="#LowLevelParticleFilters.debugplot"><code>LowLevelParticleFilters.debugplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">debugplot(pf, u, y, p=parameters(pf); runall=false, kwargs...)</code></pre><p>Produce a helpful plot. For customization options (<code>kwargs...</code>), see <code>?pplot</code>.</p><ul><li><code>runall=false:</code> if true, runs all time steps befor displaying (faster), if false, displays the plot after each time step.</li></ul><p>The generated plot becomes quite heavy. Initially, try limiting your input to 100 time steps to verify that it doesn&#39;t crash.</p><div class="admonition is-info" id="Note-d6f7826f6f13af13"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d6f7826f6f13af13" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/LowLevelParticleFilters.jl#L111-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.densityplot" href="#LowLevelParticleFilters.densityplot"><code>LowLevelParticleFilters.densityplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">densityplot(x,[w])</code></pre><p>Plot (weighted) particles densities</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/plotting.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.double_integrator_covariance" href="#LowLevelParticleFilters.double_integrator_covariance"><code>LowLevelParticleFilters.double_integrator_covariance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R = double_integrator_covariance(Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time integrator with piecewise constant stochastic force as input. <code>Ts</code> is the sample time. <code>σ2</code> scales the covariance matrix with the variance of the noise.</p><p>The state is assumed to be [x; ẋ] and the dynamics</p><p class="math-container">\[x^+ = Ax + Bu + w\]</p><p>where the noise input <code>w</code> has not been included in the discretization process.</p><p>This matrix is rank deficient and some applications might require a small increase in the diagonal to make it positive definite (or use <a href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>double_integrator_covariance_smooth</code></a>).</p><p>See also <a href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>double_integrator_covariance_smooth</code></a> for the version that does not assume piecewise constant noise, leading to a full-rank covariance matrix that results in sample-time invariant covariance dynamics (often favorable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/utils.jl#L115-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.double_integrator_covariance_smooth" href="#LowLevelParticleFilters.double_integrator_covariance_smooth"><code>LowLevelParticleFilters.double_integrator_covariance_smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R = double_integrator_covariance_smooth(Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time integrator with continuous noise as input. Assumes the state [x; ẋ]. <code>Ts</code> is the sample time. <code>σ2</code> scales the covariance matrix with the variance of the noise.</p><p>This matrix is full rank, but can be well approximated by a rank-1 matrix as <code>double_integrator_covariance(Ts, σ2) ./ Ts</code>.</p><p>To make use of a single random number per step for augmented UKFs, but be have a resulting covariance dynamics that is approximately invariant to the sample interval, you can use the scalar noise <code>σ2 / Ts</code> instead of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/utils.jl#L169-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.forward_trajectory" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sol = forward_trajectory(kf::AbstractKalmanFilter, u::Vector, y::Vector, p=parameters(kf); debug=false)</code></pre><p>Run a Kalman filter forward to perform (offline / batch) filtering along an entire trajectory <code>u, y</code>.</p><p>Returns a KalmanFilteringSolution: with the following</p><ul><li><code>x</code>: predictions <span>$x(t|t-1)$</span></li><li><code>xt</code>: filtered estimates <span>$x(t|t)$</span></li><li><code>R</code>: predicted covariance matrices <span>$R(t|t-1)$</span></li><li><code>Rt</code>: filter covariances <span>$R(t|t)$</span></li><li><code>ll</code>: loglik</li></ul><p><code>sol</code> can be plotted</p><pre><code class="nohighlight hljs">plot(sol::KalmanFilteringSolution; plotx = true, plotxt=true, plotu=true, ploty=true)</code></pre><p>See <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> for more details.</p><p><strong>Extended help</strong></p><p><strong>Very large systems</strong></p><p>If your system is very large, i.e., the dimension of the state is very large, and the arrays <code>u,y</code> are long, this function may use a lot of memory to store all covariance matrices <code>R, Rt</code>. If you do not need all the information retained by this function, you may opt to call one of the functions</p><ul><li><a href="#LowLevelParticleFilters.loglik"><code>loglik</code></a></li><li><a href="@ref"><code>LowLevelParticleFilters.sse</code></a></li><li><a href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a></li></ul><p>That store significantly less information. The amount of computation performed by all of these functions is identical, the only difference lies in what is stored and returned.</p><p><strong>Callbacks</strong></p><p>For advanced usage, such as implementing conditional resetting and adaptive covariance, one may make use of the callback functions</p><ul><li><code>pre_correct_cb(kf, u, y, p, t)</code>: called before the correction step, returns either <code>nothing</code> or a covariance matrix <code>R2</code> to use in the correction step.</li><li><code>pre_predict_cb(kf, u, y, p, t, ll, e, S, Sᵪ)</code>: called before the prediction step, returns either <code>nothing</code> or a covariance matrix <code>R1</code> to use in the prediction step. The arguments to this callback are <code>filter, input, measurement, parameters, time, loglikelihood, prediction error, innovation covariance and Cholesky factor of the innovation covariance</code>, essentially all the information available after the correct step.</li></ul><p>The filter loop consists of the following steps, in this order:</p><ol><li><code>pre_correct_cb</code></li><li><code>correct!</code></li><li><code>pre_predict_cb</code></li><li><code>predict!</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L222-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.forward_trajectory" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sol = forward_trajectory(pf, u::AbstractVector, y::AbstractVector, p=parameters(pf))</code></pre><p>Run the particle filter for a sequence of inputs and measurements (offline / batch filtering). Return a solution with <code>x,w,we,ll = particles, weights, expweights and loglikelihood</code></p><p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, you may transform the output particles to <code>Matrix{MonteCarloMeasurements.Particles}</code> using <code>Particles(x,we)</code>. Internally, the particles are then resampled such that they all have unit weight. This is conventient for making use of the <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/stable/#Plotting-1">plotting facilities of MonteCarloMeasurements.jl</a>.</p><p><code>sol</code> can be plotted</p><pre><code class="nohighlight hljs">plot(sol::ParticleFilteringSolution; nbinsy=30, xreal=nothing, dim=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L306-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.forward_trajectory" href="#LowLevelParticleFilters.forward_trajectory"><code>LowLevelParticleFilters.forward_trajectory</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">forward_trajectory(imm::IMM, u, y, p = parameters(imm); interact = true)</code></pre><p>When performing batch filtering using an <a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter, one may</p><ul><li>Override the <code>interact</code> parameter of the filter</li><li>Access the mode probabilities along the trajectory as the <code>sol.extra</code> field. This is a matrix of size <code>(n_modes, T)</code> where <code>T</code> is the length of the trajectory (length of <code>u</code> and <code>y</code>).</li></ul><p>The returned solution object is of type <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> and has the following fields:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/imm.jl#L257-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.interact!-Tuple{IMM}" href="#LowLevelParticleFilters.interact!-Tuple{IMM}"><code>LowLevelParticleFilters.interact!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact!(imm::IMM)</code></pre><p>The interaction step of the IMM filter updates the state and covariance of each internal model based on the mixing probabilities <code>imm.μ</code> and the transition probability matrix <code>imm.P</code>.</p><p>Models with small mixing probabilities will have their states and covariances updated more towards the states and covariances of models with higher mixing probabilities, and vice versa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/imm.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Vararg{Any}}" href="#LowLevelParticleFilters.log_likelihood_fun-Tuple{Any, AbstractVector, Vararg{Any}}"><code>LowLevelParticleFilters.log_likelihood_fun</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll(θ) = log_likelihood_fun(filter_from_parameters(θ::Vector)::Function, priors::Vector{Distribution}, u, y, p)
ll(θ) = log_likelihood_fun(filter_from_parameters(θ::Vector)::Function, priors::Vector{Distribution}, u, y, x, p)</code></pre><p>returns function θ -&gt; p(y|θ)p(θ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.loglik" href="#LowLevelParticleFilters.loglik"><code>LowLevelParticleFilters.loglik</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll = loglik(filter, u, y, p=parameters(filter))</code></pre><p>Calculate log-likelihood for entire sequences <code>u,y</code>.</p><p>See also <a href="#LowLevelParticleFilters.loglik_x"><code>loglik_x</code></a> for Kalman-type filters when an accurate state sequence <code>x</code> is available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L187-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.loglik_x" href="#LowLevelParticleFilters.loglik_x"><code>LowLevelParticleFilters.loglik_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll = loglik_x(kf, u, y, x, p=parameters(kf))</code></pre><p>For Kalman-type filters when an accurate state sequence <code>x</code> is available, such as when data is obtained from a simulation or in a lab setting, the log-likelihood can be calculated using the state prediction errors rather than the output prediction errors. In this case, <code>logpdf(f.R, x-x̂)</code> is used rather than <code>logpdf(S, y-ŷ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.logsumexp!" href="#LowLevelParticleFilters.logsumexp!"><code>LowLevelParticleFilters.logsumexp!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll = logsumexp!(w, we [, maxw])</code></pre><p>Normalizes the weight vector <code>w</code> and returns the weighted log-likelihood</p><p>https://arxiv.org/pdf/1412.8695.pdf eq 3.8 for p(y) https://discourse.julialang.org/t/fast-logsumexp/22827/7?u=baggepinnen for stable logsumexp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/utils.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.mean_trajectory-Tuple{Any, Vector, Vector}" href="#LowLevelParticleFilters.mean_trajectory-Tuple{Any, Vector, Vector}"><code>LowLevelParticleFilters.mean_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x,ll = mean_trajectory(pf, u::Vector{Vector}, y::Vector{Vector}, p=parameters(pf))</code></pre><p>This method resets the particle filter to the initial state distribution upon start</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}" href="#LowLevelParticleFilters.mean_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mean_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_trajectory(sol::ParticleFilteringSolution)
mean_trajectory(x::AbstractMatrix, we::AbstractMatrix)</code></pre><p>Compute the weighted mean along the trajectory of a particle-filter solution. Returns a matrix of size <code>T × nx</code>. If <code>x</code> and <code>we</code> are supplied, the weights are expected to be in the original space (not log space).</p><p>See also <a href="#LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}"><code>mode_trajectory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L367-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.metropolis" href="#LowLevelParticleFilters.metropolis"><code>LowLevelParticleFilters.metropolis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metropolis(ll::Function(θ), R::Int, θ₀::Vector, draw::Function(θ) = naive_sampler(θ₀))</code></pre><p>Performs MCMC sampling using the marginal Metropolis (-Hastings) algorithm <code>draw = θ -&gt; θ&#39;</code> samples a new parameter vector given an old parameter vector. The distribution must be symmetric, e.g., a Gaussian. <code>R</code> is the number of iterations. See <code>log_likelihood_fun</code></p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">filter_from_parameters(θ) = ParticleFilter(N, dynamics, measurement, MvNormal(n,exp(θ[1])), MvNormal(p,exp(θ[2])), d0)
priors = [Normal(0,0.1),Normal(0,0.1)]
ll     = log_likelihood_fun(filter_from_parameters,priors,u,y,1)
θ₀ = log.([1.,1.]) # Initial point
draw = θ -&gt; θ .+ rand(MvNormal(0.1ones(2))) # Function that proposes new parameters (has to be symmetric)
burnin = 200 # If using threaded call, provide number of burnin iterations
# @time theta, lls = metropolis(ll, 2000, θ₀, draw) # Run single threaded
# thetam = reduce(hcat, theta)&#39;
@time thetalls = LowLevelParticleFilters.metropolis_threaded(burnin, ll, 5000, θ₀, draw) # run on all threads, will provide (2000-burnin)*nthreads() samples
histogram(exp.(thetalls[:,1:2]), layout=3)
plot!(thetalls[:,3], subplot=3) # if threaded call, log likelihoods are in the last column</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L257-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}" href="#LowLevelParticleFilters.mode_trajectory-Tuple{ParticleFilteringSolution}"><code>LowLevelParticleFilters.mode_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mode_trajectory(sol::ParticleFilteringSolution)
mode_trajectory(x::AbstractMatrix, we::AbstractMatrix)</code></pre><p>Compute the mode (particle with largest weight) along the trajectory of a particle-filter solution. Returns a matrix of size <code>T × nx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L379-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.n_integrator_covariance" href="#LowLevelParticleFilters.n_integrator_covariance"><code>LowLevelParticleFilters.n_integrator_covariance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R = n_integrator_covariance(n, Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time n-integrator with piecewise constant stochastic (generalized) force as input.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Order of the integrator (state dimension)</li><li><code>Ts</code>: Sample time</li><li><code>σ2</code>: Variance of driving noise</li></ul><p>The state is assumed to be <a href="n dimensional">x; ẋ; ẍ; ...</a> and the dynamics follow</p><p class="math-container">\[x^+ = Ax + Bu + w\]</p><p>where the noise input <code>w</code> has not been included in the discretization process.</p><p>This matrix is rank deficient and some applications might require a small increase in the diagonal to make it positive definite (or use <a href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>n_integrator_covariance_smooth</code></a>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">R = n_integrator_covariance(3, 0.1)  # 3rd order integrator with Ts=0.1</code></pre><p>See also <a href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>n_integrator_covariance_smooth</code></a> for the version that does not assume piecewise constant noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/utils.jl#L136-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n" href="#LowLevelParticleFilters.n_integrator_covariance_smooth-Union{Tuple{n}, Tuple{Val{n}, Any}, Tuple{Val{n}, Any, Any}} where n"><code>LowLevelParticleFilters.n_integrator_covariance_smooth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R = n_integrator_covariance_smooth(n, Ts, σ2=1)
R = n_integrator_covariance_smooth(Val(n), Ts, σ2=1)</code></pre><p>Returns the covariance matrix of a discrete-time n-integrator with continuous noise as input.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Order of the integrator (state dimension), can be provided as <code>Int</code> or <code>Val{n}</code></li><li><code>Ts</code>: Sample time  </li><li><code>σ2</code>: Variance of driving noise (default: 1)</li></ul><p>The state is assumed to be <a href="n dimensional">x; ẋ; ẍ; ...</a>. This assumes continuous white noise  driving the highest derivative, integrated over the sample interval.</p><p>This matrix is full rank, which is often favorable for numerical stability. The resulting  covariance dynamics are approximately invariant to the sample interval.</p><p>Formally, <span>$R$</span> is the solution to the fixed-horizon Lyapunov equation with the dynamics given by an n-th order integrator.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">R = n_integrator_covariance_smooth(3, 0.1)  # 3rd order integrator with Ts=0.1
R = n_integrator_covariance_smooth(Val(3), 0.1)  # Compile-time known dimension</code></pre><p>See also <a href="#LowLevelParticleFilters.n_integrator_covariance"><code>n_integrator_covariance</code></a> for the version that assumes piecewise constant noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/utils.jl#L184-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}" href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(kf::AbstractKalmanFilter; x0)</code></pre><p>Reset the initial distribution of the state. Optionally, a new mean vector <code>x0</code> can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/kalman.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}" href="#LowLevelParticleFilters.reset!-Tuple{LowLevelParticleFilters.AbstractParticleFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Reset the filter to initial state and covariance/distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}" href="#LowLevelParticleFilters.reset!-Tuple{SqKalmanFilter}"><code>LowLevelParticleFilters.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(kf::SqKalmanFilter; x0)</code></pre><p>Reset the initial distribution of the state. Optionally, a new mean vector <code>x0</code> can be provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_kalman.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.simulate" href="#LowLevelParticleFilters.simulate"><code>LowLevelParticleFilters.simulate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x,u,y = simulate(f::AbstractFilter, T::Int, du::Distribution, p=parameters(f), [N]; dynamics_noise=true, measurement_noise=true)
x,u,y = simulate(f::AbstractFilter, u, p=parameters(f); dynamics_noise=true, measurement_noise=true)</code></pre><p>Simulate dynamical system forward in time <code>T</code> steps, or for the duration of <code>u</code>. Returns state sequence, inputs and measurements.</p><ul><li><code>u</code> is an input-signal trajectory, alternatively, <code>du</code> is a distribution of random inputs.</li></ul><p>A simulation can be considered a draw from the prior distribution over the evolution of the system implied by the selected noise models. Such a simulation is useful in order to evaluate whether or not the noise models are reasonable.</p><p>If <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a> is loaded, the argument <code>N::Int</code> can be supplied, in which case <code>N</code> simulations are done and the result is returned in the form of <code>Vector{MonteCarloMeasurements.Particles}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L411-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smooth" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sol = smooth(filtersol)
sol = smooth(kf::AbstractKalmanFilter, u::Vector, y::Vector, p=parameters(kf))</code></pre><p>Returns a <a href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>KalmanSmoothingSolution</code></a> with smoothed estimates of state <code>xT</code> and covariance <code>RT</code> given all input output data <code>u,y</code> or an existing filtering solution <code>filtersol</code> obtained from <a href="#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>.</p><p>The return smoothing can be plotted using <code>plot(sol)</code>, see <a href="#LowLevelParticleFilters.KalmanSmoothingSolution"><code>KalmanSmoothingSolution</code></a> and <a href="#LowLevelParticleFilters.KalmanFilteringSolution"><code>KalmanFilteringSolution</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smooth" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth(sol, kf::SqExtendedKalmanFilter, u, y, p)</code></pre><p>Performs Rauch-Tung-Striebel smoothing for the Square-root Extended Kalman Filter. Returns smoothed states and covariance matrices (converted from Cholesky factors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_ekf.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smooth" href="#LowLevelParticleFilters.smooth"><code>LowLevelParticleFilters.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xb,ll = smooth(pf, M, u, y, p=parameters(pf))
xb,ll = smooth(pf, xf, wf, wef, ll, M, u, y, p=parameters(pf))</code></pre><p>Perform particle smoothing using forward-filtering, backward simulation. Return smoothed particles and loglikelihood. See also <a href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>smoothed_trajs</code></a>, <a href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>smoothed_mean</code></a>, <a href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>smoothed_cov</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L107-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smoothed_cov-Tuple{Any}" href="#LowLevelParticleFilters.smoothed_cov-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_cov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothed_cov(xb)</code></pre><p>Helper function to calculate the covariance of smoothed particle trajectories</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L331-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smoothed_mean-Tuple{Any}" href="#LowLevelParticleFilters.smoothed_mean-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothed_mean(xb)</code></pre><p>Helper function to calculate the mean of smoothed particle trajectories</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.smoothed_trajs-Tuple{Any}" href="#LowLevelParticleFilters.smoothed_trajs-Tuple{Any}"><code>LowLevelParticleFilters.smoothed_trajs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smoothed_trajs(xb)</code></pre><p>Helper function to get particle trajectories as a 3-dimensions array (N,M,T) instead of matrix of vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L342-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.unscentedplot" href="#LowLevelParticleFilters.unscentedplot"><code>LowLevelParticleFilters.unscentedplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unscentedplot(ukf;          n_std = 2, N = 100, dims=1:2)
unscentedplot(sigmapoints;  n_std = 2, N = 100, dims=1:2)</code></pre><p>Plot the sigma points and their corresponding covariance ellipse. <code>dims</code> indicate the two dimensions to plot, and defaults to the first two dimensions.</p><p>If an UKF is passed, the sigma points after the last dynamics update are extracted from the filter. To plot the sigma points of the output, pass those in manually, they are available as <code>ukf.measurement_model.cache.x0</code> and <code>ukf.measurement_model.cache.x1</code>, denoting the input and output points of the measurement model.</p><p>Note: The covariance of the sigma points does not in general equal the predicted covariance of the state, since the state covariance is updated as <code>cov(sigmapoints) + R1</code>. Only when <code>AUGD = true</code> (augmented dynamics), the covariance of the state is given by the first <code>nx</code> sigmapoints.</p><p>See also <code>covplot</code>.</p><div class="admonition is-info" id="Note-d6f7826f6f13af13"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d6f7826f6f13af13" title="Permalink"></a></header><div class="admonition-body"><p>This function requires <code>using Plots</code> to be called before it is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/LowLevelParticleFilters.jl#L124-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.update!" href="#LowLevelParticleFilters.update!"><code>LowLevelParticleFilters.update!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ll, e = update!(f::AbstractFilter, u, y, p = parameters(f), t = index(f))</code></pre><p>Perform one step of <code>predict!</code> and <code>correct!</code>, returns log-likelihood and prediction error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}" href="#LowLevelParticleFilters.update!-Tuple{IMM, Any, Any, Vararg{Any}}"><code>LowLevelParticleFilters.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(imm::IMM, u, y, p, t; correct_kwargs = (;), predict_kwargs = (;), interact = true)</code></pre><p>The combined udpate for an <a href="#LowLevelParticleFilters.IMM-Tuple{Any, AbstractMatrix, AbstractVector}"><code>IMM</code></a> filter performs the following steps:</p><ol><li>Correct each model with the measurements <code>y</code> and control input <code>u</code>.</li><li>Combine the models into a single state and covariance.</li><li>Interact the models to update their respective state and covariance.</li><li>Predict each model to the next time step.</li></ol><p>This differs slightly from the udpate step of other filters, where at the end of an update the state of the filter is the one-step ahead <em>predicted</em> value, whereas here each individual filter has a predicted state, but the <a href="#LowLevelParticleFilters.combine!-Tuple{IMM}"><code>combine!</code></a> step of the IMM filter hasn&#39;t been performed on the predictions yet. The state of the IMM filter is thus <span>$x(t|t)$</span> and not <span>$x(t+1|t)$</span> like it is for other filters, and each filter internal to the IMM.</p><p><strong>Arguments:</strong></p><ul><li><code>correct_kwargs</code>: An optional named tuple of keyword arguments that are sent to <a href="#LowLevelParticleFilters.correct!"><code>correct!</code></a>.</li><li><code>predict_kwargs</code>: An optional named tuple of keyword arguments that are sent to <a href="#StatsAPI.predict!"><code>predict!</code></a>.</li><li><code>interact</code>: Whether or not to run the interaction step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/imm.jl#L193-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}" href="#LowLevelParticleFilters.weighted_cov-Tuple{Any, Any}"><code>LowLevelParticleFilters.weighted_cov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_cov(x,we)</code></pre><p>Similar to <a href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>weighted_mean</code></a>, but returns covariances</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L488-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}" href="#LowLevelParticleFilters.weighted_mean-Tuple{Any, AbstractVector}"><code>LowLevelParticleFilters.weighted_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x̂ = weighted_mean(x,we)</code></pre><p>Calculated weighted mean of particle trajectories. <code>we</code> are expweights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L454-L458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.weighted_mean-Tuple{Any}" href="#LowLevelParticleFilters.weighted_mean-Tuple{Any}"><code>LowLevelParticleFilters.weighted_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x̂ = weighted_mean(pf)
x̂ = weighted_mean(s::PFstate)</code></pre><p>See also <a href="#LowLevelParticleFilters.mean_trajectory-Tuple{Any, Vector, Vector}"><code>mean_trajectory</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L479-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.weighted_quantile-Tuple{Any, Any, Any}" href="#LowLevelParticleFilters.weighted_quantile-Tuple{Any, Any, Any}"><code>LowLevelParticleFilters.weighted_quantile</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_quantile(x,we,q)
weighted_quantile(sol,q)</code></pre><p>Calculated weighted quantile <code>q</code> of particle trajectories. <code>we</code> are expweights. Returns a vector of length <code>size(x, 2)</code> where each entry has length <code>nx</code>. For a particle-filtering solution, this means the vector will be as long as the number of time steps in the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L504-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(kf::AbstractKalmanFilter, u, p = parameters(kf), t::Integer = index(kf); R1, α = kf.α)</code></pre><p>Perform the prediction step (updating the state estimate to <span>$x(t+1|t)$</span>). If <code>R1</code> stored in <code>kf</code> is a function <code>R1(x, u, p, t)</code>, this function is evaluated at the state <em>before</em> the prediction is performed. The dynamics noise covariance matrix <code>R1</code> stored in <code>kf</code> can optionally be overridden by passing the argument <code>R1</code>, in this case <code>R1</code> must be a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(f, u, p = parameters(f), t = index(f))</code></pre><p>Move filter state forward in time using dynamics equation and input vector <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/filtering.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!" href="#StatsAPI.predict!"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(kf::SqKalmanFilter, u, p = parameters(kf), t::Real = index(kf); R1 = get_mat(kf.R1, kf.x, u, p, t), α = kf.α)</code></pre><p>For the square-root Kalman filter, a custom provided <code>R1</code> must be the upper triangular Cholesky factor of the covariance matrix of the process noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_kalman.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!-Union{Tuple{CF}, Tuple{MF}, Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM, MF, CF}" href="#StatsAPI.predict!-Union{Tuple{CF}, Tuple{MF}, Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any}, Tuple{UnscentedKalmanFilter{IPD, IPM, AUGD, AUGM}, Any, Any, Real}} where {IPD, IPM, AUGD, AUGM, MF, CF}"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(ukf::UnscentedKalmanFilter, u, p = parameters(ukf), t::Real = index(ukf) * ukf.Ts; R1 = get_mat(ukf.R1, ukf.x, u, p, t), reject, mean, cov, dynamics)</code></pre><p>The prediction step for an <a href="#LowLevelParticleFilters.UnscentedKalmanFilter-Union{Tuple{AUGM}, Tuple{AUGD}, Tuple{IPM}, Tuple{IPD}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any}, Tuple{Any, LowLevelParticleFilters.AbstractMeasurementModel, Any, Any}} where {IPD, IPM, AUGD, AUGM}"><code>UnscentedKalmanFilter</code></a> allows the user to override, <code>R1</code> and any of the functions, reject, mean, cov, dynamics`.</p><p><strong>Arguments:</strong></p><ul><li><code>u</code>: The input</li><li><code>p</code>: The parameters</li><li><code>t</code>: The current time</li><li><code>R1</code>: The dynamics noise covariance matrix, or a function that returns the covariance matrix.</li><li><code>reject</code>: A function that takes a sigma point and returns <code>true</code> if it should be rejected.</li><li><code>mean</code>: The function that computes the mean of the state sigma points.</li><li><code>cov</code>: The function that computes the covariance of the state sigma points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/ukf.jl#L447-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.predict!-Union{Tuple{IPD}, Tuple{SqExtendedKalmanFilter{IPD}, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any, Real}} where IPD" href="#StatsAPI.predict!-Union{Tuple{IPD}, Tuple{SqExtendedKalmanFilter{IPD}, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any}, Tuple{SqExtendedKalmanFilter{IPD}, Any, Any, Real}} where IPD"><code>StatsAPI.predict!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict!(kf::SqExtendedKalmanFilter, u, p, t; R1, α)</code></pre><p>Prediction step for the Square-root Extended Kalman Filter. Linearizes the dynamics and updates the state and Cholesky factor of covariance using QR decomposition.</p><p>If a custom <code>R1</code> is provided, it must be the upper triangular Cholesky factor (of type <code>UpperTriangular</code>) of the covariance matrix of the process noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/sq_ekf.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelParticleFilters.prediction_errors!" href="#LowLevelParticleFilters.prediction_errors!"><code>LowLevelParticleFilters.prediction_errors!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prediction_errors!(res, f::AbstractFilter, u, y, p = parameters(f), λ = 1)</code></pre><p>Calculate the prediction errors and store the result in <code>res</code>. Similar to <a href="@ref"><code>sse</code></a>, this function is useful for sum-of-squares optimization. In contrast to <code>sse</code>, this function returns the residuals themselves rather than their sum of squares. This is useful for Gauss-Newton style optimizers, such as <a href="https://github.com/matthieugomez/LeastSquaresOptim.jl">LeastSquaresOptim.LevenbergMarquardt</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>res</code>: A vector of length <code>ny*length(y)</code>. Note, for each datapoint in <code>u</code> and <code>u</code>, there are <code>ny</code> outputs, and thus <code>ny</code> residuals.</li><li><code>f</code>: Any filter</li><li><code>λ</code>: A weighting factor to minimize <code>dot(e, λ, e</code>). A commonly used metric is <code>λ = Diagonal(1 ./ (mag.^2))</code>, where <code>mag</code> is a vector of the &quot;typical magnitude&quot; of each output. Internally, the square root of <code>W = sqrt(λ)</code> is calculated so that the residuals stored in <code>res</code> are <code>W*e</code>.</li></ul><p>See example in <a href="../parameter_estimation/#Solving-using-Gauss-Newton-optimization">Solving using Gauss-Newton optimization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/206235e65214d64dea42b1102aaadb876ac4d2da/src/smoothing.jl#L160-L171">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sample_rate/">« Influence of sample rate on performance</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 31 August 2025 11:00">Sunday 31 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
