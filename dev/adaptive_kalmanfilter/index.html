<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kalman-filter tutorial with LowLevelParticleFilters · LowLevelParticleFilters Documentation</title><meta name="title" content="Kalman-filter tutorial with LowLevelParticleFilters · LowLevelParticleFilters Documentation"/><meta property="og:title" content="Kalman-filter tutorial with LowLevelParticleFilters · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="Kalman-filter tutorial with LowLevelParticleFilters · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../measurement_models/">Multiple measurement models</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Kalman-filter tutorial with LowLevelParticleFilters</a><ul class="internal"><li><a class="tocitem" href="#Data-generation"><span>Data generation</span></a></li><li><a class="tocitem" href="#Simple-Kalman-filtering"><span>Simple Kalman filtering</span></a></li><li><a class="tocitem" href="#Adaptive-noise-covariance"><span>Adaptive noise covariance</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#Disturbance-modeling-and-noise-tuning"><span>Disturbance modeling and noise tuning</span></a></li></ul></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="../beetle_example_imm/">IMM-filter tutorial</a></li><li><a class="tocitem" href="../rbpf_example/">Rao-Blackwellized PF tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li><li><a class="tocitem" href="../adaptive_control/">Adaptive estimation and control</a></li><li><a class="tocitem" href="../neural_network/">Adaptive Neural-Network training</a></li><li><a class="tocitem" href="../friction_nn_example/">SciML: Adaptive Universal Differential Equation</a></li><li><a class="tocitem" href="../thermal_nn_example/">SciML: Learning a sunshine disturbance model</a></li><li><a class="tocitem" href="../fault_detection/">Fault detection</a></li><li><a class="tocitem" href="../ut/">Unscented transform</a></li><li><a class="tocitem" href="../disturbance_gallery/">Disturbance gallery</a></li><li><a class="tocitem" href="../sample_rate/">Influence of sample rate on performance</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Kalman-filter tutorial with LowLevelParticleFilters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Kalman-filter tutorial with LowLevelParticleFilters</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/adaptive_kalmanfilter.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Noise-adaptive-Kalman-filter"><a class="docs-heading-anchor" href="#Noise-adaptive-Kalman-filter">Noise-adaptive Kalman filter</a><a id="Noise-adaptive-Kalman-filter-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-adaptive-Kalman-filter" title="Permalink"></a></h1><p>In this tutorial we will consider filtering of a 1D position track, similar in spirit to what one could have obtained from a GPS device, but limited to 1D for easier visualization. We will use a constant-velocity model, i.e., use a double integrator,</p><p class="math-container">\[\begin{aligned}
x_{k+1} &amp;= \begin{bmatrix} 1 &amp; T_s \\ 0 &amp; 1 \end{bmatrix} x_k + \begin{bmatrix} T_s^2/2 \\ T_s \end{bmatrix} w_k \\
y_k &amp;= \begin{bmatrix} 1 &amp; 0 \end{bmatrix} x_k + v_k
\end{aligned}\]</p><p>where <span>$w_k \sim \mathcal{N}(0, σ_w)$</span> is the process noise, and <span>$v_k \sim \mathcal{N}(0, R_2)$</span> is the measurement noise, and illustrate how we can make use of an adaptive noise covariance to improve the filter performance.</p><h2 id="Data-generation"><a class="docs-heading-anchor" href="#Data-generation">Data generation</a><a id="Data-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-generation" title="Permalink"></a></h2><p>We start by generating some position data that we want to perform filtering on. The &quot;object&quot; we want to track is initially stationary, and transitions to moving with a constant velocity after a while. </p><pre><code class="language-julia hljs">using LowLevelParticleFilters, Plots, Random
Random.seed!(1)

# Create a time series for filtering
x = [zeros(50); 0:100]
T = length(x)
Y = x + randn(T)
plot([Y x], lab=[&quot;Measurement&quot; &quot;True state to be tracked&quot;], c=[1 :purple])</code></pre><img src="dac626bb.svg" alt="Example block output"/><h2 id="Simple-Kalman-filtering"><a class="docs-heading-anchor" href="#Simple-Kalman-filtering">Simple Kalman filtering</a><a id="Simple-Kalman-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Kalman-filtering" title="Permalink"></a></h2><p>We will use a Kalman filter to perform the filtering. The model is a double integrator, i.e., a constant-acceleration model. The state vector is thus <span>$x = [p, v]^T$</span>, where <span>$p$</span> is the position and <span>$v$</span> is the velocity. When designing a Kalman filter, we need to specify the noise covariances <span>$R_1$</span> and <span>$R_2$</span>. While it&#39;s often easy to measure the covariance of the measurement noise, <span>$R_2$</span>, it can be quite difficult to know ahead of time what the dynamics noise covariance, <span>$R_1$</span>, should be. In this example, we will use an adaptive filter, where we will increase the dynamics noise covariance if the filter prediction error is too large. However, we first run the filter twice, once with a large <span>$R_1$</span> and once with a small <span>$R_1$</span> to illustrate the difference.</p><pre><code class="language-julia hljs">y = [[y] for y in Y] # create a vector of vectors for the KF
u = fill([], T) # No inputs in this example :(

# Define the model
Ts = 1
A = [1 Ts; 0 1]
B = zeros(2, 0)
C = [1 0]
D = zeros(0, 0)
R2 = [1;;]

σws = [1e-2, 1e-5] # Dynamics noise standard deviations

fig = plot(Y, lab=&quot;Measurement&quot;)
for σw in σws
    R1 = σw*[Ts^3/3 Ts^2/2; Ts^2/2 Ts] # The dynamics noise covariance matrix is σw*Bw*Bw&#39; where Bw = [Ts^2/2; Ts]
    kf = KalmanFilter(A, B, C, D, R1, R2)
    measure = LowLevelParticleFilters.measurement(kf)
    yh = [measure(state(kf), u[1], nothing, 1)]
    for t = 1:T # Main filter loop
        kf(u[t], y[t]) # Performs both prediction and correction
        xh = state(kf)
        yht = measure(xh, u[t], nothing, t)
        push!(yh, yht)
    end

    Yh = reduce(hcat, yh)
    plot!(Yh&#39;, lab=&quot;Estimate \$σ_w\$ = $σw&quot;)
end
fig</code></pre><img src="db9489de.svg" alt="Example block output"/><p>When <span>$R_1$</span> is small (controlled by <span>$σ_w$</span>), we get a nice and smooth filter estimate, but this estimate clearly lags behind the true state. When <span>$R_1$</span> is large, the filter estimate is much more responsive, but it also has a lot of noise.</p><h2 id="Adaptive-noise-covariance"><a class="docs-heading-anchor" href="#Adaptive-noise-covariance">Adaptive noise covariance</a><a id="Adaptive-noise-covariance-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-noise-covariance" title="Permalink"></a></h2><p>Below, we will implement an adaptive filter, where we keep the dynamics noise covariance low by default, but increase it if the filter prediction error is too large. We will use a Z-score to determine if the prediction error is too large. The Z-score is defined as the number of standard deviations the prediction error is away from the estimated mean. This time around we use separate <a href="../api/#LowLevelParticleFilters.correct!"><code>correct!</code></a> and <a href="../api/#StatsAPI.predict!"><code>predict!</code></a> calls, so that we can access the prediction error as well as the prior covariance of the prediction error, <span>$S$</span>. <span>$S$</span> (or the Cholesky factor <span>$Sᵪ$</span>) will be used to compute the Z-score.</p><p>When implementing behavior such as time varying covariance, we may either implement the filtering loop manually, like we do below, or make use of the callback functionality available in <a href="../api/#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a>, which we do in the next code snippet.</p><pre><code class="language-julia hljs">σw = 1e-5 # Set the covariance to a low value by default
R1 = σw*[Ts^3/3 Ts^2/2; Ts^2/2 Ts]
kf = KalmanFilter(A, B, C, D, R1, R2)
measure = LowLevelParticleFilters.measurement(kf)

# Some arrays to store simulation data
yh = []
es = Float64[]
σs = Float64[]
for t = 1:T # Main filter loop
    ll, e, S, Sᵪ = correct!(kf, u[t], y[t], nothing, t) # Manually call the prediction step
    xh = state(kf)
    yht = measure(xh, u[t], nothing, t)

    σ = √(e&#39;*(Sᵪ\e)) # Compute the Z-score
    push!(es, e[]) # Save for plotting
    push!(σs, σ)
    if σ &gt; 3 # If the Z-score is too high
        # we temporarily increase the dynamics noise covariance by 1000x to adapt faster
        predict!(kf, u[t], nothing, t; R1 = 1000kf.R1)
    else
        predict!(kf, u[t], nothing, t)
    end

    push!(yh, yht)
end

Yh = reduce(hcat, yh)
plot([Y Yh&#39;], lab=[&quot;Measurement&quot; &quot;Adaptive estimate&quot;])</code></pre><img src="cd889386.svg" alt="Example block output"/><p>Not too bad! This time the filter estimate is much more responsive during the transition, but exhibits favorable noise properties during the stationary phases. We can also plot the prediction error and the Z-score to see how the filter adapts to the dynamics noise covariance.</p><pre><code class="language-julia hljs">plot([es σs], lab=[&quot;Prediction error&quot; &quot;Z-score&quot;])</code></pre><img src="fac3172a.svg" alt="Example block output"/><p>Notice how the prediction errors, that should ideally be centered around zero, remain predominantly negative for a long time interval after the transition. This can be attributed to an overshoot in the velocity state of the estimator, but the rapid decrease of the covariance after the transition makes the filter slow at correcting its overshoot. If we want, we could mitigate this and make the adaptation even more sophisticated by letting the covariance remain large for a while after a transition in operating mode has been detected. Below, we implement a simple version of this, where we use a multiplier <span>$σ_{wt}$</span> that defaults to 1, but is increase to a very large value of 1000 if a transition is detected. When no transition is detected, <span>$σ_{wt}$</span> is decreased exponentially back down to 1.</p><p>As mentioned above, in this code snippet we make use of the callback functionality of <a href="../api/#LowLevelParticleFilters.forward_trajectory"><code>forward_trajectory</code></a> rather than implementing the filtering loop manually, we thus add the logic for modifying the covariance in the <code>pre_predict_cb</code> callback function. </p><pre><code class="language-julia hljs">σw  = 1e-5 # Set the covariance to a low value by default
σwt = 1.0
R1  = σw*[Ts^3/3 Ts^2/2; Ts^2/2 Ts]
kf  = KalmanFilter(A, B, C, D, R1, R2)
measure = LowLevelParticleFilters.measurement(kf)

function pre_predict_cb(kf, u, y, p, t, ll, e, S, Sᵪ)
    σ = √(e&#39;*(Sᵪ\e)) # Compute the Z-score
    global σwt
    if σ &gt; 3 # If the Z-score is too high
        σwt = 1000.0 # Set the R1 multiplier to a very large value
    else
        σwt = max(0.9σwt, 1.0) # Decrease exponentially back to 1
    end
    push!(σs, σ)
    push!(σwts, σwt)
    σwt*kf.R1 # The pre_predict_cb may return either nothing (operate through side effects) or a modified R1 matrix to use for this particular time step. Here, we make use of both approaches.
end

# Some arrays to store simulation data
σs = Float64[]
σwts = Float64[]

sol = forward_trajectory(kf, u, y; pre_predict_cb)
es = reduce(vcat, sol.e) # Extract prediciton errors
Yh = reduce(hcat, measure.(sol.xt, sol.u, nothing, nothing)) # Extract predicted outputs
plot([Y Yh&#39;], lab=[&quot;Measurement&quot; &quot;Adaptive estimate&quot;])</code></pre><img src="d8d32842.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot([es σs σwts], lab=[&quot;Prediction error&quot; &quot;Z-score&quot; &quot;\$σ_{wt}\$ multiplier&quot;], layout=2, sp=[1 1 2])</code></pre><img src="ab41453c.svg" alt="Example block output"/><p>This time, the prediction errors look more like white noise centered around zero after the initial transient caused by the transition.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This tutorial demonstrated simple Kalman filtering for a double integrator without control inputs. We saw how the filtering estimate could be improved by playing around with the covariance matrices of the estimator, helping it catch up to fast changes in the behavior of the system without sacrificing steady-state noise properties.</p><p>In this case, we handled the modification of <span>$R_1$</span> outside of the filter, implementing our own filtering loop. Some applications get away with instead providing time-varying matrices in the form of a 3-dimension array, where the third dimension corresponds to time, or instead of providing a matrix, providing a function <span>$R_1(x, u, p, t)$</span> allows the matrix to be a function of state, input, parameters and time. These options apply to all matrices in the filter, including the dynamics matrices, <span>$A,B,C,D$</span>.</p><p>Lastly, we mention the ability of the <a href="../api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> to act like a recursive least-squares estimator, by setting the &quot;forgetting factor <span>$α&gt;1$</span> when creating the <a href="../api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a>. <span>$α&gt;1$</span> will cause the filter will exhibit exponential forgetting similar to an RLS estimator, in addition to the covariance inflation due to R1. It is thus possible to get a RLS-like algorithm by setting <span>$R_1 = 0, R_2 = 1/α$</span> and <span>$α &gt; 1$</span>.</p><h2 id="Disturbance-modeling-and-noise-tuning"><a class="docs-heading-anchor" href="#Disturbance-modeling-and-noise-tuning">Disturbance modeling and noise tuning</a><a id="Disturbance-modeling-and-noise-tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Disturbance-modeling-and-noise-tuning" title="Permalink"></a></h2><p>See <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">this notebook</a> for a blog post about disturbance modeling and noise tuning using LowLevelParticleFilter.jl</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distributions/">« Performance tips</a><a class="docs-footer-nextpage" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 31 August 2025 11:00">Sunday 31 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
