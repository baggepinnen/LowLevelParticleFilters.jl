<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discretization · LowLevelParticleFilters Documentation</title><meta name="title" content="Discretization · LowLevelParticleFilters Documentation"/><meta property="og:title" content="Discretization · LowLevelParticleFilters Documentation"/><meta property="twitter:title" content="Discretization · LowLevelParticleFilters Documentation"/><meta name="description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="og:description" content="Documentation for LowLevelParticleFilters Documentation."/><meta property="twitter:description" content="Documentation for LowLevelParticleFilters Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelParticleFilters Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Discretization</a><ul class="internal"><li><a class="tocitem" href="#Nonlinear-ODEs"><span>Nonlinear ODEs</span></a></li><li><a class="tocitem" href="#Linear-systems"><span>Linear systems</span></a></li><li><a class="tocitem" href="#Covariance-matrices"><span>Covariance matrices</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Non-uniform-sample-rates"><span>Non-uniform sample rates</span></a></li></ul></li><li><a class="tocitem" href="../parameter_estimation/">Parameter estimation</a></li><li><a class="tocitem" href="../benchmark/">Benchmark</a></li><li><a class="tocitem" href="../distributions/">Performance tips</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../adaptive_kalmanfilter/">Kalman-filter tutorial with LowLevelParticleFilters</a></li><li><a class="tocitem" href="../noisetuning/">Noise tuning and disturbance modeling for Kalman filtering</a></li><li><a class="tocitem" href="../beetle_example/">Particle-filter tutorial</a></li><li><a class="tocitem" href="../dae/">State estimation for DAE systems</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Discretization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Discretization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/LowLevelParticleFilters.jl/blob/master/docs/src/discretization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h1><p>This package operates exclusively on discrete-time dynamics, and dynamics describing, e.g., ODE systems must thus be discretized. This page describes the details around discretization for nonlinear and linear systems, as well as how to discretize continuous-time noise processes. </p><h2 id="Nonlinear-ODEs"><a class="docs-heading-anchor" href="#Nonlinear-ODEs">Nonlinear ODEs</a><a id="Nonlinear-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-ODEs" title="Permalink"></a></h2><p>Continuous-time dynamics functions on the form <code>(x,u,p,t) -&gt; ẋ</code> can be discretized (integrated) using the function <a href="https://baggepinnen.github.io/SeeToDee.jl/dev/api/#SeeToDee.Rk4"><code>SeeToDee.Rk4</code></a>, e.g.,</p><pre><code class="language-julia hljs">using SeeToDee
discrete_dynamics = SeeToDee.Rk4(continuous_dynamics, sampletime; supersample=1)</code></pre><p>where the integer <code>supersample</code> determines the number of RK4 steps that is taken internally for each change of the control signal (1 is often sufficient and is the default). The returned function <code>discrete_dynamics</code> is on the form <code>(x,u,p,t) -&gt; x⁺</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When solving state-estimation problems, accurate integration is often less important than during simulation. The motivations for this are several</p><ul><li>The dynamics model is often inaccurate, and solving an inaccurate model to high accuracy can be a waste of effort.</li><li>The performance is often dictated by the disturbances acting on the system.</li><li>State-estimation enjoys feedback from measurements that corrects for slight errors due to integration.</li></ul></div></div><h2 id="Linear-systems"><a class="docs-heading-anchor" href="#Linear-systems">Linear systems</a><a id="Linear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-systems" title="Permalink"></a></h2><p>A linear system on the form </p><p class="math-container">\[\begin{aligned}
\dot{x}(t) &amp;= Ax(t) + Bu(t)\\
y(t) &amp;= Cx(t) + Du(t)
\end{aligned}\]</p><p>can be discretized using <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/lib/synthesis/#ControlSystemsBase.c2d"><code>ControlSystems.c2d</code></a>, which defaults to a zero-order hold discretization. See the example below for more info.</p><h2 id="Covariance-matrices"><a class="docs-heading-anchor" href="#Covariance-matrices">Covariance matrices</a><a id="Covariance-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-matrices" title="Permalink"></a></h2><p>Covariance matrices for continuous-time noise processes can also be discretized using <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/lib/synthesis/#ControlSystemsBase.c2d-Tuple{AbstractStateSpace{%3C:Continuous},%20AbstractMatrix,%20Real}"><code>ControlSystems.c2d</code></a></p><pre><code class="language-julia hljs">using ControlSystemIdentification
R1d = c2d(sys::StateSpace{&lt;:Discrete}, R1::Matrix)
R1d, R2d = c2d(sys::StateSpace{&lt;:Discrete}, R1::Matrix, R2::Matrix)</code></pre><p>This samples a continuous-time covariance matrix to fit the provided discrete-time system <code>sys</code>.</p><p>The method used comes from theorem 5 in the reference below.</p><blockquote><p>Ref: &quot;Discrete-time Solutions to the Continuous-time Differential Lyapunov Equation With Applications to Kalman Filtering&quot;,  Patrik Axelsson and Fredrik Gustafsson</p></blockquote><p><strong>On singular covariance matrices:</strong> The traditional double integrator with covariance matrix <code>Q = diagm([0,σ²])</code> can not be sampled with this method. Instead, the input matrix (&quot;Cholesky factor&quot;) of <code>Q</code> must be manually kept track of, e.g., the noise of variance <code>σ²</code> enters like <code>N = [0, 1]</code> which is sampled using ZoH and becomes <code>Nd = [Ts^2 / 2; Ts]</code> which results in the covariance matrix <code>σ² * Nd * Nd&#39;</code> (see example below).</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>The following example will discretize a linear double integrator system. Double integrators arise when the position of an object is controlled by a force, i.e., when Newtons second law <span>$f = ma$</span> governs the dynamics. The system can be written on the form</p><p class="math-container">\[\begin{aligned}
\dot x(t) &amp;= Ax(t) + Bu(t) + Nw(t)\\
y(t) &amp;= Cx(t) + e(t)
\end{aligned}\]</p><p>where <span>$N = B$</span> are both equal to <code>[0, 1]</code>, indicating that the noise <span>$w(t)$</span> enters like a force (this could be for instance due to air resistance or friction).</p><p>We start by defining the system that takes <span>$u$</span> as an input and discretize that with a sample time of <span>$T_s = 0.1$</span>.</p><pre><code class="language-julia hljs">using ControlSystemsBase
A = [0 1; 0 0]
B = [0; 1;;]
C = [1 0]
D = 0
Ts = 0.1 # Sample time

sys = ss(A,B,C,D)
sysd = c2d(sys, Ts) # Discretize the dynamics</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemsBase.StateSpace{ControlSystemsBase.Discrete{Float64}, Float64}
A = 
 1.0  0.1
 0.0  1.0
B = 
 0.005000000000000001
 0.1
C = 
 1.0  0.0
D = 
 0.0

Sample Time: 0.1 (seconds)
Discrete-time state-space model</code></pre><p>We then form another system, this time with <span>$w(t)$</span> as the input, and thus <span>$N$</span> as the input matrix instead of <span>$B$</span>. We assume that the noise has a standard deviation of <span>$\sigma_1 = 0.5$</span></p><pre><code class="language-julia hljs">σ1 = 0.5
N  = σ1*[0; 1;;]
sys_w  = ss(A,N,C,D)
sys_wd = c2d(sys_w, Ts) # Discretize the noise system
Nd  = sys_wd.B # The discretized noise input matrix
R1d = Nd*Nd&#39; # The final discrete-time covariance matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 6.25e-6   0.000125
 0.000125  0.0025</code></pre><p>We can verify that the matrix we computed corresponds to the theoretical covariance matrix for a discrete-time double integrator:</p><pre><code class="language-julia hljs">R1d ≈ σ1^2*[Ts^2 / 2; Ts]*[Ts^2 / 2; Ts]&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>For a nonlinear system, we could adopt a similar strategy by first linearizing the system around a suitable operating point. Alternatively, we could make use of the fact that some of the state estimators in this package allows the covariance matrices to be functions of the state, and thus compute a new discretized covariance matrix using a linearization around the current state.</p><h2 id="Non-uniform-sample-rates"><a class="docs-heading-anchor" href="#Non-uniform-sample-rates">Non-uniform sample rates</a><a id="Non-uniform-sample-rates-1"></a><a class="docs-heading-anchor-permalink" href="#Non-uniform-sample-rates" title="Permalink"></a></h2><p>Special care is needed if the sample rate is not constant, i.e., the time interval between measurements varies. </p><h3 id="Dropped-samples"><a class="docs-heading-anchor" href="#Dropped-samples">Dropped samples</a><a id="Dropped-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Dropped-samples" title="Permalink"></a></h3><p>A common case is that the sample rate is constant, but some measurements are lost. This case is very easy to handle; the filter loop iterates between two steps</p><ol><li>Prediction using <code>predict!(filter, x, u, p, t)</code></li><li>Correction using <code>correct!(f, u, y, p, t)</code></li></ol><p>If a measurement <code>y</code> is lacking, one simply skips the corresponding call to <code>correct!</code> where <code>y</code> is missing. Repeated calls to <code>predict!</code> corresponds to simulating the system without any feedback from measurements, like if an ODE was solved. Internally, the filter will keep track of the covariance of the estimate, which is likely to grow if no measurements are used to inform the filter about the state of the system.</p><h3 id="Stochastic-sample-rate"><a class="docs-heading-anchor" href="#Stochastic-sample-rate">Stochastic sample rate</a><a id="Stochastic-sample-rate-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-sample-rate" title="Permalink"></a></h3><p>In some situations, such as in event-based systems, the sample rate is truly stochastic. There is no single correct way of handling this, and we instead outline some alternative approaches.</p><ul><li>If the filtering is performed offline on a batch of data, time-varying dynamics can be used, for instance by supplying matrices to a <a href="../api/#LowLevelParticleFilters.KalmanFilter"><code>KalmanFilter</code></a> on the form <code>A[:, :, t]</code>. Each <code>A</code> is then computed as the discretization with the sample time given as the time between measurement <code>t</code> and measurement <code>t+1</code>.</li><li>A conceptually simple approach is to choose a very small sample interval <span>$T_s$</span> which is smaller than the smallest occuring sample interval in the data, and approximate each sample interval by rounding it to the nearest integer multiple of <span>$T_s$</span>. This transforms the problem to an instance of the &quot;dropped samples&quot; problem described above.</li><li>Make use of an adaptive integrator instead of the fixed-step <code>rk4</code> supplied in this package, and manually keep track of the step length that needs to be taken.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../parameter_estimation/">Parameter estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 18 November 2024 08:06">Monday 18 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
